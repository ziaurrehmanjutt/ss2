require.config({"config": {
        "jsbuild":{"js/owl.carousel.js":"/**\n * Owl Carousel v2.3.4\n * Copyright 2013-2018 David Deutsch\n * Licensed under: SEE LICENSE IN https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE\n */\n/**\n * Owl carousel\n * @version 2.3.4\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n * @todo Lazy Load Icon\n * @todo prevent animationend bubling\n * @todo itemsScaleUp\n * @todo Test Zepto\n * @todo stagePadding calculate wrong active classes\n */\ndefine([\"jquery\"], function ($) {\n    ;(function ($, window, document, undefined) {\n\n        /**\n         * Creates a carousel.\n         * @class The Owl Carousel.\n         * @public\n         * @param {HTMLElement|jQuery} element - The element to create the carousel for.\n         * @param {Object} [options] - The options\n         */\n        function Owl(element, options) {\n\n            /**\n             * Current settings for the carousel.\n             * @public\n             */\n            this.settings = null;\n\n            /**\n             * Current options set by the caller including defaults.\n             * @public\n             */\n            this.options = $.extend({}, Owl.Defaults, options);\n\n            /**\n             * Plugin element.\n             * @public\n             */\n            this.$element = $(element);\n\n            /**\n             * Proxied event handlers.\n             * @protected\n             */\n            this._handlers = {};\n\n            /**\n             * References to the running plugins of this carousel.\n             * @protected\n             */\n            this._plugins = {};\n\n            /**\n             * Currently suppressed events to prevent them from being retriggered.\n             * @protected\n             */\n            this._supress = {};\n\n            /**\n             * Absolute current position.\n             * @protected\n             */\n            this._current = null;\n\n            /**\n             * Animation speed in milliseconds.\n             * @protected\n             */\n            this._speed = null;\n\n            /**\n             * Coordinates of all items in pixel.\n             * @todo The name of this member is missleading.\n             * @protected\n             */\n            this._coordinates = [];\n\n            /**\n             * Current breakpoint.\n             * @todo Real media queries would be nice.\n             * @protected\n             */\n            this._breakpoint = null;\n\n            /**\n             * Current width of the plugin element.\n             */\n            this._width = null;\n\n            /**\n             * All real items.\n             * @protected\n             */\n            this._items = [];\n\n            /**\n             * All cloned items.\n             * @protected\n             */\n            this._clones = [];\n\n            /**\n             * Merge values of all items.\n             * @todo Maybe this could be part of a plugin.\n             * @protected\n             */\n            this._mergers = [];\n\n            /**\n             * Widths of all items.\n             */\n            this._widths = [];\n\n            /**\n             * Invalidated parts within the update process.\n             * @protected\n             */\n            this._invalidated = {};\n\n            /**\n             * Ordered list of workers for the update process.\n             * @protected\n             */\n            this._pipe = [];\n\n            /**\n             * Current state information for the drag operation.\n             * @todo #261\n             * @protected\n             */\n            this._drag = {\n                time: null,\n                target: null,\n                pointer: null,\n                stage: {\n                    start: null,\n                    current: null\n                },\n                direction: null\n            };\n\n            /**\n             * Current state information and their tags.\n             * @type {Object}\n             * @protected\n             */\n            this._states = {\n                current: {},\n                tags: {\n                    'initializing': ['busy'],\n                    'animating': ['busy'],\n                    'dragging': ['interacting']\n                }\n            };\n\n            $.each(['onResize', 'onThrottledResize'], $.proxy(function (i, handler) {\n                this._handlers[handler] = $.proxy(this[handler], this);\n            }, this));\n\n            $.each(Owl.Plugins, $.proxy(function (key, plugin) {\n                this._plugins[key.charAt(0).toLowerCase() + key.slice(1)]\n                    = new plugin(this);\n            }, this));\n\n            $.each(Owl.Workers, $.proxy(function (priority, worker) {\n                this._pipe.push({\n                    'filter': worker.filter,\n                    'run': $.proxy(worker.run, this)\n                });\n            }, this));\n\n            this.setup();\n            this.initialize();\n        }\n\n        /**\n         * Default options for the carousel.\n         * @public\n         */\n        Owl.Defaults = {\n            items: 3,\n            loop: false,\n            center: false,\n            rewind: false,\n            checkVisibility: true,\n\n            mouseDrag: true,\n            touchDrag: true,\n            pullDrag: true,\n            freeDrag: false,\n\n            margin: 0,\n            stagePadding: 0,\n\n            merge: false,\n            mergeFit: true,\n            autoWidth: false,\n\n            startPosition: 0,\n            rtl: false,\n\n            smartSpeed: 250,\n            fluidSpeed: false,\n            dragEndSpeed: false,\n\n            responsive: {},\n            responsiveRefreshRate: 200,\n            responsiveBaseElement: window,\n\n            fallbackEasing: 'swing',\n            slideTransition: '',\n\n            info: false,\n\n            nestedItemSelector: false,\n            itemElement: 'div',\n            stageElement: 'div',\n\n            refreshClass: 'owl-refresh',\n            loadedClass: 'owl-loaded',\n            loadingClass: 'owl-loading',\n            rtlClass: 'owl-rtl',\n            responsiveClass: 'owl-responsive',\n            dragClass: 'owl-drag',\n            itemClass: 'owl-item',\n            stageClass: 'owl-stage',\n            stageOuterClass: 'owl-stage-outer',\n            grabClass: 'owl-grab'\n        };\n\n        /**\n         * Enumeration for width.\n         * @public\n         * @readonly\n         * @enum {String}\n         */\n        Owl.Width = {\n            Default: 'default',\n            Inner: 'inner',\n            Outer: 'outer'\n        };\n\n        /**\n         * Enumeration for types.\n         * @public\n         * @readonly\n         * @enum {String}\n         */\n        Owl.Type = {\n            Event: 'event',\n            State: 'state'\n        };\n\n        /**\n         * Contains all registered plugins.\n         * @public\n         */\n        Owl.Plugins = {};\n\n        /**\n         * List of workers involved in the update process.\n         */\n        Owl.Workers = [{\n            filter: ['width', 'settings'],\n            run: function () {\n                this._width = this.$element.width();\n            }\n        }, {\n            filter: ['width', 'items', 'settings'],\n            run: function (cache) {\n                cache.current = this._items && this._items[this.relative(this._current)];\n            }\n        }, {\n            filter: ['items', 'settings'],\n            run: function () {\n                this.$stage.children('.cloned').remove();\n            }\n        }, {\n            filter: ['width', 'items', 'settings'],\n            run: function (cache) {\n                var margin = this.settings.margin || '',\n                    grid = !this.settings.autoWidth,\n                    rtl = this.settings.rtl,\n                    css = {\n                        'width': 'auto',\n                        'margin-left': rtl ? margin : '',\n                        'margin-right': rtl ? '' : margin\n                    };\n\n                !grid && this.$stage.children().css(css);\n\n                cache.css = css;\n            }\n        }, {\n            filter: ['width', 'items', 'settings'],\n            run: function (cache) {\n                var width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,\n                    merge = null,\n                    iterator = this._items.length,\n                    grid = !this.settings.autoWidth,\n                    widths = [];\n\n                cache.items = {\n                    merge: false,\n                    width: width\n                };\n\n                while (iterator--) {\n                    merge = this._mergers[iterator];\n                    merge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;\n\n                    cache.items.merge = merge > 1 || cache.items.merge;\n\n                    widths[iterator] = !grid ? this._items[iterator].width() : width * merge;\n                }\n\n                this._widths = widths;\n            }\n        }, {\n            filter: ['items', 'settings'],\n            run: function () {\n                var clones = [],\n                    items = this._items,\n                    settings = this.settings,\n                    // TODO: Should be computed from number of min width items in stage\n                    view = Math.max(settings.items * 2, 4),\n                    size = Math.ceil(items.length / 2) * 2,\n                    repeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0,\n                    append = '',\n                    prepend = '';\n\n                repeat /= 2;\n\n                while (repeat > 0) {\n                    // Switch to only using appended clones\n                    clones.push(this.normalize(clones.length / 2, true));\n                    append = append + items[clones[clones.length - 1]][0].outerHTML;\n                    clones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));\n                    prepend = items[clones[clones.length - 1]][0].outerHTML + prepend;\n                    repeat -= 1;\n                }\n\n                this._clones = clones;\n\n                $(append).addClass('cloned').appendTo(this.$stage);\n                $(prepend).addClass('cloned').prependTo(this.$stage);\n            }\n        }, {\n            filter: ['width', 'items', 'settings'],\n            run: function () {\n                var rtl = this.settings.rtl ? 1 : -1,\n                    size = this._clones.length + this._items.length,\n                    iterator = -1,\n                    previous = 0,\n                    current = 0,\n                    coordinates = [];\n\n                while (++iterator < size) {\n                    previous = coordinates[iterator - 1] || 0;\n                    current = this._widths[this.relative(iterator)] + this.settings.margin;\n                    coordinates.push(previous + current * rtl);\n                }\n\n                this._coordinates = coordinates;\n            }\n        }, {\n            filter: ['width', 'items', 'settings'],\n            run: function () {\n                var padding = this.settings.stagePadding,\n                    coordinates = this._coordinates,\n                    css = {\n                        'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,\n                        'padding-left': padding || '',\n                        'padding-right': padding || ''\n                    };\n\n                this.$stage.css(css);\n            }\n        }, {\n            filter: ['width', 'items', 'settings'],\n            run: function (cache) {\n                var iterator = this._coordinates.length,\n                    grid = !this.settings.autoWidth,\n                    items = this.$stage.children();\n\n                if (grid && cache.items.merge) {\n                    while (iterator--) {\n                        cache.css.width = this._widths[this.relative(iterator)];\n                        items.eq(iterator).css(cache.css);\n                    }\n                } else if (grid) {\n                    cache.css.width = cache.items.width;\n                    items.css(cache.css);\n                }\n            }\n        }, {\n            filter: ['items'],\n            run: function () {\n                this._coordinates.length < 1 && this.$stage.removeAttr('style');\n            }\n        }, {\n            filter: ['width', 'items', 'settings'],\n            run: function (cache) {\n                cache.current = cache.current ? this.$stage.children().index(cache.current) : 0;\n                cache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));\n                this.reset(cache.current);\n            }\n        }, {\n            filter: ['position'],\n            run: function () {\n                this.animate(this.coordinates(this._current));\n            }\n        }, {\n            filter: ['width', 'position', 'items', 'settings'],\n            run: function () {\n                var rtl = this.settings.rtl ? 1 : -1,\n                    padding = this.settings.stagePadding * 2,\n                    begin = this.coordinates(this.current()) + padding,\n                    end = begin + this.width() * rtl,\n                    inner, outer, matches = [], i, n;\n\n                for (i = 0, n = this._coordinates.length; i < n; i++) {\n                    inner = this._coordinates[i - 1] || 0;\n                    outer = Math.abs(this._coordinates[i]) + padding * rtl;\n\n                    if ((this.op(inner, '<=', begin) && (this.op(inner, '>', end)))\n                        || (this.op(outer, '<', begin) && this.op(outer, '>', end))) {\n                        matches.push(i);\n                    }\n                }\n\n                this.$stage.children('.active').removeClass('active');\n                this.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');\n\n                this.$stage.children('.center').removeClass('center');\n                if (this.settings.center) {\n                    this.$stage.children().eq(this.current()).addClass('center');\n                }\n            }\n        }];\n\n        /**\n         * Create the stage DOM element\n         */\n        Owl.prototype.initializeStage = function () {\n            this.$stage = this.$element.find('.' + this.settings.stageClass);\n\n            // if the stage is already in the DOM, grab it and skip stage initialization\n            if (this.$stage.length) {\n                return;\n            }\n\n            this.$element.addClass(this.options.loadingClass);\n\n            // create stage\n            this.$stage = $('<' + this.settings.stageElement + '>', {\n                \"class\": this.settings.stageClass\n            }).wrap($('<div/>', {\n                \"class\": this.settings.stageOuterClass\n            }));\n\n            // append stage\n            this.$element.append(this.$stage.parent());\n        };\n\n        /**\n         * Create item DOM elements\n         */\n        Owl.prototype.initializeItems = function () {\n            var $items = this.$element.find('.owl-item');\n\n            // if the items are already in the DOM, grab them and skip item initialization\n            if ($items.length) {\n                this._items = $items.get().map(function (item) {\n                    return $(item);\n                });\n\n                this._mergers = this._items.map(function () {\n                    return 1;\n                });\n\n                this.refresh();\n\n                return;\n            }\n\n            // append content\n            this.replace(this.$element.children().not(this.$stage.parent()));\n\n            // check visibility\n            if (this.isVisible()) {\n                // update view\n                this.refresh();\n            } else {\n                // invalidate width\n                this.invalidate('width');\n            }\n\n            this.$element\n                .removeClass(this.options.loadingClass)\n                .addClass(this.options.loadedClass);\n        };\n\n        /**\n         * Initializes the carousel.\n         * @protected\n         */\n        Owl.prototype.initialize = function () {\n            this.enter('initializing');\n            this.trigger('initialize');\n\n            this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);\n\n            if (this.settings.autoWidth && !this.is('pre-loading')) {\n                var imgs, nestedSelector, width;\n                imgs = this.$element.find('img');\n                nestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;\n                width = this.$element.children(nestedSelector).width();\n\n                if (imgs.length && width <= 0) {\n                    this.preloadAutoWidthImages(imgs);\n                }\n            }\n\n            this.initializeStage();\n            this.initializeItems();\n\n            // register event handlers\n            this.registerEventHandlers();\n\n            this.leave('initializing');\n            this.trigger('initialized');\n        };\n\n        /**\n         * @returns {Boolean} visibility of $element\n         *                    if you know the carousel will always be visible you can set `checkVisibility` to `false` to\n         *                    prevent the expensive browser layout forced reflow the $element.is(':visible') does\n         */\n        Owl.prototype.isVisible = function () {\n            return this.settings.checkVisibility\n                ? this.$element.is(':visible')\n                : true;\n        };\n\n        /**\n         * Setups the current settings.\n         * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?\n         * @todo Support for media queries by using `matchMedia` would be nice.\n         * @public\n         */\n        Owl.prototype.setup = function () {\n            var viewport = this.viewport(),\n                overwrites = this.options.responsive,\n                match = -1,\n                settings = null;\n\n            if (!overwrites) {\n                settings = $.extend({}, this.options);\n            } else {\n                $.each(overwrites, function (breakpoint) {\n                    if (breakpoint <= viewport && breakpoint > match) {\n                        match = Number(breakpoint);\n                    }\n                });\n\n                settings = $.extend({}, this.options, overwrites[match]);\n                if (typeof settings.stagePadding === 'function') {\n                    settings.stagePadding = settings.stagePadding();\n                }\n                delete settings.responsive;\n\n                // responsive class\n                if (settings.responsiveClass) {\n                    this.$element.attr('class',\n                        this.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\\\S+\\\\s', 'g'), '$1' + match)\n                    );\n                }\n            }\n\n            this.trigger('change', {property: {name: 'settings', value: settings}});\n            this._breakpoint = match;\n            this.settings = settings;\n            this.invalidate('settings');\n            this.trigger('changed', {property: {name: 'settings', value: this.settings}});\n        };\n\n        /**\n         * Updates option logic if necessery.\n         * @protected\n         */\n        Owl.prototype.optionsLogic = function () {\n            if (this.settings.autoWidth) {\n                this.settings.stagePadding = false;\n                this.settings.merge = false;\n            }\n        };\n\n        /**\n         * Prepares an item before add.\n         * @todo Rename event parameter `content` to `item`.\n         * @protected\n         * @returns {jQuery|HTMLElement} - The item container.\n         */\n        Owl.prototype.prepare = function (item) {\n            var event = this.trigger('prepare', {content: item});\n\n            if (!event.data) {\n                event.data = $('<' + this.settings.itemElement + '/>')\n                    .addClass(this.options.itemClass).append(item)\n            }\n\n            this.trigger('prepared', {content: event.data});\n\n            return event.data;\n        };\n\n        /**\n         * Updates the view.\n         * @public\n         */\n        Owl.prototype.update = function () {\n            var i = 0,\n                n = this._pipe.length,\n                filter = $.proxy(function (p) {\n                    return this[p]\n                }, this._invalidated),\n                cache = {};\n\n            while (i < n) {\n                if (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {\n                    this._pipe[i].run(cache);\n                }\n                i++;\n            }\n\n            this._invalidated = {};\n\n            !this.is('valid') && this.enter('valid');\n        };\n\n        /**\n         * Gets the width of the view.\n         * @public\n         * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.\n         * @returns {Number} - The width of the view in pixel.\n         */\n        Owl.prototype.width = function (dimension) {\n            dimension = dimension || Owl.Width.Default;\n            switch (dimension) {\n                case Owl.Width.Inner:\n                case Owl.Width.Outer:\n                    return this._width;\n                default:\n                    return this._width - this.settings.stagePadding * 2 + this.settings.margin;\n            }\n        };\n\n        /**\n         * Refreshes the carousel primarily for adaptive purposes.\n         * @public\n         */\n        Owl.prototype.refresh = function () {\n            this.enter('refreshing');\n            this.trigger('refresh');\n\n            this.setup();\n\n            this.optionsLogic();\n\n            this.$element.addClass(this.options.refreshClass);\n\n            this.update();\n\n            this.$element.removeClass(this.options.refreshClass);\n\n            this.leave('refreshing');\n            this.trigger('refreshed');\n        };\n\n        /**\n         * Checks window `resize` event.\n         * @protected\n         */\n        Owl.prototype.onThrottledResize = function () {\n            window.clearTimeout(this.resizeTimer);\n            this.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);\n        };\n\n        /**\n         * Checks window `resize` event.\n         * @protected\n         */\n        Owl.prototype.onResize = function () {\n            if (!this._items.length) {\n                return false;\n            }\n\n            if (this._width === this.$element.width()) {\n                return false;\n            }\n\n            if (!this.isVisible()) {\n                return false;\n            }\n\n            this.enter('resizing');\n\n            if (this.trigger('resize').isDefaultPrevented()) {\n                this.leave('resizing');\n                return false;\n            }\n\n            this.invalidate('width');\n\n            this.refresh();\n\n            this.leave('resizing');\n            this.trigger('resized');\n        };\n\n        /**\n         * Registers event handlers.\n         * @todo Check `msPointerEnabled`\n         * @todo #261\n         * @protected\n         */\n        Owl.prototype.registerEventHandlers = function () {\n            if ($.support.transition) {\n                this.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));\n            }\n\n            if (this.settings.responsive !== false) {\n                this.on(window, 'resize', this._handlers.onThrottledResize);\n            }\n\n            if (this.settings.mouseDrag) {\n                this.$element.addClass(this.options.dragClass);\n                this.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));\n                this.$stage.on('dragstart.owl.core selectstart.owl.core', function () {\n                    return false\n                });\n            }\n\n            if (this.settings.touchDrag) {\n                this.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));\n                this.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));\n            }\n        };\n\n        /**\n         * Handles `touchstart` and `mousedown` events.\n         * @todo Horizontal swipe threshold as option\n         * @todo #261\n         * @protected\n         * @param {Event} event - The event arguments.\n         */\n        Owl.prototype.onDragStart = function (event) {\n            var stage = null;\n\n            if (event.which === 3) {\n                return;\n            }\n\n            if ($.support.transform) {\n                stage = this.$stage.css('transform').replace(/.*\\(|\\)| /g, '').split(',');\n                stage = {\n                    x: stage[stage.length === 16 ? 12 : 4],\n                    y: stage[stage.length === 16 ? 13 : 5]\n                };\n            } else {\n                stage = this.$stage.position();\n                stage = {\n                    x: this.settings.rtl ?\n                        stage.left + this.$stage.width() - this.width() + this.settings.margin :\n                        stage.left,\n                    y: stage.top\n                };\n            }\n\n            if (this.is('animating')) {\n                $.support.transform ? this.animate(stage.x) : this.$stage.stop()\n                this.invalidate('position');\n            }\n\n            this.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');\n\n            this.speed(0);\n\n            this._drag.time = new Date().getTime();\n            this._drag.target = $(event.target);\n            this._drag.stage.start = stage;\n            this._drag.stage.current = stage;\n            this._drag.pointer = this.pointer(event);\n\n            $(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));\n\n            $(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function (event) {\n                var delta = this.difference(this._drag.pointer, this.pointer(event));\n\n                $(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));\n\n                if (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {\n                    return;\n                }\n\n                event.preventDefault();\n\n                this.enter('dragging');\n                this.trigger('drag');\n            }, this));\n        };\n\n        /**\n         * Handles the `touchmove` and `mousemove` events.\n         * @todo #261\n         * @protected\n         * @param {Event} event - The event arguments.\n         */\n        Owl.prototype.onDragMove = function (event) {\n            var minimum = null,\n                maximum = null,\n                pull = null,\n                delta = this.difference(this._drag.pointer, this.pointer(event)),\n                stage = this.difference(this._drag.stage.start, delta);\n\n            if (!this.is('dragging')) {\n                return;\n            }\n\n            event.preventDefault();\n\n            if (this.settings.loop) {\n                minimum = this.coordinates(this.minimum());\n                maximum = this.coordinates(this.maximum() + 1) - minimum;\n                stage.x = (((stage.x - minimum) % maximum + maximum) % maximum) + minimum;\n            } else {\n                minimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());\n                maximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());\n                pull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;\n                stage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);\n            }\n\n            this._drag.stage.current = stage;\n\n            this.animate(stage.x);\n        };\n\n        /**\n         * Handles the `touchend` and `mouseup` events.\n         * @todo #261\n         * @todo Threshold for click event\n         * @protected\n         * @param {Event} event - The event arguments.\n         */\n        Owl.prototype.onDragEnd = function (event) {\n            var delta = this.difference(this._drag.pointer, this.pointer(event)),\n                stage = this._drag.stage.current,\n                direction = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';\n\n            $(document).off('.owl.core');\n\n            this.$element.removeClass(this.options.grabClass);\n\n            if (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {\n                this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);\n                this.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));\n                this.invalidate('position');\n                this.update();\n\n                this._drag.direction = direction;\n\n                if (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {\n                    this._drag.target.one('click.owl.core', function () {\n                        return false;\n                    });\n                }\n            }\n\n            if (!this.is('dragging')) {\n                return;\n            }\n\n            this.leave('dragging');\n            this.trigger('dragged');\n        };\n\n        /**\n         * Gets absolute position of the closest item for a coordinate.\n         * @todo Setting `freeDrag` makes `closest` not reusable. See #165.\n         * @protected\n         * @param {Number} coordinate - The coordinate in pixel.\n         * @param {String} direction - The direction to check for the closest item. Ether `left` or `right`.\n         * @return {Number} - The absolute position of the closest item.\n         */\n        Owl.prototype.closest = function (coordinate, direction) {\n            var position = -1,\n                pull = 30,\n                width = this.width(),\n                coordinates = this.coordinates();\n\n            if (!this.settings.freeDrag) {\n                // check closest item\n                $.each(coordinates, $.proxy(function (index, value) {\n                    // on a left pull, check on current index\n                    if (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {\n                        position = index;\n                        // on a right pull, check on previous index\n                        // to do so, subtract width from value and set position = index + 1\n                    } else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {\n                        position = index + 1;\n                    } else if (this.op(coordinate, '<', value)\n                        && this.op(coordinate, '>', coordinates[index + 1] !== undefined ? coordinates[index + 1] : value - width)) {\n                        position = direction === 'left' ? index + 1 : index;\n                    }\n                    return position === -1;\n                }, this));\n            }\n\n            if (!this.settings.loop) {\n                // non loop boundries\n                if (this.op(coordinate, '>', coordinates[this.minimum()])) {\n                    position = coordinate = this.minimum();\n                } else if (this.op(coordinate, '<', coordinates[this.maximum()])) {\n                    position = coordinate = this.maximum();\n                }\n            }\n\n            return position;\n        };\n\n        /**\n         * Animates the stage.\n         * @todo #270\n         * @public\n         * @param {Number} coordinate - The coordinate in pixels.\n         */\n        Owl.prototype.animate = function (coordinate) {\n            var animate = this.speed() > 0;\n\n            this.is('animating') && this.onTransitionEnd();\n\n            if (animate) {\n                this.enter('animating');\n                this.trigger('translate');\n            }\n\n            if ($.support.transform3d && $.support.transition) {\n                this.$stage.css({\n                    transform: 'translate3d(' + coordinate + 'px,0px,0px)',\n                    transition: (this.speed() / 1000) + 's' + (\n                        this.settings.slideTransition ? ' ' + this.settings.slideTransition : ''\n                    )\n                });\n            } else if (animate) {\n                this.$stage.animate({\n                    left: coordinate + 'px'\n                }, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));\n            } else {\n                this.$stage.css({\n                    left: coordinate + 'px'\n                });\n            }\n        };\n\n        /**\n         * Checks whether the carousel is in a specific state or not.\n         * @param {String} state - The state to check.\n         * @returns {Boolean} - The flag which indicates if the carousel is busy.\n         */\n        Owl.prototype.is = function (state) {\n            return this._states.current[state] && this._states.current[state] > 0;\n        };\n\n        /**\n         * Sets the absolute position of the current item.\n         * @public\n         * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.\n         * @returns {Number} - The absolute position of the current item.\n         */\n        Owl.prototype.current = function (position) {\n            if (position === undefined) {\n                return this._current;\n            }\n\n            if (this._items.length === 0) {\n                return undefined;\n            }\n\n            position = this.normalize(position);\n\n            if (this._current !== position) {\n                var event = this.trigger('change', {property: {name: 'position', value: position}});\n\n                if (event.data !== undefined) {\n                    position = this.normalize(event.data);\n                }\n\n                this._current = position;\n\n                this.invalidate('position');\n\n                this.trigger('changed', {property: {name: 'position', value: this._current}});\n            }\n\n            return this._current;\n        };\n\n        /**\n         * Invalidates the given part of the update routine.\n         * @param {String} [part] - The part to invalidate.\n         * @returns {Array.<String>} - The invalidated parts.\n         */\n        Owl.prototype.invalidate = function (part) {\n            if ($.type(part) === 'string') {\n                this._invalidated[part] = true;\n                this.is('valid') && this.leave('valid');\n            }\n            return $.map(this._invalidated, function (v, i) {\n                return i\n            });\n        };\n\n        /**\n         * Resets the absolute position of the current item.\n         * @public\n         * @param {Number} position - The absolute position of the new item.\n         */\n        Owl.prototype.reset = function (position) {\n            position = this.normalize(position);\n\n            if (position === undefined) {\n                return;\n            }\n\n            this._speed = 0;\n            this._current = position;\n\n            this.suppress(['translate', 'translated']);\n\n            this.animate(this.coordinates(position));\n\n            this.release(['translate', 'translated']);\n        };\n\n        /**\n         * Normalizes an absolute or a relative position of an item.\n         * @public\n         * @param {Number} position - The absolute or relative position to normalize.\n         * @param {Boolean} [relative=false] - Whether the given position is relative or not.\n         * @returns {Number} - The normalized position.\n         */\n        Owl.prototype.normalize = function (position, relative) {\n            var n = this._items.length,\n                m = relative ? 0 : this._clones.length;\n\n            if (!this.isNumeric(position) || n < 1) {\n                position = undefined;\n            } else if (position < 0 || position >= n + m) {\n                position = ((position - m / 2) % n + n) % n + m / 2;\n            }\n\n            return position;\n        };\n\n        /**\n         * Converts an absolute position of an item into a relative one.\n         * @public\n         * @param {Number} position - The absolute position to convert.\n         * @returns {Number} - The converted position.\n         */\n        Owl.prototype.relative = function (position) {\n            position -= this._clones.length / 2;\n            return this.normalize(position, true);\n        };\n\n        /**\n         * Gets the maximum position for the current item.\n         * @public\n         * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\n         * @returns {Number}\n         */\n        Owl.prototype.maximum = function (relative) {\n            var settings = this.settings,\n                maximum = this._coordinates.length,\n                iterator,\n                reciprocalItemsWidth,\n                elementWidth;\n\n            if (settings.loop) {\n                maximum = this._clones.length / 2 + this._items.length - 1;\n            } else if (settings.autoWidth || settings.merge) {\n                iterator = this._items.length;\n                if (iterator) {\n                    reciprocalItemsWidth = this._items[--iterator].width();\n                    elementWidth = this.$element.width();\n                    while (iterator--) {\n                        reciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;\n                        if (reciprocalItemsWidth > elementWidth) {\n                            break;\n                        }\n                    }\n                }\n                maximum = iterator + 1;\n            } else if (settings.center) {\n                maximum = this._items.length - 1;\n            } else {\n                maximum = this._items.length - settings.items;\n            }\n\n            if (relative) {\n                maximum -= this._clones.length / 2;\n            }\n\n            return Math.max(maximum, 0);\n        };\n\n        /**\n         * Gets the minimum position for the current item.\n         * @public\n         * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\n         * @returns {Number}\n         */\n        Owl.prototype.minimum = function (relative) {\n            return relative ? 0 : this._clones.length / 2;\n        };\n\n        /**\n         * Gets an item at the specified relative position.\n         * @public\n         * @param {Number} [position] - The relative position of the item.\n         * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\n         */\n        Owl.prototype.items = function (position) {\n            if (position === undefined) {\n                return this._items.slice();\n            }\n\n            position = this.normalize(position, true);\n            return this._items[position];\n        };\n\n        /**\n         * Gets an item at the specified relative position.\n         * @public\n         * @param {Number} [position] - The relative position of the item.\n         * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\n         */\n        Owl.prototype.mergers = function (position) {\n            if (position === undefined) {\n                return this._mergers.slice();\n            }\n\n            position = this.normalize(position, true);\n            return this._mergers[position];\n        };\n\n        /**\n         * Gets the absolute positions of clones for an item.\n         * @public\n         * @param {Number} [position] - The relative position of the item.\n         * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.\n         */\n        Owl.prototype.clones = function (position) {\n            var odd = this._clones.length / 2,\n                even = odd + this._items.length,\n                map = function (index) {\n                    return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2\n                };\n\n            if (position === undefined) {\n                return $.map(this._clones, function (v, i) {\n                    return map(i)\n                });\n            }\n\n            return $.map(this._clones, function (v, i) {\n                return v === position ? map(i) : null\n            });\n        };\n\n        /**\n         * Sets the current animation speed.\n         * @public\n         * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.\n         * @returns {Number} - The current animation speed in milliseconds.\n         */\n        Owl.prototype.speed = function (speed) {\n            if (speed !== undefined) {\n                this._speed = speed;\n            }\n\n            return this._speed;\n        };\n\n        /**\n         * Gets the coordinate of an item.\n         * @todo The name of this method is missleanding.\n         * @public\n         * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.\n         * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.\n         */\n        Owl.prototype.coordinates = function (position) {\n            var multiplier = 1,\n                newPosition = position - 1,\n                coordinate;\n\n            if (position === undefined) {\n                return $.map(this._coordinates, $.proxy(function (coordinate, index) {\n                    return this.coordinates(index);\n                }, this));\n            }\n\n            if (this.settings.center) {\n                if (this.settings.rtl) {\n                    multiplier = -1;\n                    newPosition = position + 1;\n                }\n\n                coordinate = this._coordinates[position];\n                coordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;\n            } else {\n                coordinate = this._coordinates[newPosition] || 0;\n            }\n\n            coordinate = Math.ceil(coordinate);\n\n            return coordinate;\n        };\n\n        /**\n         * Calculates the speed for a translation.\n         * @protected\n         * @param {Number} from - The absolute position of the start item.\n         * @param {Number} to - The absolute position of the target item.\n         * @param {Number} [factor=undefined] - The time factor in milliseconds.\n         * @returns {Number} - The time in milliseconds for the translation.\n         */\n        Owl.prototype.duration = function (from, to, factor) {\n            if (factor === 0) {\n                return 0;\n            }\n\n            return Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs((factor || this.settings.smartSpeed));\n        };\n\n        /**\n         * Slides to the specified item.\n         * @public\n         * @param {Number} position - The position of the item.\n         * @param {Number} [speed] - The time in milliseconds for the transition.\n         */\n        Owl.prototype.to = function (position, speed) {\n            var current = this.current(),\n                revert = null,\n                distance = position - this.relative(current),\n                direction = (distance > 0) - (distance < 0),\n                items = this._items.length,\n                minimum = this.minimum(),\n                maximum = this.maximum();\n\n            if (this.settings.loop) {\n                if (!this.settings.rewind && Math.abs(distance) > items / 2) {\n                    distance += direction * -1 * items;\n                }\n\n                position = current + distance;\n                revert = ((position - minimum) % items + items) % items + minimum;\n\n                if (revert !== position && revert - distance <= maximum && revert - distance > 0) {\n                    current = revert - distance;\n                    position = revert;\n                    this.reset(current);\n                }\n            } else if (this.settings.rewind) {\n                maximum += 1;\n                position = (position % maximum + maximum) % maximum;\n            } else {\n                position = Math.max(minimum, Math.min(maximum, position));\n            }\n\n            this.speed(this.duration(current, position, speed));\n            this.current(position);\n\n            if (this.isVisible()) {\n                this.update();\n            }\n        };\n\n        /**\n         * Slides to the next item.\n         * @public\n         * @param {Number} [speed] - The time in milliseconds for the transition.\n         */\n        Owl.prototype.next = function (speed) {\n            speed = speed || false;\n            this.to(this.relative(this.current()) + 1, speed);\n        };\n\n        /**\n         * Slides to the previous item.\n         * @public\n         * @param {Number} [speed] - The time in milliseconds for the transition.\n         */\n        Owl.prototype.prev = function (speed) {\n            speed = speed || false;\n            this.to(this.relative(this.current()) - 1, speed);\n        };\n\n        /**\n         * Handles the end of an animation.\n         * @protected\n         * @param {Event} event - The event arguments.\n         */\n        Owl.prototype.onTransitionEnd = function (event) {\n\n            // if css2 animation then event object is undefined\n            if (event !== undefined) {\n                event.stopPropagation();\n\n                // Catch only owl-stage transitionEnd event\n                if ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {\n                    return false;\n                }\n            }\n\n            this.leave('animating');\n            this.trigger('translated');\n        };\n\n        /**\n         * Gets viewport width.\n         * @protected\n         * @return {Number} - The width in pixel.\n         */\n        Owl.prototype.viewport = function () {\n            var width;\n            if (this.options.responsiveBaseElement !== window) {\n                width = $(this.options.responsiveBaseElement).width();\n            } else if (window.innerWidth) {\n                width = window.innerWidth;\n            } else if (document.documentElement && document.documentElement.clientWidth) {\n                width = document.documentElement.clientWidth;\n            } else {\n                console.warn('Can not detect viewport width.');\n            }\n            return width;\n        };\n\n        /**\n         * Replaces the current content.\n         * @public\n         * @param {HTMLElement|jQuery|String} content - The new content.\n         */\n        Owl.prototype.replace = function (content) {\n            this.$stage.empty();\n            this._items = [];\n\n            if (content) {\n                content = (content instanceof jQuery) ? content : $(content);\n            }\n\n            if (this.settings.nestedItemSelector) {\n                content = content.find('.' + this.settings.nestedItemSelector);\n            }\n\n            content.filter(function () {\n                return this.nodeType === 1;\n            }).each($.proxy(function (index, item) {\n                item = this.prepare(item);\n                this.$stage.append(item);\n                this._items.push(item);\n                this._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n            }, this));\n\n            this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);\n\n            this.invalidate('items');\n        };\n\n        /**\n         * Adds an item.\n         * @todo Use `item` instead of `content` for the event arguments.\n         * @public\n         * @param {HTMLElement|jQuery|String} content - The item content to add.\n         * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.\n         */\n        Owl.prototype.add = function (content, position) {\n            var current = this.relative(this._current);\n\n            position = position === undefined ? this._items.length : this.normalize(position, true);\n            content = content instanceof jQuery ? content : $(content);\n\n            this.trigger('add', {content: content, position: position});\n\n            content = this.prepare(content);\n\n            if (this._items.length === 0 || position === this._items.length) {\n                this._items.length === 0 && this.$stage.append(content);\n                this._items.length !== 0 && this._items[position - 1].after(content);\n                this._items.push(content);\n                this._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n            } else {\n                this._items[position].before(content);\n                this._items.splice(position, 0, content);\n                this._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n            }\n\n            this._items[current] && this.reset(this._items[current].index());\n\n            this.invalidate('items');\n\n            this.trigger('added', {content: content, position: position});\n        };\n\n        /**\n         * Removes an item by its position.\n         * @todo Use `item` instead of `content` for the event arguments.\n         * @public\n         * @param {Number} position - The relative position of the item to remove.\n         */\n        Owl.prototype.remove = function (position) {\n            position = this.normalize(position, true);\n\n            if (position === undefined) {\n                return;\n            }\n\n            this.trigger('remove', {content: this._items[position], position: position});\n\n            this._items[position].remove();\n            this._items.splice(position, 1);\n            this._mergers.splice(position, 1);\n\n            this.invalidate('items');\n\n            this.trigger('removed', {content: null, position: position});\n        };\n\n        /**\n         * Preloads images with auto width.\n         * @todo Replace by a more generic approach\n         * @protected\n         */\n        Owl.prototype.preloadAutoWidthImages = function (images) {\n            images.each($.proxy(function (i, element) {\n                this.enter('pre-loading');\n                element = $(element);\n                $(new Image()).one('load', $.proxy(function (e) {\n                    element.attr('src', e.target.src);\n                    element.css('opacity', 1);\n                    this.leave('pre-loading');\n                    !this.is('pre-loading') && !this.is('initializing') && this.refresh();\n                }, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));\n            }, this));\n        };\n\n        /**\n         * Destroys the carousel.\n         * @public\n         */\n        Owl.prototype.destroy = function () {\n\n            this.$element.off('.owl.core');\n            this.$stage.off('.owl.core');\n            $(document).off('.owl.core');\n\n            if (this.settings.responsive !== false) {\n                window.clearTimeout(this.resizeTimer);\n                this.off(window, 'resize', this._handlers.onThrottledResize);\n            }\n\n            for (var i in this._plugins) {\n                this._plugins[i].destroy();\n            }\n\n            this.$stage.children('.cloned').remove();\n\n            this.$stage.unwrap();\n            this.$stage.children().contents().unwrap();\n            this.$stage.children().unwrap();\n            this.$stage.remove();\n            this.$element\n                .removeClass(this.options.refreshClass)\n                .removeClass(this.options.loadingClass)\n                .removeClass(this.options.loadedClass)\n                .removeClass(this.options.rtlClass)\n                .removeClass(this.options.dragClass)\n                .removeClass(this.options.grabClass)\n                .attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\\\S+\\\\s', 'g'), ''))\n                .removeData('owl.carousel');\n        };\n\n        /**\n         * Operators to calculate right-to-left and left-to-right.\n         * @protected\n         * @param {Number} [a] - The left side operand.\n         * @param {String} [o] - The operator.\n         * @param {Number} [b] - The right side operand.\n         */\n        Owl.prototype.op = function (a, o, b) {\n            var rtl = this.settings.rtl;\n            switch (o) {\n                case '<':\n                    return rtl ? a > b : a < b;\n                case '>':\n                    return rtl ? a < b : a > b;\n                case '>=':\n                    return rtl ? a <= b : a >= b;\n                case '<=':\n                    return rtl ? a >= b : a <= b;\n                default:\n                    break;\n            }\n        };\n\n        /**\n         * Attaches to an internal event.\n         * @protected\n         * @param {HTMLElement} element - The event source.\n         * @param {String} event - The event name.\n         * @param {Function} listener - The event handler to attach.\n         * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.\n         */\n        Owl.prototype.on = function (element, event, listener, capture) {\n            if (element.addEventListener) {\n                element.addEventListener(event, listener, capture);\n            } else if (element.attachEvent) {\n                element.attachEvent('on' + event, listener);\n            }\n        };\n\n        /**\n         * Detaches from an internal event.\n         * @protected\n         * @param {HTMLElement} element - The event source.\n         * @param {String} event - The event name.\n         * @param {Function} listener - The attached event handler to detach.\n         * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.\n         */\n        Owl.prototype.off = function (element, event, listener, capture) {\n            if (element.removeEventListener) {\n                element.removeEventListener(event, listener, capture);\n            } else if (element.detachEvent) {\n                element.detachEvent('on' + event, listener);\n            }\n        };\n\n        /**\n         * Triggers a public event.\n         * @todo Remove `status`, `relatedTarget` should be used instead.\n         * @protected\n         * @param {String} name - The event name.\n         * @param {*} [data=null] - The event data.\n         * @param {String} [namespace=carousel] - The event namespace.\n         * @param {String} [state] - The state which is associated with the event.\n         * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.\n         * @returns {Event} - The event arguments.\n         */\n        Owl.prototype.trigger = function (name, data, namespace, state, enter) {\n            var status = {\n                item: {count: this._items.length, index: this.current()}\n            }, handler = $.camelCase(\n                $.grep(['on', name, namespace], function (v) {\n                    return v\n                })\n                    .join('-').toLowerCase()\n            ), event = $.Event(\n                [name, 'owl', namespace || 'carousel'].join('.').toLowerCase(),\n                $.extend({relatedTarget: this}, status, data)\n            );\n\n            if (!this._supress[name]) {\n                $.each(this._plugins, function (name, plugin) {\n                    if (plugin.onTrigger) {\n                        plugin.onTrigger(event);\n                    }\n                });\n\n                this.register({type: Owl.Type.Event, name: name});\n                this.$element.trigger(event);\n\n                if (this.settings && typeof this.settings[handler] === 'function') {\n                    this.settings[handler].call(this, event);\n                }\n            }\n\n            return event;\n        };\n\n        /**\n         * Enters a state.\n         * @param name - The state name.\n         */\n        Owl.prototype.enter = function (name) {\n            $.each([name].concat(this._states.tags[name] || []), $.proxy(function (i, name) {\n                if (this._states.current[name] === undefined) {\n                    this._states.current[name] = 0;\n                }\n\n                this._states.current[name]++;\n            }, this));\n        };\n\n        /**\n         * Leaves a state.\n         * @param name - The state name.\n         */\n        Owl.prototype.leave = function (name) {\n            $.each([name].concat(this._states.tags[name] || []), $.proxy(function (i, name) {\n                this._states.current[name]--;\n            }, this));\n        };\n\n        /**\n         * Registers an event or state.\n         * @public\n         * @param {Object} object - The event or state to register.\n         */\n        Owl.prototype.register = function (object) {\n            if (object.type === Owl.Type.Event) {\n                if (!$.event.special[object.name]) {\n                    $.event.special[object.name] = {};\n                }\n\n                if (!$.event.special[object.name].owl) {\n                    var _default = $.event.special[object.name]._default;\n                    $.event.special[object.name]._default = function (e) {\n                        if (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {\n                            return _default.apply(this, arguments);\n                        }\n                        return e.namespace && e.namespace.indexOf('owl') > -1;\n                    };\n                    $.event.special[object.name].owl = true;\n                }\n            } else if (object.type === Owl.Type.State) {\n                if (!this._states.tags[object.name]) {\n                    this._states.tags[object.name] = object.tags;\n                } else {\n                    this._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);\n                }\n\n                this._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function (tag, i) {\n                    return $.inArray(tag, this._states.tags[object.name]) === i;\n                }, this));\n            }\n        };\n\n        /**\n         * Suppresses events.\n         * @protected\n         * @param {Array.<String>} events - The events to suppress.\n         */\n        Owl.prototype.suppress = function (events) {\n            $.each(events, $.proxy(function (index, event) {\n                this._supress[event] = true;\n            }, this));\n        };\n\n        /**\n         * Releases suppressed events.\n         * @protected\n         * @param {Array.<String>} events - The events to release.\n         */\n        Owl.prototype.release = function (events) {\n            $.each(events, $.proxy(function (index, event) {\n                delete this._supress[event];\n            }, this));\n        };\n\n        /**\n         * Gets unified pointer coordinates from event.\n         * @todo #261\n         * @protected\n         * @param {Event} - The `mousedown` or `touchstart` event.\n         * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.\n         */\n        Owl.prototype.pointer = function (event) {\n            var result = {x: null, y: null};\n\n            event = event.originalEvent || event || window.event;\n\n            event = event.touches && event.touches.length ?\n                event.touches[0] : event.changedTouches && event.changedTouches.length ?\n                    event.changedTouches[0] : event;\n\n            if (event.pageX) {\n                result.x = event.pageX;\n                result.y = event.pageY;\n            } else {\n                result.x = event.clientX;\n                result.y = event.clientY;\n            }\n\n            return result;\n        };\n\n        /**\n         * Determines if the input is a Number or something that can be coerced to a Number\n         * @protected\n         * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested\n         * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number\n         */\n        Owl.prototype.isNumeric = function (number) {\n            return !isNaN(parseFloat(number));\n        };\n\n        /**\n         * Gets the difference of two vectors.\n         * @todo #261\n         * @protected\n         * @param {Object} - The first vector.\n         * @param {Object} - The second vector.\n         * @returns {Object} - The difference.\n         */\n        Owl.prototype.difference = function (first, second) {\n            return {\n                x: first.x - second.x,\n                y: first.y - second.y\n            };\n        };\n\n        /**\n         * The jQuery Plugin for the Owl Carousel\n         * @todo Navigation plugin `next` and `prev`\n         * @public\n         */\n        $.fn.owlCarousel = function (option) {\n            var args = Array.prototype.slice.call(arguments, 1);\n\n            return this.each(function () {\n                var $this = $(this),\n                    data = $this.data('owl.carousel');\n\n                if (!data) {\n                    data = new Owl(this, typeof option == 'object' && option);\n                    $this.data('owl.carousel', data);\n\n                    $.each([\n                        'next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'\n                    ], function (i, event) {\n                        data.register({type: Owl.Type.Event, name: event});\n                        data.$element.on(event + '.owl.carousel.core', $.proxy(function (e) {\n                            if (e.namespace && e.relatedTarget !== this) {\n                                this.suppress([event]);\n                                data[event].apply(this, [].slice.call(arguments, 1));\n                                this.release([event]);\n                            }\n                        }, data));\n                    });\n                }\n\n                if (typeof option == 'string' && option.charAt(0) !== '_') {\n                    data[option].apply(data, args);\n                }\n            });\n        };\n\n        /**\n         * The constructor for the jQuery Plugin\n         * @public\n         */\n        $.fn.owlCarousel.Constructor = Owl;\n\n    })(window.Zepto || window.jQuery, window, document);\n\n    /**\n     * AutoRefresh Plugin\n     * @version 2.3.4\n     * @author Artus Kolanowski\n     * @author David Deutsch\n     * @license The MIT License (MIT)\n     */\n    ;(function ($, window, document, undefined) {\n\n        /**\n         * Creates the auto refresh plugin.\n         * @class The Auto Refresh Plugin\n         * @param {Owl} carousel - The Owl Carousel\n         */\n        var AutoRefresh = function (carousel) {\n            /**\n             * Reference to the core.\n             * @protected\n             * @type {Owl}\n             */\n            this._core = carousel;\n\n            /**\n             * Refresh interval.\n             * @protected\n             * @type {number}\n             */\n            this._interval = null;\n\n            /**\n             * Whether the element is currently visible or not.\n             * @protected\n             * @type {Boolean}\n             */\n            this._visible = null;\n\n            /**\n             * All event handlers.\n             * @protected\n             * @type {Object}\n             */\n            this._handlers = {\n                'initialized.owl.carousel': $.proxy(function (e) {\n                    if (e.namespace && this._core.settings.autoRefresh) {\n                        this.watch();\n                    }\n                }, this)\n            };\n\n            // set default options\n            this._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options);\n\n            // register event handlers\n            this._core.$element.on(this._handlers);\n        };\n\n        /**\n         * Default options.\n         * @public\n         */\n        AutoRefresh.Defaults = {\n            autoRefresh: true,\n            autoRefreshInterval: 500\n        };\n\n        /**\n         * Watches the element.\n         */\n        AutoRefresh.prototype.watch = function () {\n            if (this._interval) {\n                return;\n            }\n\n            this._visible = this._core.isVisible();\n            this._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);\n        };\n\n        /**\n         * Refreshes the element.\n         */\n        AutoRefresh.prototype.refresh = function () {\n            if (this._core.isVisible() === this._visible) {\n                return;\n            }\n\n            this._visible = !this._visible;\n\n            this._core.$element.toggleClass('owl-hidden', !this._visible);\n\n            this._visible && (this._core.invalidate('width') && this._core.refresh());\n        };\n\n        /**\n         * Destroys the plugin.\n         */\n        AutoRefresh.prototype.destroy = function () {\n            var handler, property;\n\n            window.clearInterval(this._interval);\n\n            for (handler in this._handlers) {\n                this._core.$element.off(handler, this._handlers[handler]);\n            }\n            for (property in Object.getOwnPropertyNames(this)) {\n                typeof this[property] != 'function' && (this[property] = null);\n            }\n        };\n\n        $.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;\n\n    })(window.Zepto || window.jQuery, window, document);\n\n    /**\n     * Lazy Plugin\n     * @version 2.3.4\n     * @author Bartosz Wojciechowski\n     * @author David Deutsch\n     * @license The MIT License (MIT)\n     */\n    ;(function ($, window, document, undefined) {\n\n        /**\n         * Creates the lazy plugin.\n         * @class The Lazy Plugin\n         * @param {Owl} carousel - The Owl Carousel\n         */\n        var Lazy = function (carousel) {\n\n            /**\n             * Reference to the core.\n             * @protected\n             * @type {Owl}\n             */\n            this._core = carousel;\n\n            /**\n             * Already loaded items.\n             * @protected\n             * @type {Array.<jQuery>}\n             */\n            this._loaded = [];\n\n            /**\n             * Event handlers.\n             * @protected\n             * @type {Object}\n             */\n            this._handlers = {\n                'initialized.owl.carousel change.owl.carousel resized.owl.carousel': $.proxy(function (e) {\n                    if (!e.namespace) {\n                        return;\n                    }\n\n                    if (!this._core.settings || !this._core.settings.lazyLoad) {\n                        return;\n                    }\n\n                    if ((e.property && e.property.name == 'position') || e.type == 'initialized') {\n                        var settings = this._core.settings,\n                            n = (settings.center && Math.ceil(settings.items / 2) || settings.items),\n                            i = ((settings.center && n * -1) || 0),\n                            position = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i,\n                            clones = this._core.clones().length,\n                            load = $.proxy(function (i, v) {\n                                this.load(v)\n                            }, this);\n                        //TODO: Need documentation for this new option\n                        if (settings.lazyLoadEager > 0) {\n                            n += settings.lazyLoadEager;\n                            // If the carousel is looping also preload images that are to the \"left\"\n                            if (settings.loop) {\n                                position -= settings.lazyLoadEager;\n                                n++;\n                            }\n                        }\n\n                        while (i++ < n) {\n                            this.load(clones / 2 + this._core.relative(position));\n                            clones && $.each(this._core.clones(this._core.relative(position)), load);\n                            position++;\n                        }\n                    }\n                }, this)\n            };\n\n            // set the default options\n            this._core.options = $.extend({}, Lazy.Defaults, this._core.options);\n\n            // register event handler\n            this._core.$element.on(this._handlers);\n        };\n\n        /**\n         * Default options.\n         * @public\n         */\n        Lazy.Defaults = {\n            lazyLoad: false,\n            lazyLoadEager: 0\n        };\n\n        /**\n         * Loads all resources of an item at the specified position.\n         * @param {Number} position - The absolute position of the item.\n         * @protected\n         */\n        Lazy.prototype.load = function (position) {\n            var $item = this._core.$stage.children().eq(position),\n                $elements = $item && $item.find('.owl-lazy');\n\n            if (!$elements || $.inArray($item.get(0), this._loaded) > -1) {\n                return;\n            }\n\n            $elements.each($.proxy(function (index, element) {\n                var $element = $(element), image,\n                    url = (window.devicePixelRatio > 1 && $element.attr('data-src-retina')) || $element.attr('data-src') || $element.attr('data-srcset');\n\n                this._core.trigger('load', {element: $element, url: url}, 'lazy');\n\n                if ($element.is('img')) {\n                    $element.one('load.owl.lazy', $.proxy(function () {\n                        $element.css('opacity', 1);\n                        this._core.trigger('loaded', {element: $element, url: url}, 'lazy');\n                    }, this)).attr('src', url);\n                } else if ($element.is('source')) {\n                    $element.one('load.owl.lazy', $.proxy(function () {\n                        this._core.trigger('loaded', {element: $element, url: url}, 'lazy');\n                    }, this)).attr('srcset', url);\n                } else {\n                    image = new Image();\n                    image.onload = $.proxy(function () {\n                        $element.css({\n                            'background-image': 'url(\"' + url + '\")',\n                            'opacity': '1'\n                        });\n                        this._core.trigger('loaded', {element: $element, url: url}, 'lazy');\n                    }, this);\n                    image.src = url;\n                }\n            }, this));\n\n            this._loaded.push($item.get(0));\n        };\n\n        /**\n         * Destroys the plugin.\n         * @public\n         */\n        Lazy.prototype.destroy = function () {\n            var handler, property;\n\n            for (handler in this.handlers) {\n                this._core.$element.off(handler, this.handlers[handler]);\n            }\n            for (property in Object.getOwnPropertyNames(this)) {\n                typeof this[property] != 'function' && (this[property] = null);\n            }\n        };\n\n        $.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;\n\n    })(window.Zepto || window.jQuery, window, document);\n\n    /**\n     * AutoHeight Plugin\n     * @version 2.3.4\n     * @author Bartosz Wojciechowski\n     * @author David Deutsch\n     * @license The MIT License (MIT)\n     */\n    ;(function ($, window, document, undefined) {\n\n        /**\n         * Creates the auto height plugin.\n         * @class The Auto Height Plugin\n         * @param {Owl} carousel - The Owl Carousel\n         */\n        var AutoHeight = function (carousel) {\n            /**\n             * Reference to the core.\n             * @protected\n             * @type {Owl}\n             */\n            this._core = carousel;\n\n            this._previousHeight = null;\n\n            /**\n             * All event handlers.\n             * @protected\n             * @type {Object}\n             */\n            this._handlers = {\n                'initialized.owl.carousel refreshed.owl.carousel': $.proxy(function (e) {\n                    if (e.namespace && this._core.settings.autoHeight) {\n                        this.update();\n                    }\n                }, this),\n                'changed.owl.carousel': $.proxy(function (e) {\n                    if (e.namespace && this._core.settings.autoHeight && e.property.name === 'position') {\n                        this.update();\n                    }\n                }, this),\n                'loaded.owl.lazy': $.proxy(function (e) {\n                    if (e.namespace && this._core.settings.autoHeight\n                        && e.element.closest('.' + this._core.settings.itemClass).index() === this._core.current()) {\n                        this.update();\n                    }\n                }, this)\n            };\n\n            // set default options\n            this._core.options = $.extend({}, AutoHeight.Defaults, this._core.options);\n\n            // register event handlers\n            this._core.$element.on(this._handlers);\n            this._intervalId = null;\n            var refThis = this;\n\n            // These changes have been taken from a PR by gavrochelegnou proposed in #1575\n            // and have been made compatible with the latest jQuery version\n            $(window).on('load', function () {\n                if (refThis._core.settings.autoHeight) {\n                    refThis.update();\n                }\n            });\n\n            // Autoresize the height of the carousel when window is resized\n            // When carousel has images, the height is dependent on the width\n            // and should also change on resize\n            $(window).resize(function () {\n                if (refThis._core.settings.autoHeight) {\n                    if (refThis._intervalId != null) {\n                        clearTimeout(refThis._intervalId);\n                    }\n\n                    refThis._intervalId = setTimeout(function () {\n                        refThis.update();\n                    }, 250);\n                }\n            });\n\n        };\n\n        /**\n         * Default options.\n         * @public\n         */\n        AutoHeight.Defaults = {\n            autoHeight: false,\n            autoHeightClass: 'owl-height'\n        };\n\n        /**\n         * Updates the view.\n         */\n        AutoHeight.prototype.update = function () {\n            var start = this._core._current,\n                end = start + this._core.settings.items,\n                lazyLoadEnabled = this._core.settings.lazyLoad,\n                visible = this._core.$stage.children().toArray().slice(start, end),\n                heights = [],\n                maxheight = 0;\n\n            $.each(visible, function (index, item) {\n                heights.push($(item).height());\n            });\n\n            maxheight = Math.max.apply(null, heights);\n\n            if (maxheight <= 1 && lazyLoadEnabled && this._previousHeight) {\n                maxheight = this._previousHeight;\n            }\n\n            this._previousHeight = maxheight;\n\n            this._core.$stage.parent()\n                .height(maxheight)\n                .addClass(this._core.settings.autoHeightClass);\n        };\n\n        AutoHeight.prototype.destroy = function () {\n            var handler, property;\n\n            for (handler in this._handlers) {\n                this._core.$element.off(handler, this._handlers[handler]);\n            }\n            for (property in Object.getOwnPropertyNames(this)) {\n                typeof this[property] !== 'function' && (this[property] = null);\n            }\n        };\n\n        $.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;\n\n    })(window.Zepto || window.jQuery, window, document);\n\n    /**\n     * Video Plugin\n     * @version 2.3.4\n     * @author Bartosz Wojciechowski\n     * @author David Deutsch\n     * @license The MIT License (MIT)\n     */\n    ;(function ($, window, document, undefined) {\n\n        /**\n         * Creates the video plugin.\n         * @class The Video Plugin\n         * @param {Owl} carousel - The Owl Carousel\n         */\n        var Video = function (carousel) {\n            /**\n             * Reference to the core.\n             * @protected\n             * @type {Owl}\n             */\n            this._core = carousel;\n\n            /**\n             * Cache all video URLs.\n             * @protected\n             * @type {Object}\n             */\n            this._videos = {};\n\n            /**\n             * Current playing item.\n             * @protected\n             * @type {jQuery}\n             */\n            this._playing = null;\n\n            /**\n             * All event handlers.\n             * @todo The cloned content removale is too late\n             * @protected\n             * @type {Object}\n             */\n            this._handlers = {\n                'initialized.owl.carousel': $.proxy(function (e) {\n                    if (e.namespace) {\n                        this._core.register({type: 'state', name: 'playing', tags: ['interacting']});\n                    }\n                }, this),\n                'resize.owl.carousel': $.proxy(function (e) {\n                    if (e.namespace && this._core.settings.video && this.isInFullScreen()) {\n                        e.preventDefault();\n                    }\n                }, this),\n                'refreshed.owl.carousel': $.proxy(function (e) {\n                    if (e.namespace && this._core.is('resizing')) {\n                        this._core.$stage.find('.cloned .owl-video-frame').remove();\n                    }\n                }, this),\n                'changed.owl.carousel': $.proxy(function (e) {\n                    if (e.namespace && e.property.name === 'position' && this._playing) {\n                        this.stop();\n                    }\n                }, this),\n                'prepared.owl.carousel': $.proxy(function (e) {\n                    if (!e.namespace) {\n                        return;\n                    }\n\n                    var $element = $(e.content).find('.owl-video');\n\n                    if ($element.length) {\n                        $element.css('display', 'none');\n                        this.fetch($element, $(e.content));\n                    }\n                }, this)\n            };\n\n            // set default options\n            this._core.options = $.extend({}, Video.Defaults, this._core.options);\n\n            // register event handlers\n            this._core.$element.on(this._handlers);\n\n            this._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function (e) {\n                this.play(e);\n            }, this));\n        };\n\n        /**\n         * Default options.\n         * @public\n         */\n        Video.Defaults = {\n            video: false,\n            videoHeight: false,\n            videoWidth: false\n        };\n\n        /**\n         * Gets the video ID and the type (YouTube/Vimeo/vzaar only).\n         * @protected\n         * @param {jQuery} target - The target containing the video data.\n         * @param {jQuery} item - The item containing the video.\n         */\n        Video.prototype.fetch = function (target, item) {\n            var type = (function () {\n                    if (target.attr('data-vimeo-id')) {\n                        return 'vimeo';\n                    } else if (target.attr('data-vzaar-id')) {\n                        return 'vzaar'\n                    } else {\n                        return 'youtube';\n                    }\n                })(),\n                id = target.attr('data-vimeo-id') || target.attr('data-youtube-id') || target.attr('data-vzaar-id'),\n                width = target.attr('data-width') || this._core.settings.videoWidth,\n                height = target.attr('data-height') || this._core.settings.videoHeight,\n                url = target.attr('href');\n\n            if (url) {\n\n                /*\n\t\t\t\t\tParses the id's out of the following urls (and probably more):\n\t\t\t\t\thttps://www.youtube.com/watch?v=:id\n\t\t\t\t\thttps://youtu.be/:id\n\t\t\t\t\thttps://vimeo.com/:id\n\t\t\t\t\thttps://vimeo.com/channels/:channel/:id\n\t\t\t\t\thttps://vimeo.com/groups/:group/videos/:id\n\t\t\t\t\thttps://app.vzaar.com/videos/:id\n\n\t\t\t\t\tVisual example: https://regexper.com/#(http%3A%7Chttps%3A%7C)%5C%2F%5C%2F(player.%7Cwww.%7Capp.)%3F(vimeo%5C.com%7Cyoutu(be%5C.com%7C%5C.be%7Cbe%5C.googleapis%5C.com)%7Cvzaar%5C.com)%5C%2F(video%5C%2F%7Cvideos%5C%2F%7Cembed%5C%2F%7Cchannels%5C%2F.%2B%5C%2F%7Cgroups%5C%2F.%2B%5C%2F%7Cwatch%5C%3Fv%3D%7Cv%5C%2F)%3F(%5BA-Za-z0-9._%25-%5D*)(%5C%26%5CS%2B)%3F\n\t\t\t*/\n\n                id = url.match(/(http:|https:|)\\/\\/(player.|www.|app.)?(vimeo\\.com|youtu(be\\.com|\\.be|be\\.googleapis\\.com|be\\-nocookie\\.com)|vzaar\\.com)\\/(video\\/|videos\\/|embed\\/|channels\\/.+\\/|groups\\/.+\\/|watch\\?v=|v\\/)?([A-Za-z0-9._%-]*)(\\&\\S+)?/);\n\n                if (id[3].indexOf('youtu') > -1) {\n                    type = 'youtube';\n                } else if (id[3].indexOf('vimeo') > -1) {\n                    type = 'vimeo';\n                } else if (id[3].indexOf('vzaar') > -1) {\n                    type = 'vzaar';\n                } else {\n                    throw new Error('Video URL not supported.');\n                }\n                id = id[6];\n            } else {\n                throw new Error('Missing video URL.');\n            }\n\n            this._videos[url] = {\n                type: type,\n                id: id,\n                width: width,\n                height: height\n            };\n\n            item.attr('data-video', url);\n\n            this.thumbnail(target, this._videos[url]);\n        };\n\n        /**\n         * Creates video thumbnail.\n         * @protected\n         * @param {jQuery} target - The target containing the video data.\n         * @param {Object} info - The video info object.\n         * @see `fetch`\n         */\n        Video.prototype.thumbnail = function (target, video) {\n            var tnLink,\n                icon,\n                path,\n                dimensions = video.width && video.height ? 'width:' + video.width + 'px;height:' + video.height + 'px;' : '',\n                customTn = target.find('img'),\n                srcType = 'src',\n                lazyClass = '',\n                settings = this._core.settings,\n                create = function (path) {\n                    icon = '<div class=\"owl-video-play-icon\"></div>';\n\n                    if (settings.lazyLoad) {\n                        tnLink = $('<div/>', {\n                            \"class\": 'owl-video-tn ' + lazyClass,\n                            \"srcType\": path\n                        });\n                    } else {\n                        tnLink = $('<div/>', {\n                            \"class\": \"owl-video-tn\",\n                            \"style\": 'opacity:1;background-image:url(' + path + ')'\n                        });\n                    }\n                    target.after(tnLink);\n                    target.after(icon);\n                };\n\n            // wrap video content into owl-video-wrapper div\n            target.wrap($('<div/>', {\n                \"class\": \"owl-video-wrapper\",\n                \"style\": dimensions\n            }));\n\n            if (this._core.settings.lazyLoad) {\n                srcType = 'data-src';\n                lazyClass = 'owl-lazy';\n            }\n\n            // custom thumbnail\n            if (customTn.length) {\n                create(customTn.attr(srcType));\n                customTn.remove();\n                return false;\n            }\n\n            if (video.type === 'youtube') {\n                path = \"//img.youtube.com/vi/\" + video.id + \"/hqdefault.jpg\";\n                create(path);\n            } else if (video.type === 'vimeo') {\n                $.ajax({\n                    type: 'GET',\n                    url: '//vimeo.com/api/v2/video/' + video.id + '.json',\n                    jsonp: 'callback',\n                    dataType: 'jsonp',\n                    success: function (data) {\n                        path = data[0].thumbnail_large;\n                        create(path);\n                    }\n                });\n            } else if (video.type === 'vzaar') {\n                $.ajax({\n                    type: 'GET',\n                    url: '//vzaar.com/api/videos/' + video.id + '.json',\n                    jsonp: 'callback',\n                    dataType: 'jsonp',\n                    success: function (data) {\n                        path = data.framegrab_url;\n                        create(path);\n                    }\n                });\n            }\n        };\n\n        /**\n         * Stops the current video.\n         * @public\n         */\n        Video.prototype.stop = function () {\n            this._core.trigger('stop', null, 'video');\n            this._playing.find('.owl-video-frame').remove();\n            this._playing.removeClass('owl-video-playing');\n            this._playing = null;\n            this._core.leave('playing');\n            this._core.trigger('stopped', null, 'video');\n        };\n\n        /**\n         * Starts the current video.\n         * @public\n         * @param {Event} event - The event arguments.\n         */\n        Video.prototype.play = function (event) {\n            var target = $(event.target),\n                item = target.closest('.' + this._core.settings.itemClass),\n                video = this._videos[item.attr('data-video')],\n                width = video.width || '100%',\n                height = video.height || this._core.$stage.height(),\n                html,\n                iframe;\n\n            if (this._playing) {\n                return;\n            }\n\n            this._core.enter('playing');\n            this._core.trigger('play', null, 'video');\n\n            item = this._core.items(this._core.relative(item.index()));\n\n            this._core.reset(item.index());\n\n            html = $('<iframe frameborder=\"0\" allowfullscreen mozallowfullscreen webkitAllowFullScreen ></iframe>');\n            html.attr('height', height);\n            html.attr('width', width);\n            if (video.type === 'youtube') {\n                html.attr('src', '//www.youtube.com/embed/' + video.id + '?autoplay=1&rel=0&v=' + video.id);\n            } else if (video.type === 'vimeo') {\n                html.attr('src', '//player.vimeo.com/video/' + video.id + '?autoplay=1');\n            } else if (video.type === 'vzaar') {\n                html.attr('src', '//view.vzaar.com/' + video.id + '/player?autoplay=true');\n            }\n\n            iframe = $(html).wrap('<div class=\"owl-video-frame\" />').insertAfter(item.find('.owl-video'));\n\n            this._playing = item.addClass('owl-video-playing');\n        };\n\n        /**\n         * Checks whether an video is currently in full screen mode or not.\n         * @todo Bad style because looks like a readonly method but changes members.\n         * @protected\n         * @returns {Boolean}\n         */\n        Video.prototype.isInFullScreen = function () {\n            var element = document.fullscreenElement || document.mozFullScreenElement ||\n                document.webkitFullscreenElement;\n\n            return element && $(element).parent().hasClass('owl-video-frame');\n        };\n\n        /**\n         * Destroys the plugin.\n         */\n        Video.prototype.destroy = function () {\n            var handler, property;\n\n            this._core.$element.off('click.owl.video');\n\n            for (handler in this._handlers) {\n                this._core.$element.off(handler, this._handlers[handler]);\n            }\n            for (property in Object.getOwnPropertyNames(this)) {\n                typeof this[property] != 'function' && (this[property] = null);\n            }\n        };\n\n        $.fn.owlCarousel.Constructor.Plugins.Video = Video;\n\n    })(window.Zepto || window.jQuery, window, document);\n\n    /**\n     * Animate Plugin\n     * @version 2.3.4\n     * @author Bartosz Wojciechowski\n     * @author David Deutsch\n     * @license The MIT License (MIT)\n     */\n    ;(function ($, window, document, undefined) {\n\n        /**\n         * Creates the animate plugin.\n         * @class The Navigation Plugin\n         * @param {Owl} scope - The Owl Carousel\n         */\n        var Animate = function (scope) {\n            this.core = scope;\n            this.core.options = $.extend({}, Animate.Defaults, this.core.options);\n            this.swapping = true;\n            this.previous = undefined;\n            this.next = undefined;\n\n            this.handlers = {\n                'change.owl.carousel': $.proxy(function (e) {\n                    if (e.namespace && e.property.name == 'position') {\n                        this.previous = this.core.current();\n                        this.next = e.property.value;\n                    }\n                }, this),\n                'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function (e) {\n                    if (e.namespace) {\n                        this.swapping = e.type == 'translated';\n                    }\n                }, this),\n                'translate.owl.carousel': $.proxy(function (e) {\n                    if (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {\n                        this.swap();\n                    }\n                }, this)\n            };\n\n            this.core.$element.on(this.handlers);\n        };\n\n        /**\n         * Default options.\n         * @public\n         */\n        Animate.Defaults = {\n            animateOut: false,\n            animateIn: false\n        };\n\n        /**\n         * Toggles the animation classes whenever an translations starts.\n         * @protected\n         * @returns {Boolean|undefined}\n         */\n        Animate.prototype.swap = function () {\n\n            if (this.core.settings.items !== 1) {\n                return;\n            }\n\n            if (!$.support.animation || !$.support.transition) {\n                return;\n            }\n\n            this.core.speed(0);\n\n            var left,\n                clear = $.proxy(this.clear, this),\n                previous = this.core.$stage.children().eq(this.previous),\n                next = this.core.$stage.children().eq(this.next),\n                incoming = this.core.settings.animateIn,\n                outgoing = this.core.settings.animateOut;\n\n            if (this.core.current() === this.previous) {\n                return;\n            }\n\n            if (outgoing) {\n                left = this.core.coordinates(this.previous) - this.core.coordinates(this.next);\n                previous.one($.support.animation.end, clear)\n                    .css({'left': left + 'px'})\n                    .addClass('animated owl-animated-out')\n                    .addClass(outgoing);\n            }\n\n            if (incoming) {\n                next.one($.support.animation.end, clear)\n                    .addClass('animated owl-animated-in')\n                    .addClass(incoming);\n            }\n        };\n\n        Animate.prototype.clear = function (e) {\n            $(e.target).css({'left': ''})\n                .removeClass('animated owl-animated-out owl-animated-in')\n                .removeClass(this.core.settings.animateIn)\n                .removeClass(this.core.settings.animateOut);\n            this.core.onTransitionEnd();\n        };\n\n        /**\n         * Destroys the plugin.\n         * @public\n         */\n        Animate.prototype.destroy = function () {\n            var handler, property;\n\n            for (handler in this.handlers) {\n                this.core.$element.off(handler, this.handlers[handler]);\n            }\n            for (property in Object.getOwnPropertyNames(this)) {\n                typeof this[property] != 'function' && (this[property] = null);\n            }\n        };\n\n        $.fn.owlCarousel.Constructor.Plugins.Animate = Animate;\n\n    })(window.Zepto || window.jQuery, window, document);\n\n    /**\n     * Autoplay Plugin\n     * @version 2.3.4\n     * @author Bartosz Wojciechowski\n     * @author Artus Kolanowski\n     * @author David Deutsch\n     * @author Tom De Caluw\u00e9\n     * @license The MIT License (MIT)\n     */\n    ;(function ($, window, document, undefined) {\n\n        /**\n         * Creates the autoplay plugin.\n         * @class The Autoplay Plugin\n         * @param {Owl} scope - The Owl Carousel\n         */\n        var Autoplay = function (carousel) {\n            /**\n             * Reference to the core.\n             * @protected\n             * @type {Owl}\n             */\n            this._core = carousel;\n\n            /**\n             * The autoplay timeout id.\n             * @type {Number}\n             */\n            this._call = null;\n\n            /**\n             * Depending on the state of the plugin, this variable contains either\n             * the start time of the timer or the current timer value if it's\n             * paused. Since we start in a paused state we initialize the timer\n             * value.\n             * @type {Number}\n             */\n            this._time = 0;\n\n            /**\n             * Stores the timeout currently used.\n             * @type {Number}\n             */\n            this._timeout = 0;\n\n            /**\n             * Indicates whenever the autoplay is paused.\n             * @type {Boolean}\n             */\n            this._paused = true;\n\n            /**\n             * All event handlers.\n             * @protected\n             * @type {Object}\n             */\n            this._handlers = {\n                'changed.owl.carousel': $.proxy(function (e) {\n                    if (e.namespace && e.property.name === 'settings') {\n                        if (this._core.settings.autoplay) {\n                            this.play();\n                        } else {\n                            this.stop();\n                        }\n                    } else if (e.namespace && e.property.name === 'position' && this._paused) {\n                        // Reset the timer. This code is triggered when the position\n                        // of the carousel was changed through user interaction.\n                        this._time = 0;\n                    }\n                }, this),\n                'initialized.owl.carousel': $.proxy(function (e) {\n                    if (e.namespace && this._core.settings.autoplay) {\n                        this.play();\n                    }\n                }, this),\n                'play.owl.autoplay': $.proxy(function (e, t, s) {\n                    if (e.namespace) {\n                        this.play(t, s);\n                    }\n                }, this),\n                'stop.owl.autoplay': $.proxy(function (e) {\n                    if (e.namespace) {\n                        this.stop();\n                    }\n                }, this),\n                'mouseover.owl.autoplay': $.proxy(function () {\n                    if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n                        this.pause();\n                    }\n                }, this),\n                'mouseleave.owl.autoplay': $.proxy(function () {\n                    if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n                        this.play();\n                    }\n                }, this),\n                'touchstart.owl.core': $.proxy(function () {\n                    if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n                        this.pause();\n                    }\n                }, this),\n                'touchend.owl.core': $.proxy(function () {\n                    if (this._core.settings.autoplayHoverPause) {\n                        this.play();\n                    }\n                }, this)\n            };\n\n            // register event handlers\n            this._core.$element.on(this._handlers);\n\n            // set default options\n            this._core.options = $.extend({}, Autoplay.Defaults, this._core.options);\n        };\n\n        /**\n         * Default options.\n         * @public\n         */\n        Autoplay.Defaults = {\n            autoplay: false,\n            autoplayTimeout: 5000,\n            autoplayHoverPause: false,\n            autoplaySpeed: false\n        };\n\n        /**\n         * Transition to the next slide and set a timeout for the next transition.\n         * @private\n         * @param {Number} [speed] - The animation speed for the animations.\n         */\n        Autoplay.prototype._next = function (speed) {\n            this._call = window.setTimeout(\n                $.proxy(this._next, this, speed),\n                this._timeout * (Math.round(this.read() / this._timeout) + 1) - this.read()\n            );\n\n            if (this._core.is('interacting') || document.hidden) {\n                return;\n            }\n            this._core.next(speed || this._core.settings.autoplaySpeed);\n        }\n\n        /**\n         * Reads the current timer value when the timer is playing.\n         * @public\n         */\n        Autoplay.prototype.read = function () {\n            return new Date().getTime() - this._time;\n        };\n\n        /**\n         * Starts the autoplay.\n         * @public\n         * @param {Number} [timeout] - The interval before the next animation starts.\n         * @param {Number} [speed] - The animation speed for the animations.\n         */\n        Autoplay.prototype.play = function (timeout, speed) {\n            var elapsed;\n\n            if (!this._core.is('rotating')) {\n                this._core.enter('rotating');\n            }\n\n            timeout = timeout || this._core.settings.autoplayTimeout;\n\n            // Calculate the elapsed time since the last transition. If the carousel\n            // wasn't playing this calculation will yield zero.\n            elapsed = Math.min(this._time % (this._timeout || timeout), timeout);\n\n            if (this._paused) {\n                // Start the clock.\n                this._time = this.read();\n                this._paused = false;\n            } else {\n                // Clear the active timeout to allow replacement.\n                window.clearTimeout(this._call);\n            }\n\n            // Adjust the origin of the timer to match the new timeout value.\n            this._time += this.read() % timeout - elapsed;\n\n            this._timeout = timeout;\n            this._call = window.setTimeout($.proxy(this._next, this, speed), timeout - elapsed);\n        };\n\n        /**\n         * Stops the autoplay.\n         * @public\n         */\n        Autoplay.prototype.stop = function () {\n            if (this._core.is('rotating')) {\n                // Reset the clock.\n                this._time = 0;\n                this._paused = true;\n\n                window.clearTimeout(this._call);\n                this._core.leave('rotating');\n            }\n        };\n\n        /**\n         * Pauses the autoplay.\n         * @public\n         */\n        Autoplay.prototype.pause = function () {\n            if (this._core.is('rotating') && !this._paused) {\n                // Pause the clock.\n                this._time = this.read();\n                this._paused = true;\n\n                window.clearTimeout(this._call);\n            }\n        };\n\n        /**\n         * Destroys the plugin.\n         */\n        Autoplay.prototype.destroy = function () {\n            var handler, property;\n\n            this.stop();\n\n            for (handler in this._handlers) {\n                this._core.$element.off(handler, this._handlers[handler]);\n            }\n            for (property in Object.getOwnPropertyNames(this)) {\n                typeof this[property] != 'function' && (this[property] = null);\n            }\n        };\n\n        $.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;\n\n    })(window.Zepto || window.jQuery, window, document);\n\n    /**\n     * Navigation Plugin\n     * @version 2.3.4\n     * @author Artus Kolanowski\n     * @author David Deutsch\n     * @license The MIT License (MIT)\n     */\n    ;(function ($, window, document, undefined) {\n        'use strict';\n\n        /**\n         * Creates the navigation plugin.\n         * @class The Navigation Plugin\n         * @param {Owl} carousel - The Owl Carousel.\n         */\n        var Navigation = function (carousel) {\n            /**\n             * Reference to the core.\n             * @protected\n             * @type {Owl}\n             */\n            this._core = carousel;\n\n            /**\n             * Indicates whether the plugin is initialized or not.\n             * @protected\n             * @type {Boolean}\n             */\n            this._initialized = false;\n\n            /**\n             * The current paging indexes.\n             * @protected\n             * @type {Array}\n             */\n            this._pages = [];\n\n            /**\n             * All DOM elements of the user interface.\n             * @protected\n             * @type {Object}\n             */\n            this._controls = {};\n\n            /**\n             * Markup for an indicator.\n             * @protected\n             * @type {Array.<String>}\n             */\n            this._templates = [];\n\n            /**\n             * The carousel element.\n             * @type {jQuery}\n             */\n            this.$element = this._core.$element;\n\n            /**\n             * Overridden methods of the carousel.\n             * @protected\n             * @type {Object}\n             */\n            this._overrides = {\n                next: this._core.next,\n                prev: this._core.prev,\n                to: this._core.to\n            };\n\n            /**\n             * All event handlers.\n             * @protected\n             * @type {Object}\n             */\n            this._handlers = {\n                'prepared.owl.carousel': $.proxy(function (e) {\n                    if (e.namespace && this._core.settings.dotsData) {\n                        this._templates.push('<div class=\"' + this._core.settings.dotClass + '\">' +\n                            $(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot') + '</div>');\n                    }\n                }, this),\n                'added.owl.carousel': $.proxy(function (e) {\n                    if (e.namespace && this._core.settings.dotsData) {\n                        this._templates.splice(e.position, 0, this._templates.pop());\n                    }\n                }, this),\n                'remove.owl.carousel': $.proxy(function (e) {\n                    if (e.namespace && this._core.settings.dotsData) {\n                        this._templates.splice(e.position, 1);\n                    }\n                }, this),\n                'changed.owl.carousel': $.proxy(function (e) {\n                    if (e.namespace && e.property.name == 'position') {\n                        this.draw();\n                    }\n                }, this),\n                'initialized.owl.carousel': $.proxy(function (e) {\n                    if (e.namespace && !this._initialized) {\n                        this._core.trigger('initialize', null, 'navigation');\n                        this.initialize();\n                        this.update();\n                        this.draw();\n                        this._initialized = true;\n                        this._core.trigger('initialized', null, 'navigation');\n                    }\n                }, this),\n                'refreshed.owl.carousel': $.proxy(function (e) {\n                    if (e.namespace && this._initialized) {\n                        this._core.trigger('refresh', null, 'navigation');\n                        this.update();\n                        this.draw();\n                        this._core.trigger('refreshed', null, 'navigation');\n                    }\n                }, this)\n            };\n\n            // set default options\n            this._core.options = $.extend({}, Navigation.Defaults, this._core.options);\n\n            // register event handlers\n            this.$element.on(this._handlers);\n        };\n\n        /**\n         * Default options.\n         * @public\n         * @todo Rename `slideBy` to `navBy`\n         */\n        Navigation.Defaults = {\n            nav: false,\n            navText: [\n                '<span aria-label=\"' + 'Previous' + '\">&#x2039;</span>',\n                '<span aria-label=\"' + 'Next' + '\">&#x203a;</span>'\n            ],\n            navSpeed: false,\n            navElement: 'div role=\"presentation\"',\n            navContainer: false,\n            navContainerClass: 'owl-nav',\n            navClass: [\n                'owl-prev',\n                'owl-next'\n            ],\n            slideBy: 1,\n            dotClass: 'owl-dot',\n            dotsClass: 'owl-dots',\n            dots: true,\n            dotsEach: false,\n            dotsData: false,\n            dotsSpeed: false,\n            dotsContainer: false\n        };\n\n        /**\n         * Initializes the layout of the plugin and extends the carousel.\n         * @protected\n         */\n        Navigation.prototype.initialize = function () {\n            var override,\n                settings = this._core.settings;\n\n            // create DOM structure for relative navigation\n            this._controls.$relative = (settings.navContainer ? $(settings.navContainer)\n                : $('<div>').addClass(settings.navContainerClass).appendTo(this.$element)).addClass('disabled');\n\n            this._controls.$previous = $('<' + settings.navElement + '>')\n                .addClass(settings.navClass[0])\n                .html(settings.navText[0])\n                .prependTo(this._controls.$relative)\n                .on('click', $.proxy(function (e) {\n                    this.prev(settings.navSpeed);\n                }, this));\n            this._controls.$next = $('<' + settings.navElement + '>')\n                .addClass(settings.navClass[1])\n                .html(settings.navText[1])\n                .appendTo(this._controls.$relative)\n                .on('click', $.proxy(function (e) {\n                    this.next(settings.navSpeed);\n                }, this));\n\n            // create DOM structure for absolute navigation\n            if (!settings.dotsData) {\n                this._templates = [$('<button role=\"button\">')\n                    .addClass(settings.dotClass)\n                    .append($('<span>'))\n                    .prop('outerHTML')];\n            }\n\n            this._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer)\n                : $('<div>').addClass(settings.dotsClass).appendTo(this.$element)).addClass('disabled');\n\n            this._controls.$absolute.on('click', 'button', $.proxy(function (e) {\n                var index = $(e.target).parent().is(this._controls.$absolute)\n                    ? $(e.target).index() : $(e.target).parent().index();\n\n                e.preventDefault();\n\n                this.to(index, settings.dotsSpeed);\n            }, this));\n\n            /*$el.on('focusin', function() {\n\t\t\t$(document).off(\".carousel\");\n\n\t\t\t$(document).on('keydown.carousel', function(e) {\n\t\t\t\tif(e.keyCode == 37) {\n\t\t\t\t\t$el.trigger('prev.owl')\n\t\t\t\t}\n\t\t\t\tif(e.keyCode == 39) {\n\t\t\t\t\t$el.trigger('next.owl')\n\t\t\t\t}\n\t\t\t});\n\t\t});*/\n\n            // override public methods of the carousel\n            for (override in this._overrides) {\n                this._core[override] = $.proxy(this[override], this);\n            }\n        };\n\n        /**\n         * Destroys the plugin.\n         * @protected\n         */\n        Navigation.prototype.destroy = function () {\n            var handler, control, property, override, settings;\n            settings = this._core.settings;\n\n            for (handler in this._handlers) {\n                this.$element.off(handler, this._handlers[handler]);\n            }\n            for (control in this._controls) {\n                if (control === '$relative' && settings.navContainer) {\n                    this._controls[control].html('');\n                } else {\n                    this._controls[control].remove();\n                }\n            }\n            for (override in this.overides) {\n                this._core[override] = this._overrides[override];\n            }\n            for (property in Object.getOwnPropertyNames(this)) {\n                typeof this[property] != 'function' && (this[property] = null);\n            }\n        };\n\n        /**\n         * Updates the internal state.\n         * @protected\n         */\n        Navigation.prototype.update = function () {\n            var i, j, k,\n                lower = this._core.clones().length / 2,\n                upper = lower + this._core.items().length,\n                maximum = this._core.maximum(true),\n                settings = this._core.settings,\n                size = settings.center || settings.autoWidth || settings.dotsData\n                    ? 1 : settings.dotsEach || settings.items;\n\n            if (settings.slideBy !== 'page') {\n                settings.slideBy = Math.min(settings.slideBy, settings.items);\n            }\n\n            if (settings.dots || settings.slideBy == 'page') {\n                this._pages = [];\n\n                for (i = lower, j = 0, k = 0; i < upper; i++) {\n                    if (j >= size || j === 0) {\n                        this._pages.push({\n                            start: Math.min(maximum, i - lower),\n                            end: i - lower + size - 1\n                        });\n                        if (Math.min(maximum, i - lower) === maximum) {\n                            break;\n                        }\n                        j = 0, ++k;\n                    }\n                    j += this._core.mergers(this._core.relative(i));\n                }\n            }\n        };\n\n        /**\n         * Draws the user interface.\n         * @todo The option `dotsData` wont work.\n         * @protected\n         */\n        Navigation.prototype.draw = function () {\n            var difference,\n                settings = this._core.settings,\n                disabled = this._core.items().length <= settings.items,\n                index = this._core.relative(this._core.current()),\n                loop = settings.loop || settings.rewind;\n\n            this._controls.$relative.toggleClass('disabled', !settings.nav || disabled);\n\n            if (settings.nav) {\n                this._controls.$previous.toggleClass('disabled', !loop && index <= this._core.minimum(true));\n                this._controls.$next.toggleClass('disabled', !loop && index >= this._core.maximum(true));\n            }\n\n            this._controls.$absolute.toggleClass('disabled', !settings.dots || disabled);\n\n            if (settings.dots) {\n                difference = this._pages.length - this._controls.$absolute.children().length;\n\n                if (settings.dotsData && difference !== 0) {\n                    this._controls.$absolute.html(this._templates.join(''));\n                } else if (difference > 0) {\n                    this._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));\n                } else if (difference < 0) {\n                    this._controls.$absolute.children().slice(difference).remove();\n                }\n\n                this._controls.$absolute.find('.active').removeClass('active');\n                this._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass('active');\n            }\n        };\n\n        /**\n         * Extends event data.\n         * @protected\n         * @param {Event} event - The event object which gets thrown.\n         */\n        Navigation.prototype.onTrigger = function (event) {\n            var settings = this._core.settings;\n\n            event.page = {\n                index: $.inArray(this.current(), this._pages),\n                count: this._pages.length,\n                size: settings && (settings.center || settings.autoWidth || settings.dotsData\n                    ? 1 : settings.dotsEach || settings.items)\n            };\n        };\n\n        /**\n         * Gets the current page position of the carousel.\n         * @protected\n         * @returns {Number}\n         */\n        Navigation.prototype.current = function () {\n            var current = this._core.relative(this._core.current());\n            return $.grep(this._pages, $.proxy(function (page, index) {\n                return page.start <= current && page.end >= current;\n            }, this)).pop();\n        };\n\n        /**\n         * Gets the current succesor/predecessor position.\n         * @protected\n         * @returns {Number}\n         */\n        Navigation.prototype.getPosition = function (successor) {\n            var position, length,\n                settings = this._core.settings;\n\n            if (settings.slideBy == 'page') {\n                position = $.inArray(this.current(), this._pages);\n                length = this._pages.length;\n                successor ? ++position : --position;\n                position = this._pages[((position % length) + length) % length].start;\n            } else {\n                position = this._core.relative(this._core.current());\n                length = this._core.items().length;\n                successor ? position += settings.slideBy : position -= settings.slideBy;\n            }\n\n            return position;\n        };\n\n        /**\n         * Slides to the next item or page.\n         * @public\n         * @param {Number} [speed=false] - The time in milliseconds for the transition.\n         */\n        Navigation.prototype.next = function (speed) {\n            $.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);\n        };\n\n        /**\n         * Slides to the previous item or page.\n         * @public\n         * @param {Number} [speed=false] - The time in milliseconds for the transition.\n         */\n        Navigation.prototype.prev = function (speed) {\n            $.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);\n        };\n\n        /**\n         * Slides to the specified item or page.\n         * @public\n         * @param {Number} position - The position of the item or page.\n         * @param {Number} [speed] - The time in milliseconds for the transition.\n         * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.\n         */\n        Navigation.prototype.to = function (position, speed, standard) {\n            var length;\n\n            if (!standard && this._pages.length) {\n                length = this._pages.length;\n                $.proxy(this._overrides.to, this._core)(this._pages[((position % length) + length) % length].start, speed);\n            } else {\n                $.proxy(this._overrides.to, this._core)(position, speed);\n            }\n        };\n\n        $.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;\n\n    })(window.Zepto || window.jQuery, window, document);\n\n    /**\n     * Hash Plugin\n     * @version 2.3.4\n     * @author Artus Kolanowski\n     * @author David Deutsch\n     * @license The MIT License (MIT)\n     */\n    ;(function ($, window, document, undefined) {\n        'use strict';\n\n        /**\n         * Creates the hash plugin.\n         * @class The Hash Plugin\n         * @param {Owl} carousel - The Owl Carousel\n         */\n        var Hash = function (carousel) {\n            /**\n             * Reference to the core.\n             * @protected\n             * @type {Owl}\n             */\n            this._core = carousel;\n\n            /**\n             * Hash index for the items.\n             * @protected\n             * @type {Object}\n             */\n            this._hashes = {};\n\n            /**\n             * The carousel element.\n             * @type {jQuery}\n             */\n            this.$element = this._core.$element;\n\n            /**\n             * All event handlers.\n             * @protected\n             * @type {Object}\n             */\n            this._handlers = {\n                'initialized.owl.carousel': $.proxy(function (e) {\n                    if (e.namespace && this._core.settings.startPosition === 'URLHash') {\n                        $(window).trigger('hashchange.owl.navigation');\n                    }\n                }, this),\n                'prepared.owl.carousel': $.proxy(function (e) {\n                    if (e.namespace) {\n                        var hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');\n\n                        if (!hash) {\n                            return;\n                        }\n\n                        this._hashes[hash] = e.content;\n                    }\n                }, this),\n                'changed.owl.carousel': $.proxy(function (e) {\n                    if (e.namespace && e.property.name === 'position') {\n                        var current = this._core.items(this._core.relative(this._core.current())),\n                            hash = $.map(this._hashes, function (item, hash) {\n                                return item === current ? hash : null;\n                            }).join();\n\n                        if (!hash || window.location.hash.slice(1) === hash) {\n                            return;\n                        }\n\n                        window.location.hash = hash;\n                    }\n                }, this)\n            };\n\n            // set default options\n            this._core.options = $.extend({}, Hash.Defaults, this._core.options);\n\n            // register the event handlers\n            this.$element.on(this._handlers);\n\n            // register event listener for hash navigation\n            $(window).on('hashchange.owl.navigation', $.proxy(function (e) {\n                var hash = window.location.hash.substring(1),\n                    items = this._core.$stage.children(),\n                    position = this._hashes[hash] && items.index(this._hashes[hash]);\n\n                if (position === undefined || position === this._core.current()) {\n                    return;\n                }\n\n                this._core.to(this._core.relative(position), false, true);\n            }, this));\n        };\n\n        /**\n         * Default options.\n         * @public\n         */\n        Hash.Defaults = {\n            URLhashListener: false\n        };\n\n        /**\n         * Destroys the plugin.\n         * @public\n         */\n        Hash.prototype.destroy = function () {\n            var handler, property;\n\n            $(window).off('hashchange.owl.navigation');\n\n            for (handler in this._handlers) {\n                this._core.$element.off(handler, this._handlers[handler]);\n            }\n            for (property in Object.getOwnPropertyNames(this)) {\n                typeof this[property] != 'function' && (this[property] = null);\n            }\n        };\n\n        $.fn.owlCarousel.Constructor.Plugins.Hash = Hash;\n\n    })(window.Zepto || window.jQuery, window, document);\n\n    /**\n     * Support Plugin\n     *\n     * @version 2.3.4\n     * @author Vivid Planet Software GmbH\n     * @author Artus Kolanowski\n     * @author David Deutsch\n     * @license The MIT License (MIT)\n     */\n    ;(function ($, window, document, undefined) {\n\n        var style = $('<support>').get(0).style,\n            prefixes = 'Webkit Moz O ms'.split(' '),\n            events = {\n                transition: {\n                    end: {\n                        WebkitTransition: 'webkitTransitionEnd',\n                        MozTransition: 'transitionend',\n                        OTransition: 'oTransitionEnd',\n                        transition: 'transitionend'\n                    }\n                },\n                animation: {\n                    end: {\n                        WebkitAnimation: 'webkitAnimationEnd',\n                        MozAnimation: 'animationend',\n                        OAnimation: 'oAnimationEnd',\n                        animation: 'animationend'\n                    }\n                }\n            },\n            tests = {\n                csstransforms: function () {\n                    return !!test('transform');\n                },\n                csstransforms3d: function () {\n                    return !!test('perspective');\n                },\n                csstransitions: function () {\n                    return !!test('transition');\n                },\n                cssanimations: function () {\n                    return !!test('animation');\n                }\n            };\n\n        function test(property, prefixed) {\n            var result = false,\n                upper = property.charAt(0).toUpperCase() + property.slice(1);\n\n            $.each((property + ' ' + prefixes.join(upper + ' ') + upper).split(' '), function (i, property) {\n                if (style[property] !== undefined) {\n                    result = prefixed ? property : true;\n                    return false;\n                }\n            });\n\n            return result;\n        }\n\n        function prefixed(property) {\n            return test(property, true);\n        }\n\n        if (tests.csstransitions()) {\n            /* jshint -W053 */\n            $.support.transition = new String(prefixed('transition'))\n            $.support.transition.end = events.transition.end[$.support.transition];\n        }\n\n        if (tests.cssanimations()) {\n            /* jshint -W053 */\n            $.support.animation = new String(prefixed('animation'))\n            $.support.animation.end = events.animation.end[$.support.animation];\n        }\n\n        if (tests.csstransforms()) {\n            /* jshint -W053 */\n            $.support.transform = new String(prefixed('transform'));\n            $.support.transform3d = tests.csstransforms3d();\n        }\n\n    })(window.Zepto || window.jQuery, window, document);\n});\n","js/slick.js":"/*\n _ _      _       _\n ___| (_) ___| | __  (_)___\n / __| | |/ __| |/ /  | / __|\n \\__ \\ | | (__|   < _ | \\__ \\\n |___/_|_|\\___|_|\\_(_)/ |___/\n |__/\n\n Version: 1.8.0\n Author: Ken Wheeler\n Website: http://kenwheeler.github.io\n Docs: http://kenwheeler.github.io/slick\n Repo: http://github.com/kenwheeler/slick\n Issues: http://github.com/kenwheeler/slick/issues\n\n */\n/* global window, document, define, jQuery, setInterval, clearInterval */\n\n;(function (factory) {\n    'use strict';\n    if (typeof define === 'function' && define.amd) {\n        define(['jquery'], factory);\n    } else if (typeof exports !== 'undefined') {\n        module.exports = factory(require('jquery'));\n    } else {\n        factory(jQuery);\n    }\n\n}(function ($) {\n    'use strict';\n    var Slick = window.Slick || {};\n\n    Slick = (function () {\n\n        var instanceUid = 0;\n\n        function Slick(element, settings) {\n\n            var _ = this, dataSettings;\n\n            _.defaults = {\n                accessibility: true,\n                adaptiveHeight: false,\n                appendArrows: $(element),\n                appendDots: $(element),\n                arrows: true,\n                asNavFor: null,\n                prevArrow: '<button class=\"slick-prev\" aria-label=\"Previous\" type=\"button\">Previous</button>',\n                nextArrow: '<button class=\"slick-next\" aria-label=\"Next\" type=\"button\">Next</button>',\n                autoplay: false,\n                autoplaySpeed: 3000,\n                centerMode: false,\n                centerPadding: '50px',\n                cssEase: 'ease',\n                customPaging: function (slider, i) {\n                    return $('<button type=\"button\" />').text(i + 1);\n                },\n                dots: false,\n                dotsClass: 'slick-dots',\n                draggable: true,\n                easing: 'linear',\n                edgeFriction: 0.35,\n                fade: false,\n                focusOnSelect: false,\n                focusOnChange: false,\n                infinite: true,\n                initialSlide: 0,\n                lazyLoad: 'ondemand',\n                mobileFirst: false,\n                pauseOnHover: true,\n                pauseOnFocus: true,\n                pauseOnDotsHover: false,\n                respondTo: 'window',\n                responsive: null,\n                rows: 1,\n                rtl: false,\n                slide: '',\n                slidesPerRow: 1,\n                slidesToShow: 1,\n                slidesToScroll: 1,\n                speed: 500,\n                swipe: true,\n                swipeToSlide: false,\n                touchMove: true,\n                touchThreshold: 5,\n                useCSS: true,\n                useTransform: true,\n                variableWidth: false,\n                vertical: false,\n                verticalSwiping: false,\n                waitForAnimate: true,\n                zIndex: 1000\n            };\n\n            _.initials = {\n                animating: false,\n                dragging: false,\n                autoPlayTimer: null,\n                currentDirection: 0,\n                currentLeft: null,\n                currentSlide: 0,\n                direction: 1,\n                $dots: null,\n                listWidth: null,\n                listHeight: null,\n                loadIndex: 0,\n                $nextArrow: null,\n                $prevArrow: null,\n                scrolling: false,\n                slideCount: null,\n                slideWidth: null,\n                $slideTrack: null,\n                $slides: null,\n                sliding: false,\n                slideOffset: 0,\n                swipeLeft: null,\n                swiping: false,\n                $list: null,\n                touchObject: {},\n                transformsEnabled: false,\n                unslicked: false\n            };\n\n            $.extend(_, _.initials);\n\n            _.activeBreakpoint = null;\n            _.animType = null;\n            _.animProp = null;\n            _.breakpoints = [];\n            _.breakpointSettings = [];\n            _.cssTransitions = false;\n            _.focussed = false;\n            _.interrupted = false;\n            _.hidden = 'hidden';\n            _.paused = true;\n            _.positionProp = null;\n            _.respondTo = null;\n            _.rowCount = 1;\n            _.shouldClick = true;\n            _.$slider = $(element);\n            _.$slidesCache = null;\n            _.transformType = null;\n            _.transitionType = null;\n            _.visibilityChange = 'visibilitychange';\n            _.windowWidth = 0;\n            _.windowTimer = null;\n\n            dataSettings = $(element).data('slick') || {};\n\n            _.options = $.extend({}, _.defaults, settings, dataSettings);\n\n            _.currentSlide = _.options.initialSlide;\n\n            _.originalSettings = _.options;\n\n            if (typeof document.mozHidden !== 'undefined') {\n                _.hidden = 'mozHidden';\n                _.visibilityChange = 'mozvisibilitychange';\n            } else if (typeof document.webkitHidden !== 'undefined') {\n                _.hidden = 'webkitHidden';\n                _.visibilityChange = 'webkitvisibilitychange';\n            }\n\n            _.autoPlay = $.proxy(_.autoPlay, _);\n            _.autoPlayClear = $.proxy(_.autoPlayClear, _);\n            _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);\n            _.changeSlide = $.proxy(_.changeSlide, _);\n            _.clickHandler = $.proxy(_.clickHandler, _);\n            _.selectHandler = $.proxy(_.selectHandler, _);\n            _.setPosition = $.proxy(_.setPosition, _);\n            _.swipeHandler = $.proxy(_.swipeHandler, _);\n            _.dragHandler = $.proxy(_.dragHandler, _);\n            _.keyHandler = $.proxy(_.keyHandler, _);\n\n            _.instanceUid = instanceUid++;\n\n            // A simple way to check for HTML strings\n            // Strict HTML recognition (must start with <)\n            // Extracted from jQuery v1.11 source\n            _.htmlExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*)$/;\n\n\n            _.registerBreakpoints();\n            _.init(true);\n\n        }\n\n        return Slick;\n\n    }());\n\n    Slick.prototype.activateADA = function () {\n        var _ = this;\n\n        _.$slideTrack.find('.slick-active').attr({\n            'aria-hidden': 'false'\n        }).find('a, input, button, select').attr({\n            'tabindex': '0'\n        });\n\n    };\n\n    Slick.prototype.addSlide = Slick.prototype.slickAdd = function (markup, index, addBefore) {\n\n        var _ = this;\n\n        if (typeof(index) === 'boolean') {\n            addBefore = index;\n            index = null;\n        } else if (index < 0 || (index >= _.slideCount)) {\n            return false;\n        }\n\n        _.unload();\n\n        if (typeof(index) === 'number') {\n            if (index === 0 && _.$slides.length === 0) {\n                $(markup).appendTo(_.$slideTrack);\n            } else if (addBefore) {\n                $(markup).insertBefore(_.$slides.eq(index));\n            } else {\n                $(markup).insertAfter(_.$slides.eq(index));\n            }\n        } else {\n            if (addBefore === true) {\n                $(markup).prependTo(_.$slideTrack);\n            } else {\n                $(markup).appendTo(_.$slideTrack);\n            }\n        }\n\n        _.$slides = _.$slideTrack.children(this.options.slide);\n\n        _.$slideTrack.children(this.options.slide).detach();\n\n        _.$slideTrack.append(_.$slides);\n\n        _.$slides.each(function (index, element) {\n            $(element).attr('data-slick-index', index);\n        });\n\n        _.$slidesCache = _.$slides;\n\n        _.reinit();\n\n    };\n\n    Slick.prototype.animateHeight = function () {\n        var _ = this;\n        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {\n            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);\n            _.$list.animate({\n                height: targetHeight\n            }, _.options.speed);\n        }\n    };\n\n    Slick.prototype.animateSlide = function (targetLeft, callback) {\n\n        var animProps = {},\n            _ = this;\n\n        _.animateHeight();\n\n        if (_.options.rtl === true && _.options.vertical === false) {\n            targetLeft = -targetLeft;\n        }\n        if (_.transformsEnabled === false) {\n            if (_.options.vertical === false) {\n                _.$slideTrack.animate({\n                    left: targetLeft\n                }, _.options.speed, _.options.easing, callback);\n            } else {\n                _.$slideTrack.animate({\n                    top: targetLeft\n                }, _.options.speed, _.options.easing, callback);\n            }\n\n        } else {\n\n            if (_.cssTransitions === false) {\n                if (_.options.rtl === true) {\n                    _.currentLeft = -(_.currentLeft);\n                }\n                $({\n                    animStart: _.currentLeft\n                }).animate({\n                    animStart: targetLeft\n                }, {\n                    duration: _.options.speed,\n                    easing: _.options.easing,\n                    step: function (now) {\n                        now = Math.ceil(now);\n                        if (_.options.vertical === false) {\n                            animProps[_.animType] = 'translate(' +\n                                now + 'px, 0px)';\n                            _.$slideTrack.css(animProps);\n                        } else {\n                            animProps[_.animType] = 'translate(0px,' +\n                                now + 'px)';\n                            _.$slideTrack.css(animProps);\n                        }\n                    },\n                    complete: function () {\n                        if (callback) {\n                            callback.call();\n                        }\n                    }\n                });\n\n            } else {\n\n                _.applyTransition();\n                targetLeft = Math.ceil(targetLeft);\n\n                if (_.options.vertical === false) {\n                    animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';\n                } else {\n                    animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';\n                }\n                _.$slideTrack.css(animProps);\n\n                if (callback) {\n                    setTimeout(function () {\n\n                        _.disableTransition();\n\n                        callback.call();\n                    }, _.options.speed);\n                }\n\n            }\n\n        }\n\n    };\n\n    Slick.prototype.getNavTarget = function () {\n\n        var _ = this,\n            asNavFor = _.options.asNavFor;\n\n        if (asNavFor && asNavFor !== null) {\n            asNavFor = $(asNavFor).not(_.$slider);\n        }\n\n        return asNavFor;\n\n    };\n\n    Slick.prototype.asNavFor = function (index) {\n\n        var _ = this,\n            asNavFor = _.getNavTarget();\n\n        if (asNavFor !== null && typeof asNavFor === 'object') {\n            asNavFor.each(function () {\n                var target = $(this).slick('getSlick');\n                if (!target.unslicked) {\n                    target.slideHandler(index, true);\n                }\n            });\n        }\n\n    };\n\n    Slick.prototype.applyTransition = function (slide) {\n\n        var _ = this,\n            transition = {};\n\n        if (_.options.fade === false) {\n            transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;\n        } else {\n            transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;\n        }\n\n        if (_.options.fade === false) {\n            _.$slideTrack.css(transition);\n        } else {\n            _.$slides.eq(slide).css(transition);\n        }\n\n    };\n\n    Slick.prototype.autoPlay = function () {\n\n        var _ = this;\n\n        _.autoPlayClear();\n\n        if (_.slideCount > _.options.slidesToShow) {\n            _.autoPlayTimer = setInterval(_.autoPlayIterator, _.options.autoplaySpeed);\n        }\n\n    };\n\n    Slick.prototype.autoPlayClear = function () {\n\n        var _ = this;\n\n        if (_.autoPlayTimer) {\n            clearInterval(_.autoPlayTimer);\n        }\n\n    };\n\n    Slick.prototype.autoPlayIterator = function () {\n\n        var _ = this,\n            slideTo = _.currentSlide + _.options.slidesToScroll;\n\n        if (!_.paused && !_.interrupted && !_.focussed) {\n\n            if (_.options.infinite === false) {\n\n                if (_.direction === 1 && ( _.currentSlide + 1 ) === ( _.slideCount - 1 )) {\n                    _.direction = 0;\n                }\n\n                else if (_.direction === 0) {\n\n                    slideTo = _.currentSlide - _.options.slidesToScroll;\n\n                    if (_.currentSlide - 1 === 0) {\n                        _.direction = 1;\n                    }\n\n                }\n\n            }\n\n            _.slideHandler(slideTo);\n\n        }\n\n    };\n\n    Slick.prototype.buildArrows = function () {\n\n        var _ = this;\n\n        if (_.options.arrows === true) {\n\n            _.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');\n            _.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');\n\n            if (_.slideCount > _.options.slidesToShow) {\n\n                _.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');\n                _.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');\n\n                if (_.htmlExpr.test(_.options.prevArrow)) {\n                    _.$prevArrow.prependTo(_.options.appendArrows);\n                }\n\n                if (_.htmlExpr.test(_.options.nextArrow)) {\n                    _.$nextArrow.appendTo(_.options.appendArrows);\n                }\n\n                if (_.options.infinite !== true) {\n                    _.$prevArrow\n                        .addClass('slick-disabled')\n                        .attr('aria-disabled', 'true');\n                }\n\n            } else {\n\n                _.$prevArrow.add(_.$nextArrow)\n\n                    .addClass('slick-hidden')\n                    .attr({\n                        'aria-disabled': 'true',\n                        'tabindex': '-1'\n                    });\n\n            }\n\n        }\n\n    };\n\n    Slick.prototype.buildDots = function () {\n\n        var _ = this,\n            i, dot;\n\n        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {\n\n            _.$slider.addClass('slick-dotted');\n\n            dot = $('<ul />').addClass(_.options.dotsClass);\n\n            for (i = 0; i <= _.getDotCount(); i += 1) {\n                dot.append($('<li />').append(_.options.customPaging.call(this, _, i)));\n            }\n\n            _.$dots = dot.appendTo(_.options.appendDots);\n\n            _.$dots.find('li').first().addClass('slick-active');\n\n        }\n\n    };\n\n    Slick.prototype.buildOut = function () {\n\n        var _ = this;\n\n        _.$slides =\n            _.$slider\n                .children(_.options.slide + ':not(.slick-cloned)')\n                .addClass('slick-slide');\n\n        _.slideCount = _.$slides.length;\n\n        _.$slides.each(function (index, element) {\n            $(element)\n                .attr('data-slick-index', index)\n                .data('originalStyling', $(element).attr('style') || '');\n        });\n\n        _.$slider.addClass('slick-slider');\n\n        _.$slideTrack = (_.slideCount === 0) ?\n            $('<div class=\"slick-track\"/>').appendTo(_.$slider) :\n            _.$slides.wrapAll('<div class=\"slick-track\"/>').parent();\n\n        _.$list = _.$slideTrack.wrap(\n            '<div class=\"slick-list\"/>').parent();\n        _.$slideTrack.css('opacity', 0);\n\n        if (_.options.centerMode === true || _.options.swipeToSlide === true) {\n            _.options.slidesToScroll = 1;\n        }\n\n        $('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');\n\n        _.setupInfinite();\n\n        _.buildArrows();\n\n        _.buildDots();\n\n        _.updateDots();\n\n\n        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);\n\n        if (_.options.draggable === true) {\n            _.$list.addClass('draggable');\n        }\n\n    };\n\n    Slick.prototype.buildRows = function () {\n\n        var _ = this, a, b, c, newSlides, numOfSlides, originalSlides, slidesPerSection;\n\n        newSlides = document.createDocumentFragment();\n        originalSlides = _.$slider.children();\n\n        if (_.options.rows > 0) {\n\n            slidesPerSection = _.options.slidesPerRow * _.options.rows;\n            numOfSlides = Math.ceil(\n                originalSlides.length / slidesPerSection\n            );\n\n            for (a = 0; a < numOfSlides; a++) {\n                var slide = document.createElement('div');\n                for (b = 0; b < _.options.rows; b++) {\n                    var row = document.createElement('div');\n                    for (c = 0; c < _.options.slidesPerRow; c++) {\n                        var target = (a * slidesPerSection + ((b * _.options.slidesPerRow) + c));\n                        if (originalSlides.get(target)) {\n                            row.appendChild(originalSlides.get(target));\n                        }\n                    }\n                    slide.appendChild(row);\n                }\n                newSlides.appendChild(slide);\n            }\n\n            _.$slider.empty().append(newSlides);\n            _.$slider.children().children().children()\n                .css({\n                    'width': (100 / _.options.slidesPerRow) + '%',\n                    'display': 'inline-block'\n                });\n\n        }\n\n    };\n\n    Slick.prototype.checkResponsive = function (initial, forceUpdate) {\n\n        var _ = this,\n            breakpoint, targetBreakpoint, respondToWidth, triggerBreakpoint = false;\n        var sliderWidth = _.$slider.width();\n        var windowWidth = window.innerWidth || $(window).width();\n\n        if (_.respondTo === 'window') {\n            respondToWidth = windowWidth;\n        } else if (_.respondTo === 'slider') {\n            respondToWidth = sliderWidth;\n        } else if (_.respondTo === 'min') {\n            respondToWidth = Math.min(windowWidth, sliderWidth);\n        }\n\n        if (_.options.responsive &&\n            _.options.responsive.length &&\n            _.options.responsive !== null) {\n\n            targetBreakpoint = null;\n\n            for (breakpoint in _.breakpoints) {\n                if (_.breakpoints.hasOwnProperty(breakpoint)) {\n                    if (_.originalSettings.mobileFirst === false) {\n                        if (respondToWidth < _.breakpoints[breakpoint]) {\n                            targetBreakpoint = _.breakpoints[breakpoint];\n                        }\n                    } else {\n                        if (respondToWidth > _.breakpoints[breakpoint]) {\n                            targetBreakpoint = _.breakpoints[breakpoint];\n                        }\n                    }\n                }\n            }\n\n            if (targetBreakpoint !== null) {\n                if (_.activeBreakpoint !== null) {\n                    if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {\n                        _.activeBreakpoint =\n                            targetBreakpoint;\n                        if (_.breakpointSettings[targetBreakpoint] === 'unslick') {\n                            _.unslick(targetBreakpoint);\n                        } else {\n                            _.options = $.extend({}, _.originalSettings,\n                                _.breakpointSettings[\n                                    targetBreakpoint]);\n                            if (initial === true) {\n                                _.currentSlide = _.options.initialSlide;\n                            }\n                            _.refresh(initial);\n                        }\n                        triggerBreakpoint = targetBreakpoint;\n                    }\n                } else {\n                    _.activeBreakpoint = targetBreakpoint;\n                    if (_.breakpointSettings[targetBreakpoint] === 'unslick') {\n                        _.unslick(targetBreakpoint);\n                    } else {\n                        _.options = $.extend({}, _.originalSettings,\n                            _.breakpointSettings[\n                                targetBreakpoint]);\n                        if (initial === true) {\n                            _.currentSlide = _.options.initialSlide;\n                        }\n                        _.refresh(initial);\n                    }\n                    triggerBreakpoint = targetBreakpoint;\n                }\n            } else {\n                if (_.activeBreakpoint !== null) {\n                    _.activeBreakpoint = null;\n                    _.options = _.originalSettings;\n                    if (initial === true) {\n                        _.currentSlide = _.options.initialSlide;\n                    }\n                    _.refresh(initial);\n                    triggerBreakpoint = targetBreakpoint;\n                }\n            }\n\n            // only trigger breakpoints during an actual break. not on initialize.\n            if (!initial && triggerBreakpoint !== false) {\n                _.$slider.trigger('breakpoint', [_, triggerBreakpoint]);\n            }\n        }\n\n    };\n\n    Slick.prototype.changeSlide = function (event, dontAnimate) {\n\n        var _ = this,\n            $target = $(event.currentTarget),\n            indexOffset, slideOffset, unevenOffset;\n\n        // If target is a link, prevent default action.\n        if ($target.is('a')) {\n            event.preventDefault();\n        }\n\n        // If target is not the <li> element (ie: a child), find the <li>.\n        if (!$target.is('li')) {\n            $target = $target.closest('li');\n        }\n\n        unevenOffset = (_.slideCount % _.options.slidesToScroll !== 0);\n        indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;\n\n        switch (event.data.message) {\n\n            case 'previous':\n                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;\n                if (_.slideCount > _.options.slidesToShow) {\n                    _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);\n                }\n                break;\n\n            case 'next':\n                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;\n                if (_.slideCount > _.options.slidesToShow) {\n                    _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);\n                }\n                break;\n\n            case 'index':\n                var index = event.data.index === 0 ? 0 :\n                    event.data.index || $target.index() * _.options.slidesToScroll;\n\n                _.slideHandler(_.checkNavigable(index), false, dontAnimate);\n                $target.children().trigger('focus');\n                break;\n\n            default:\n                return;\n        }\n\n    };\n\n    Slick.prototype.checkNavigable = function (index) {\n\n        var _ = this,\n            navigables, prevNavigable;\n\n        navigables = _.getNavigableIndexes();\n        prevNavigable = 0;\n        if (index > navigables[navigables.length - 1]) {\n            index = navigables[navigables.length - 1];\n        } else {\n            for (var n in navigables) {\n                if (index < navigables[n]) {\n                    index = prevNavigable;\n                    break;\n                }\n                prevNavigable = navigables[n];\n            }\n        }\n\n        return index;\n    };\n\n    Slick.prototype.cleanUpEvents = function () {\n\n        var _ = this;\n\n        if (_.options.dots && _.$dots !== null) {\n\n            $('li', _.$dots)\n                .off('click.slick', _.changeSlide)\n                .off('mouseenter.slick', $.proxy(_.interrupt, _, true))\n                .off('mouseleave.slick', $.proxy(_.interrupt, _, false));\n\n            if (_.options.accessibility === true) {\n                _.$dots.off('keydown.slick', _.keyHandler);\n            }\n        }\n\n        _.$slider.off('focus.slick blur.slick');\n\n        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {\n            _.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);\n            _.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);\n\n            if (_.options.accessibility === true) {\n                _.$prevArrow && _.$prevArrow.off('keydown.slick', _.keyHandler);\n                _.$nextArrow && _.$nextArrow.off('keydown.slick', _.keyHandler);\n            }\n        }\n\n        _.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);\n        _.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);\n        _.$list.off('touchend.slick mouseup.slick', _.swipeHandler);\n        _.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);\n\n        _.$list.off('click.slick', _.clickHandler);\n\n        $(document).off(_.visibilityChange, _.visibility);\n\n        _.cleanUpSlideEvents();\n\n        if (_.options.accessibility === true) {\n            _.$list.off('keydown.slick', _.keyHandler);\n        }\n\n        if (_.options.focusOnSelect === true) {\n            $(_.$slideTrack).children().off('click.slick', _.selectHandler);\n        }\n\n        $(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);\n\n        $(window).off('resize.slick.slick-' + _.instanceUid, _.resize);\n\n        $('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);\n\n        $(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);\n\n    };\n\n    Slick.prototype.cleanUpSlideEvents = function () {\n\n        var _ = this;\n\n        _.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));\n        _.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));\n\n    };\n\n    Slick.prototype.cleanUpRows = function () {\n\n        var _ = this, originalSlides;\n\n        if (_.options.rows > 0) {\n            originalSlides = _.$slides.children().children();\n            originalSlides.removeAttr('style');\n            _.$slider.empty().append(originalSlides);\n        }\n\n    };\n\n    Slick.prototype.clickHandler = function (event) {\n\n        var _ = this;\n\n        if (_.shouldClick === false) {\n            event.stopImmediatePropagation();\n            event.stopPropagation();\n            event.preventDefault();\n        }\n\n    };\n\n    Slick.prototype.destroy = function (refresh) {\n\n        var _ = this;\n\n        _.autoPlayClear();\n\n        _.touchObject = {};\n\n        _.cleanUpEvents();\n\n        $('.slick-cloned', _.$slider).detach();\n\n        if (_.$dots) {\n            _.$dots.remove();\n        }\n\n        if (_.$prevArrow && _.$prevArrow.length) {\n\n            _.$prevArrow\n                .removeClass('slick-disabled slick-arrow slick-hidden')\n                .removeAttr('aria-hidden aria-disabled tabindex')\n                .css('display', '');\n\n            if (_.htmlExpr.test(_.options.prevArrow)) {\n                _.$prevArrow.remove();\n            }\n        }\n\n        if (_.$nextArrow && _.$nextArrow.length) {\n\n            _.$nextArrow\n                .removeClass('slick-disabled slick-arrow slick-hidden')\n                .removeAttr('aria-hidden aria-disabled tabindex')\n                .css('display', '');\n\n            if (_.htmlExpr.test(_.options.nextArrow)) {\n                _.$nextArrow.remove();\n            }\n        }\n\n\n        if (_.$slides) {\n\n            _.$slides\n                .removeClass('slick-slide slick-active slick-center slick-visible slick-current')\n                .removeAttr('aria-hidden')\n                .removeAttr('data-slick-index')\n                .each(function () {\n                    $(this).attr('style', $(this).data('originalStyling'));\n                });\n\n            _.$slideTrack.children(this.options.slide).detach();\n\n            _.$slideTrack.detach();\n\n            _.$list.detach();\n\n            _.$slider.append(_.$slides);\n        }\n\n        _.cleanUpRows();\n\n        _.$slider.removeClass('slick-slider');\n        _.$slider.removeClass('slick-initialized');\n        _.$slider.removeClass('slick-dotted');\n\n        _.unslicked = true;\n\n        if (!refresh) {\n            _.$slider.trigger('destroy', [_]);\n        }\n\n    };\n\n    Slick.prototype.disableTransition = function (slide) {\n\n        var _ = this,\n            transition = {};\n\n        transition[_.transitionType] = '';\n\n        if (_.options.fade === false) {\n            _.$slideTrack.css(transition);\n        } else {\n            _.$slides.eq(slide).css(transition);\n        }\n\n    };\n\n    Slick.prototype.fadeSlide = function (slideIndex, callback) {\n\n        var _ = this;\n\n        if (_.cssTransitions === false) {\n\n            _.$slides.eq(slideIndex).css({\n                zIndex: _.options.zIndex\n            });\n\n            _.$slides.eq(slideIndex).animate({\n                opacity: 1\n            }, _.options.speed, _.options.easing, callback);\n\n        } else {\n\n            _.applyTransition(slideIndex);\n\n            _.$slides.eq(slideIndex).css({\n                opacity: 1,\n                zIndex: _.options.zIndex\n            });\n\n            if (callback) {\n                setTimeout(function () {\n\n                    _.disableTransition(slideIndex);\n\n                    callback.call();\n                }, _.options.speed);\n            }\n\n        }\n\n    };\n\n    Slick.prototype.fadeSlideOut = function (slideIndex) {\n\n        var _ = this;\n\n        if (_.cssTransitions === false) {\n\n            _.$slides.eq(slideIndex).animate({\n                opacity: 0,\n                zIndex: _.options.zIndex - 2\n            }, _.options.speed, _.options.easing);\n\n        } else {\n\n            _.applyTransition(slideIndex);\n\n            _.$slides.eq(slideIndex).css({\n                opacity: 0,\n                zIndex: _.options.zIndex - 2\n            });\n\n        }\n\n    };\n\n    Slick.prototype.filterSlides = Slick.prototype.slickFilter = function (filter) {\n\n        var _ = this;\n\n        if (filter !== null) {\n\n            _.$slidesCache = _.$slides;\n\n            _.unload();\n\n            _.$slideTrack.children(this.options.slide).detach();\n\n            _.$slidesCache.filter(filter).appendTo(_.$slideTrack);\n\n            _.reinit();\n\n        }\n\n    };\n\n    Slick.prototype.focusHandler = function () {\n\n        var _ = this;\n\n        _.$slider\n            .off('focus.slick blur.slick')\n            .on('focus.slick blur.slick', '*', function (event) {\n\n                event.stopImmediatePropagation();\n                var $sf = $(this);\n\n                setTimeout(function () {\n\n                    if (_.options.pauseOnFocus) {\n                        _.focussed = $sf.is(':focus');\n                        _.autoPlay();\n                    }\n\n                }, 0);\n\n            });\n    };\n\n    Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function () {\n\n        var _ = this;\n        return _.currentSlide;\n\n    };\n\n    Slick.prototype.getDotCount = function () {\n\n        var _ = this;\n\n        var breakPoint = 0;\n        var counter = 0;\n        var pagerQty = 0;\n\n        if (_.options.infinite === true) {\n            if (_.slideCount <= _.options.slidesToShow) {\n                ++pagerQty;\n            } else {\n                while (breakPoint < _.slideCount) {\n                    ++pagerQty;\n                    breakPoint = counter + _.options.slidesToScroll;\n                    counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;\n                }\n            }\n        } else if (_.options.centerMode === true) {\n            pagerQty = _.slideCount;\n        } else if (!_.options.asNavFor) {\n            pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);\n        } else {\n            while (breakPoint < _.slideCount) {\n                ++pagerQty;\n                breakPoint = counter + _.options.slidesToScroll;\n                counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;\n            }\n        }\n\n        return pagerQty - 1;\n\n    };\n\n    Slick.prototype.getLeft = function (slideIndex) {\n\n        var _ = this,\n            targetLeft,\n            verticalHeight,\n            verticalOffset = 0,\n            targetSlide,\n            coef;\n\n        _.slideOffset = 0;\n        verticalHeight = _.$slides.first().outerHeight(true);\n\n        if (_.options.infinite === true) {\n            if (_.slideCount > _.options.slidesToShow) {\n                _.slideOffset = (_.slideWidth * _.options.slidesToShow) * -1;\n                coef = -1\n\n                if (_.options.vertical === true && _.options.centerMode === true) {\n                    if (_.options.slidesToShow === 2) {\n                        coef = -1.5;\n                    } else if (_.options.slidesToShow === 1) {\n                        coef = -2\n                    }\n                }\n                verticalOffset = (verticalHeight * _.options.slidesToShow) * coef;\n            }\n            if (_.slideCount % _.options.slidesToScroll !== 0) {\n                if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {\n                    if (slideIndex > _.slideCount) {\n                        _.slideOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth) * -1;\n                        verticalOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight) * -1;\n                    } else {\n                        _.slideOffset = ((_.slideCount % _.options.slidesToScroll) * _.slideWidth) * -1;\n                        verticalOffset = ((_.slideCount % _.options.slidesToScroll) * verticalHeight) * -1;\n                    }\n                }\n            }\n        } else {\n            if (slideIndex + _.options.slidesToShow > _.slideCount) {\n                _.slideOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * _.slideWidth;\n                verticalOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * verticalHeight;\n            }\n        }\n\n        if (_.slideCount <= _.options.slidesToShow) {\n            _.slideOffset = 0;\n            verticalOffset = 0;\n        }\n\n        if (_.options.centerMode === true && _.slideCount <= _.options.slidesToShow) {\n            _.slideOffset = ((_.slideWidth * Math.floor(_.options.slidesToShow)) / 2) - ((_.slideWidth * _.slideCount) / 2);\n        } else if (_.options.centerMode === true && _.options.infinite === true) {\n            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;\n        } else if (_.options.centerMode === true) {\n            _.slideOffset = 0;\n            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);\n        }\n\n        if (_.options.vertical === false) {\n            targetLeft = ((slideIndex * _.slideWidth) * -1) + _.slideOffset;\n        } else {\n            targetLeft = ((slideIndex * verticalHeight) * -1) + verticalOffset;\n        }\n\n        if (_.options.variableWidth === true) {\n\n            if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {\n                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);\n            } else {\n                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);\n            }\n\n            if (_.options.rtl === true) {\n                if (targetSlide[0]) {\n                    targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;\n                } else {\n                    targetLeft = 0;\n                }\n            } else {\n                targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;\n            }\n\n            if (_.options.centerMode === true) {\n                if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {\n                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);\n                } else {\n                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);\n                }\n\n                if (_.options.rtl === true) {\n                    if (targetSlide[0]) {\n                        targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;\n                    } else {\n                        targetLeft = 0;\n                    }\n                } else {\n                    targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;\n                }\n\n                targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;\n            }\n        }\n\n        return targetLeft;\n\n    };\n\n    Slick.prototype.getOption = Slick.prototype.slickGetOption = function (option) {\n\n        var _ = this;\n\n        return _.options[option];\n\n    };\n\n    Slick.prototype.getNavigableIndexes = function () {\n\n        var _ = this,\n            breakPoint = 0,\n            counter = 0,\n            indexes = [],\n            max;\n\n        if (_.options.infinite === false) {\n            max = _.slideCount;\n        } else {\n            breakPoint = _.options.slidesToScroll * -1;\n            counter = _.options.slidesToScroll * -1;\n            max = _.slideCount * 2;\n        }\n\n        while (breakPoint < max) {\n            indexes.push(breakPoint);\n            breakPoint = counter + _.options.slidesToScroll;\n            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;\n        }\n\n        return indexes;\n\n    };\n\n    Slick.prototype.getSlick = function () {\n\n        return this;\n\n    };\n\n    Slick.prototype.getSlideCount = function () {\n\n        var _ = this,\n            slidesTraversed, swipedSlide, centerOffset;\n\n        centerOffset = _.options.centerMode === true ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;\n\n        if (_.options.swipeToSlide === true) {\n            _.$slideTrack.find('.slick-slide').each(function (index, slide) {\n                if (slide.offsetLeft - centerOffset + ($(slide).outerWidth() / 2) > (_.swipeLeft * -1)) {\n                    swipedSlide = slide;\n                    return false;\n                }\n            });\n\n            slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;\n\n            return slidesTraversed;\n\n        } else {\n            return _.options.slidesToScroll;\n        }\n\n    };\n\n    Slick.prototype.goTo = Slick.prototype.slickGoTo = function (slide, dontAnimate) {\n\n        var _ = this;\n\n        _.changeSlide({\n            data: {\n                message: 'index',\n                index: parseInt(slide)\n            }\n        }, dontAnimate);\n\n    };\n\n    Slick.prototype.init = function (creation) {\n\n        var _ = this;\n\n        if (!$(_.$slider).hasClass('slick-initialized')) {\n\n            $(_.$slider).addClass('slick-initialized');\n\n            _.buildRows();\n            _.buildOut();\n            _.setProps();\n            _.startLoad();\n            _.loadSlider();\n            _.initializeEvents();\n            _.updateArrows();\n            _.updateDots();\n            _.checkResponsive(true);\n            _.focusHandler();\n\n        }\n\n        if (creation) {\n            _.$slider.trigger('init', [_]);\n        }\n\n        if (_.options.accessibility === true) {\n            _.initADA();\n        }\n\n        if (_.options.autoplay) {\n\n            _.paused = false;\n            _.autoPlay();\n\n        }\n\n    };\n\n    Slick.prototype.initADA = function () {\n        var _ = this,\n            numDotGroups = Math.ceil(_.slideCount / _.options.slidesToShow),\n            tabControlIndexes = _.getNavigableIndexes().filter(function (val) {\n                return (val >= 0) && (val < _.slideCount);\n            });\n\n        _.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({\n            'aria-hidden': 'true',\n            'tabindex': '-1'\n        }).find('a, input, button, select').attr({\n            'tabindex': '-1'\n        });\n\n        if (_.$dots !== null) {\n            _.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function (i) {\n                var slideControlIndex = tabControlIndexes.indexOf(i);\n\n                $(this).attr({\n                    'role': 'tabpanel',\n                    'id': 'slick-slide' + _.instanceUid + i,\n                    'tabindex': -1\n                });\n\n                if (slideControlIndex !== -1) {\n                    var ariaButtonControl = 'slick-slide-control' + _.instanceUid + slideControlIndex\n                    if ($('#' + ariaButtonControl).length) {\n                        $(this).attr({\n                            'aria-describedby': ariaButtonControl\n                        });\n                    }\n                }\n            });\n\n            _.$dots.attr('role', 'tablist').find('li').each(function (i) {\n                var mappedSlideIndex = tabControlIndexes[i];\n\n                $(this).attr({\n                    'role': 'presentation'\n                });\n\n                $(this).find('button').first().attr({\n                    'role': 'tab',\n                    'id': 'slick-slide-control' + _.instanceUid + i,\n                    'aria-controls': 'slick-slide' + _.instanceUid + mappedSlideIndex,\n                    'aria-label': (i + 1) + ' of ' + numDotGroups,\n                    'aria-selected': null,\n                    'tabindex': '-1'\n                });\n\n            }).eq(_.currentSlide).find('button').attr({\n                'aria-selected': 'true',\n                'tabindex': '0'\n            }).end();\n        }\n\n        for (var i = _.currentSlide, max = i + _.options.slidesToShow; i < max; i++) {\n            if (_.options.focusOnChange) {\n                _.$slides.eq(i).attr({'tabindex': '0'});\n            } else {\n                _.$slides.eq(i).removeAttr('tabindex');\n            }\n        }\n\n        _.activateADA();\n\n    };\n\n    Slick.prototype.initArrowEvents = function () {\n\n        var _ = this;\n\n        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {\n            _.$prevArrow\n                .off('click.slick')\n                .on('click.slick', {\n                    message: 'previous'\n                }, _.changeSlide);\n            _.$nextArrow\n                .off('click.slick')\n                .on('click.slick', {\n                    message: 'next'\n                }, _.changeSlide);\n\n            if (_.options.accessibility === true) {\n                _.$prevArrow.on('keydown.slick', _.keyHandler);\n                _.$nextArrow.on('keydown.slick', _.keyHandler);\n            }\n        }\n\n    };\n\n    Slick.prototype.initDotEvents = function () {\n\n        var _ = this;\n\n        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {\n            $('li', _.$dots).on('click.slick', {\n                message: 'index'\n            }, _.changeSlide);\n\n            if (_.options.accessibility === true) {\n                _.$dots.on('keydown.slick', _.keyHandler);\n            }\n        }\n\n        if (_.options.dots === true && _.options.pauseOnDotsHover === true && _.slideCount > _.options.slidesToShow) {\n\n            $('li', _.$dots)\n                .on('mouseenter.slick', $.proxy(_.interrupt, _, true))\n                .on('mouseleave.slick', $.proxy(_.interrupt, _, false));\n\n        }\n\n    };\n\n    Slick.prototype.initSlideEvents = function () {\n\n        var _ = this;\n\n        if (_.options.pauseOnHover) {\n\n            _.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));\n            _.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));\n\n        }\n\n    };\n\n    Slick.prototype.initializeEvents = function () {\n\n        var _ = this;\n\n        _.initArrowEvents();\n\n        _.initDotEvents();\n        _.initSlideEvents();\n\n        _.$list.on('touchstart.slick mousedown.slick', {\n            action: 'start'\n        }, _.swipeHandler);\n        _.$list.on('touchmove.slick mousemove.slick', {\n            action: 'move'\n        }, _.swipeHandler);\n        _.$list.on('touchend.slick mouseup.slick', {\n            action: 'end'\n        }, _.swipeHandler);\n        _.$list.on('touchcancel.slick mouseleave.slick', {\n            action: 'end'\n        }, _.swipeHandler);\n\n        _.$list.on('click.slick', _.clickHandler);\n\n        $(document).on(_.visibilityChange, $.proxy(_.visibility, _));\n\n        if (_.options.accessibility === true) {\n            _.$list.on('keydown.slick', _.keyHandler);\n        }\n\n        if (_.options.focusOnSelect === true) {\n            $(_.$slideTrack).children().on('click.slick', _.selectHandler);\n        }\n\n        $(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));\n\n        $(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));\n\n        $('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);\n\n        $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);\n        $(_.setPosition);\n\n    };\n\n    Slick.prototype.initUI = function () {\n\n        var _ = this;\n\n        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {\n\n            _.$prevArrow.show();\n            _.$nextArrow.show();\n\n        }\n\n        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {\n\n            _.$dots.show();\n\n        }\n\n    };\n\n    Slick.prototype.keyHandler = function (event) {\n\n        var _ = this;\n        //Dont slide if the cursor is inside the form fields and arrow keys are pressed\n        if (!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {\n            if (event.keyCode === 37 && _.options.accessibility === true) {\n                _.changeSlide({\n                    data: {\n                        message: _.options.rtl === true ? 'next' : 'previous'\n                    }\n                });\n            } else if (event.keyCode === 39 && _.options.accessibility === true) {\n                _.changeSlide({\n                    data: {\n                        message: _.options.rtl === true ? 'previous' : 'next'\n                    }\n                });\n            }\n        }\n\n    };\n\n    Slick.prototype.lazyLoad = function () {\n\n        var _ = this,\n            loadRange, cloneRange, rangeStart, rangeEnd;\n\n        function loadImages(imagesScope) {\n\n            $('img[data-lazy]', imagesScope).each(function () {\n\n                var image = $(this),\n                    imageSource = $(this).attr('data-lazy'),\n                    imageSrcSet = $(this).attr('data-srcset'),\n                    imageSizes = $(this).attr('data-sizes') || _.$slider.attr('data-sizes'),\n                    imageToLoad = document.createElement('img');\n\n                imageToLoad.onload = function () {\n\n                    image\n                        .animate({opacity: 0}, 100, function () {\n\n                            if (imageSrcSet) {\n                                image\n                                    .attr('srcset', imageSrcSet);\n\n                                if (imageSizes) {\n                                    image\n                                        .attr('sizes', imageSizes);\n                                }\n                            }\n\n                            image\n                                .attr('src', imageSource)\n                                .animate({opacity: 1}, 200, function () {\n                                    image\n                                        .removeAttr('data-lazy data-srcset data-sizes')\n                                        .removeClass('slick-loading');\n                                });\n                            _.$slider.trigger('lazyLoaded', [_, image, imageSource]);\n                        });\n\n                };\n\n                imageToLoad.onerror = function () {\n\n                    image\n                        .removeAttr('data-lazy')\n                        .removeClass('slick-loading')\n                        .addClass('slick-lazyload-error');\n\n                    _.$slider.trigger('lazyLoadError', [_, image, imageSource]);\n\n                };\n\n                imageToLoad.src = imageSource;\n\n            });\n\n        }\n\n        if (_.options.centerMode === true) {\n            if (_.options.infinite === true) {\n                rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);\n                rangeEnd = rangeStart + _.options.slidesToShow + 2;\n            } else {\n                rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));\n                rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;\n            }\n        } else {\n            rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;\n            rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);\n            if (_.options.fade === true) {\n                if (rangeStart > 0) rangeStart--;\n                if (rangeEnd <= _.slideCount) rangeEnd++;\n            }\n        }\n\n        loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);\n\n        if (_.options.lazyLoad === 'anticipated') {\n            var prevSlide = rangeStart - 1,\n                nextSlide = rangeEnd,\n                $slides = _.$slider.find('.slick-slide');\n\n            for (var i = 0; i < _.options.slidesToScroll; i++) {\n                if (prevSlide < 0) prevSlide = _.slideCount - 1;\n                loadRange = loadRange.add($slides.eq(prevSlide));\n                loadRange = loadRange.add($slides.eq(nextSlide));\n                prevSlide--;\n                nextSlide++;\n            }\n        }\n\n        loadImages(loadRange);\n\n        if (_.slideCount <= _.options.slidesToShow) {\n            cloneRange = _.$slider.find('.slick-slide');\n            loadImages(cloneRange);\n        } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {\n            cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);\n            loadImages(cloneRange);\n        } else if (_.currentSlide === 0) {\n            cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);\n            loadImages(cloneRange);\n        }\n\n    };\n\n    Slick.prototype.loadSlider = function () {\n\n        var _ = this;\n\n        _.setPosition();\n\n        _.$slideTrack.css({\n            opacity: 1\n        });\n\n        _.$slider.removeClass('slick-loading');\n\n        _.initUI();\n\n        if (_.options.lazyLoad === 'progressive') {\n            _.progressiveLazyLoad();\n        }\n\n    };\n\n    Slick.prototype.next = Slick.prototype.slickNext = function () {\n\n        var _ = this;\n\n        _.changeSlide({\n            data: {\n                message: 'next'\n            }\n        });\n\n    };\n\n    Slick.prototype.orientationChange = function () {\n\n        var _ = this;\n\n        _.checkResponsive();\n        _.setPosition();\n\n    };\n\n    Slick.prototype.pause = Slick.prototype.slickPause = function () {\n\n        var _ = this;\n\n        _.autoPlayClear();\n        _.paused = true;\n\n    };\n\n    Slick.prototype.play = Slick.prototype.slickPlay = function () {\n\n        var _ = this;\n\n        _.autoPlay();\n        _.options.autoplay = true;\n        _.paused = false;\n        _.focussed = false;\n        _.interrupted = false;\n\n    };\n\n    Slick.prototype.postSlide = function (index) {\n\n        var _ = this;\n\n        if (!_.unslicked) {\n\n            _.$slider.trigger('afterChange', [_, index]);\n\n            _.animating = false;\n\n            if (_.slideCount > _.options.slidesToShow) {\n                _.setPosition();\n            }\n\n            _.swipeLeft = null;\n\n            if (_.options.autoplay) {\n                _.autoPlay();\n            }\n\n            if (_.options.accessibility === true) {\n                _.initADA();\n\n                if (_.options.focusOnChange) {\n                    var $currentSlide = $(_.$slides.get(_.currentSlide));\n                    $currentSlide.attr('tabindex', 0).focus();\n                }\n            }\n\n        }\n\n    };\n\n    Slick.prototype.prev = Slick.prototype.slickPrev = function () {\n\n        var _ = this;\n\n        _.changeSlide({\n            data: {\n                message: 'previous'\n            }\n        });\n\n    };\n\n    Slick.prototype.preventDefault = function (event) {\n\n        event.preventDefault();\n\n    };\n\n    Slick.prototype.progressiveLazyLoad = function (tryCount) {\n\n        tryCount = tryCount || 1;\n\n        var _ = this,\n            $imgsToLoad = $('img[data-lazy]', _.$slider),\n            image,\n            imageSource,\n            imageSrcSet,\n            imageSizes,\n            imageToLoad;\n\n        if ($imgsToLoad.length) {\n\n            image = $imgsToLoad.first();\n            imageSource = image.attr('data-lazy');\n            imageSrcSet = image.attr('data-srcset');\n            imageSizes = image.attr('data-sizes') || _.$slider.attr('data-sizes');\n            imageToLoad = document.createElement('img');\n\n            imageToLoad.onload = function () {\n\n                if (imageSrcSet) {\n                    image\n                        .attr('srcset', imageSrcSet);\n\n                    if (imageSizes) {\n                        image\n                            .attr('sizes', imageSizes);\n                    }\n                }\n\n                image\n                    .attr('src', imageSource)\n                    .removeAttr('data-lazy data-srcset data-sizes')\n                    .removeClass('slick-loading');\n\n                if (_.options.adaptiveHeight === true) {\n                    _.setPosition();\n                }\n\n                _.$slider.trigger('lazyLoaded', [_, image, imageSource]);\n                _.progressiveLazyLoad();\n\n            };\n\n            imageToLoad.onerror = function () {\n\n                if (tryCount < 3) {\n\n                    /**\n                     * try to load the image 3 times,\n                     * leave a slight delay so we don't get\n                     * servers blocking the request.\n                     */\n                    setTimeout(function () {\n                        _.progressiveLazyLoad(tryCount + 1);\n                    }, 500);\n\n                } else {\n\n                    image\n                        .removeAttr('data-lazy')\n                        .removeClass('slick-loading')\n                        .addClass('slick-lazyload-error');\n\n                    _.$slider.trigger('lazyLoadError', [_, image, imageSource]);\n\n                    _.progressiveLazyLoad();\n\n                }\n\n            };\n\n            imageToLoad.src = imageSource;\n\n        } else {\n\n            _.$slider.trigger('allImagesLoaded', [_]);\n\n        }\n\n    };\n\n    Slick.prototype.refresh = function (initializing) {\n\n        var _ = this, currentSlide, lastVisibleIndex;\n\n        lastVisibleIndex = _.slideCount - _.options.slidesToShow;\n\n        // in non-infinite sliders, we don't want to go past the\n        // last visible index.\n        if (!_.options.infinite && ( _.currentSlide > lastVisibleIndex )) {\n            _.currentSlide = lastVisibleIndex;\n        }\n\n        // if less slides than to show, go to start.\n        if (_.slideCount <= _.options.slidesToShow) {\n            _.currentSlide = 0;\n\n        }\n\n        currentSlide = _.currentSlide;\n\n        _.destroy(true);\n\n        $.extend(_, _.initials, {currentSlide: currentSlide});\n\n        _.init();\n\n        if (!initializing) {\n\n            _.changeSlide({\n                data: {\n                    message: 'index',\n                    index: currentSlide\n                }\n            }, false);\n\n        }\n\n    };\n\n    Slick.prototype.registerBreakpoints = function () {\n\n        var _ = this, breakpoint, currentBreakpoint, l,\n            responsiveSettings = _.options.responsive || null;\n\n        if ($.type(responsiveSettings) === 'array' && responsiveSettings.length) {\n\n            _.respondTo = _.options.respondTo || 'window';\n\n            for (breakpoint in responsiveSettings) {\n\n                l = _.breakpoints.length - 1;\n\n                if (responsiveSettings.hasOwnProperty(breakpoint)) {\n                    currentBreakpoint = responsiveSettings[breakpoint].breakpoint;\n\n                    // loop through the breakpoints and cut out any existing\n                    // ones with the same breakpoint number, we don't want dupes.\n                    while (l >= 0) {\n                        if (_.breakpoints[l] && _.breakpoints[l] === currentBreakpoint) {\n                            _.breakpoints.splice(l, 1);\n                        }\n                        l--;\n                    }\n\n                    _.breakpoints.push(currentBreakpoint);\n                    _.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;\n\n                }\n\n            }\n\n            _.breakpoints.sort(function (a, b) {\n                return ( _.options.mobileFirst ) ? a - b : b - a;\n            });\n\n        }\n\n    };\n\n    Slick.prototype.reinit = function () {\n\n        var _ = this;\n\n        _.$slides =\n            _.$slideTrack\n                .children(_.options.slide)\n                .addClass('slick-slide');\n\n        _.slideCount = _.$slides.length;\n\n        if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {\n            _.currentSlide = _.currentSlide - _.options.slidesToScroll;\n        }\n\n        if (_.slideCount <= _.options.slidesToShow) {\n            _.currentSlide = 0;\n        }\n\n        _.registerBreakpoints();\n\n        _.setProps();\n        _.setupInfinite();\n        _.buildArrows();\n        _.updateArrows();\n        _.initArrowEvents();\n        _.buildDots();\n        _.updateDots();\n        _.initDotEvents();\n        _.cleanUpSlideEvents();\n        _.initSlideEvents();\n\n        _.checkResponsive(false, true);\n\n        if (_.options.focusOnSelect === true) {\n            $(_.$slideTrack).children().on('click.slick', _.selectHandler);\n        }\n\n        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);\n\n        _.setPosition();\n        _.focusHandler();\n\n        _.paused = !_.options.autoplay;\n        _.autoPlay();\n\n        _.$slider.trigger('reInit', [_]);\n\n    };\n\n    Slick.prototype.resize = function () {\n\n        var _ = this;\n\n        if ($(window).width() !== _.windowWidth) {\n            clearTimeout(_.windowDelay);\n            _.windowDelay = window.setTimeout(function () {\n                _.windowWidth = $(window).width();\n                _.checkResponsive();\n                if (!_.unslicked) {\n                    _.setPosition();\n                }\n            }, 50);\n        }\n    };\n\n    Slick.prototype.removeSlide = Slick.prototype.slickRemove = function (index, removeBefore, removeAll) {\n\n        var _ = this;\n\n        if (typeof(index) === 'boolean') {\n            removeBefore = index;\n            index = removeBefore === true ? 0 : _.slideCount - 1;\n        } else {\n            index = removeBefore === true ? --index : index;\n        }\n\n        if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {\n            return false;\n        }\n\n        _.unload();\n\n        if (removeAll === true) {\n            _.$slideTrack.children().remove();\n        } else {\n            _.$slideTrack.children(this.options.slide).eq(index).remove();\n        }\n\n        _.$slides = _.$slideTrack.children(this.options.slide);\n\n        _.$slideTrack.children(this.options.slide).detach();\n\n        _.$slideTrack.append(_.$slides);\n\n        _.$slidesCache = _.$slides;\n\n        _.reinit();\n\n    };\n\n    Slick.prototype.setCSS = function (position) {\n\n        var _ = this,\n            positionProps = {},\n            x, y;\n\n        if (_.options.rtl === true) {\n            position = -position;\n        }\n        x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';\n        y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';\n\n        positionProps[_.positionProp] = position;\n\n        if (_.transformsEnabled === false) {\n            _.$slideTrack.css(positionProps);\n        } else {\n            positionProps = {};\n            if (_.cssTransitions === false) {\n                positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';\n                _.$slideTrack.css(positionProps);\n            } else {\n                positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';\n                _.$slideTrack.css(positionProps);\n            }\n        }\n\n    };\n\n    Slick.prototype.setDimensions = function () {\n\n        var _ = this;\n\n        if (_.options.vertical === false) {\n            if (_.options.centerMode === true) {\n                _.$list.css({\n                    padding: ('0px ' + _.options.centerPadding)\n                });\n            }\n        } else {\n            _.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);\n            if (_.options.centerMode === true) {\n                _.$list.css({\n                    padding: (_.options.centerPadding + ' 0px')\n                });\n            }\n        }\n\n        _.listWidth = _.$list.width();\n        _.listHeight = _.$list.height();\n\n\n        if (_.options.vertical === false && _.options.variableWidth === false) {\n            _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);\n            _.$slideTrack.width(Math.ceil((_.slideWidth * _.$slideTrack.children('.slick-slide').length)));\n\n        } else if (_.options.variableWidth === true) {\n            _.$slideTrack.width(5000 * _.slideCount);\n        } else {\n            _.slideWidth = Math.ceil(_.listWidth);\n            _.$slideTrack.height(Math.ceil((_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length)));\n        }\n\n        var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();\n        if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);\n\n    };\n\n    Slick.prototype.setFade = function () {\n\n        var _ = this,\n            targetLeft;\n\n        _.$slides.each(function (index, element) {\n            targetLeft = (_.slideWidth * index) * -1;\n            if (_.options.rtl === true) {\n                $(element).css({\n                    position: 'relative',\n                    right: targetLeft,\n                    top: 0,\n                    zIndex: _.options.zIndex - 2,\n                    opacity: 0\n                });\n            } else {\n                $(element).css({\n                    position: 'relative',\n                    left: targetLeft,\n                    top: 0,\n                    zIndex: _.options.zIndex - 2,\n                    opacity: 0\n                });\n            }\n        });\n\n        _.$slides.eq(_.currentSlide).css({\n            zIndex: _.options.zIndex - 1,\n            opacity: 1\n        });\n\n    };\n\n    Slick.prototype.setHeight = function () {\n\n        var _ = this;\n\n        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {\n            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);\n            _.$list.css('height', targetHeight);\n        }\n\n    };\n\n    Slick.prototype.setOption =\n        Slick.prototype.slickSetOption = function () {\n\n            /**\n             * accepts arguments in format of:\n             *\n             *  - for changing a single option's value:\n             *     .slick(\"setOption\", option, value, refresh )\n             *\n             *  - for changing a set of responsive options:\n             *     .slick(\"setOption\", 'responsive', [{}, ...], refresh )\n             *\n             *  - for updating multiple values at once (not responsive)\n             *     .slick(\"setOption\", { 'option': value, ... }, refresh )\n             */\n\n            var _ = this, l, item, option, value, refresh = false, type;\n\n            if ($.type(arguments[0]) === 'object') {\n\n                option = arguments[0];\n                refresh = arguments[1];\n                type = 'multiple';\n\n            } else if ($.type(arguments[0]) === 'string') {\n\n                option = arguments[0];\n                value = arguments[1];\n                refresh = arguments[2];\n\n                if (arguments[0] === 'responsive' && $.type(arguments[1]) === 'array') {\n\n                    type = 'responsive';\n\n                } else if (typeof arguments[1] !== 'undefined') {\n\n                    type = 'single';\n\n                }\n\n            }\n\n            if (type === 'single') {\n\n                _.options[option] = value;\n\n\n            } else if (type === 'multiple') {\n\n                $.each(option, function (opt, val) {\n\n                    _.options[opt] = val;\n\n                });\n\n\n            } else if (type === 'responsive') {\n\n                for (item in value) {\n\n                    if ($.type(_.options.responsive) !== 'array') {\n\n                        _.options.responsive = [value[item]];\n\n                    } else {\n\n                        l = _.options.responsive.length - 1;\n\n                        // loop through the responsive object and splice out duplicates.\n                        while (l >= 0) {\n\n                            if (_.options.responsive[l].breakpoint === value[item].breakpoint) {\n\n                                _.options.responsive.splice(l, 1);\n\n                            }\n\n                            l--;\n\n                        }\n\n                        _.options.responsive.push(value[item]);\n\n                    }\n\n                }\n\n            }\n\n            if (refresh) {\n\n                _.unload();\n                _.reinit();\n\n            }\n\n        };\n\n    Slick.prototype.setPosition = function () {\n\n        var _ = this;\n\n        _.setDimensions();\n\n        _.setHeight();\n\n        if (_.options.fade === false) {\n            _.setCSS(_.getLeft(_.currentSlide));\n        } else {\n            _.setFade();\n        }\n\n        _.$slider.trigger('setPosition', [_]);\n\n    };\n\n    Slick.prototype.setProps = function () {\n\n        var _ = this,\n            bodyStyle = document.body.style;\n\n        _.positionProp = _.options.vertical === true ? 'top' : 'left';\n\n        if (_.positionProp === 'top') {\n            _.$slider.addClass('slick-vertical');\n        } else {\n            _.$slider.removeClass('slick-vertical');\n        }\n\n        if (bodyStyle.WebkitTransition !== undefined ||\n            bodyStyle.MozTransition !== undefined ||\n            bodyStyle.msTransition !== undefined) {\n            if (_.options.useCSS === true) {\n                _.cssTransitions = true;\n            }\n        }\n\n        if (_.options.fade) {\n            if (typeof _.options.zIndex === 'number') {\n                if (_.options.zIndex < 3) {\n                    _.options.zIndex = 3;\n                }\n            } else {\n                _.options.zIndex = _.defaults.zIndex;\n            }\n        }\n\n        if (bodyStyle.OTransform !== undefined) {\n            _.animType = 'OTransform';\n            _.transformType = '-o-transform';\n            _.transitionType = 'OTransition';\n            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;\n        }\n        if (bodyStyle.MozTransform !== undefined) {\n            _.animType = 'MozTransform';\n            _.transformType = '-moz-transform';\n            _.transitionType = 'MozTransition';\n            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;\n        }\n        if (bodyStyle.webkitTransform !== undefined) {\n            _.animType = 'webkitTransform';\n            _.transformType = '-webkit-transform';\n            _.transitionType = 'webkitTransition';\n            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;\n        }\n        if (bodyStyle.msTransform !== undefined) {\n            _.animType = 'msTransform';\n            _.transformType = '-ms-transform';\n            _.transitionType = 'msTransition';\n            if (bodyStyle.msTransform === undefined) _.animType = false;\n        }\n        if (bodyStyle.transform !== undefined && _.animType !== false) {\n            _.animType = 'transform';\n            _.transformType = 'transform';\n            _.transitionType = 'transition';\n        }\n        _.transformsEnabled = _.options.useTransform && (_.animType !== null && _.animType !== false);\n    };\n\n\n    Slick.prototype.setSlideClasses = function (index) {\n\n        var _ = this,\n            centerOffset, allSlides, indexOffset, remainder;\n\n        allSlides = _.$slider\n            .find('.slick-slide')\n            .removeClass('slick-active slick-center slick-current')\n            .attr('aria-hidden', 'true');\n\n        _.$slides\n            .eq(index)\n            .addClass('slick-current');\n\n        if (_.options.centerMode === true) {\n\n            var evenCoef = _.options.slidesToShow % 2 === 0 ? 1 : 0;\n\n            centerOffset = Math.floor(_.options.slidesToShow / 2);\n\n            if (_.options.infinite === true) {\n\n                if (index >= centerOffset && index <= (_.slideCount - 1) - centerOffset) {\n                    _.$slides\n                        .slice(index - centerOffset + evenCoef, index + centerOffset + 1)\n                        .addClass('slick-active')\n                        .attr('aria-hidden', 'false');\n\n                } else {\n\n                    indexOffset = _.options.slidesToShow + index;\n                    allSlides\n                        .slice(indexOffset - centerOffset + 1 + evenCoef, indexOffset + centerOffset + 2)\n                        .addClass('slick-active')\n                        .attr('aria-hidden', 'false');\n\n                }\n\n                if (index === 0) {\n\n                    allSlides\n                        .eq(allSlides.length - 1 - _.options.slidesToShow)\n                        .addClass('slick-center');\n\n                } else if (index === _.slideCount - 1) {\n\n                    allSlides\n                        .eq(_.options.slidesToShow)\n                        .addClass('slick-center');\n\n                }\n\n            }\n\n            _.$slides\n                .eq(index)\n                .addClass('slick-center');\n\n        } else {\n\n            if (index >= 0 && index <= (_.slideCount - _.options.slidesToShow)) {\n\n                _.$slides\n                    .slice(index, index + _.options.slidesToShow)\n                    .addClass('slick-active')\n                    .attr('aria-hidden', 'false');\n\n            } else if (allSlides.length <= _.options.slidesToShow) {\n\n                allSlides\n                    .addClass('slick-active')\n                    .attr('aria-hidden', 'false');\n\n            } else {\n\n                remainder = _.slideCount % _.options.slidesToShow;\n                indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;\n\n                if (_.options.slidesToShow == _.options.slidesToScroll && (_.slideCount - index) < _.options.slidesToShow) {\n\n                    allSlides\n                        .slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder)\n                        .addClass('slick-active')\n                        .attr('aria-hidden', 'false');\n\n                } else {\n\n                    allSlides\n                        .slice(indexOffset, indexOffset + _.options.slidesToShow)\n                        .addClass('slick-active')\n                        .attr('aria-hidden', 'false');\n\n                }\n\n            }\n\n        }\n\n        if (_.options.lazyLoad === 'ondemand' || _.options.lazyLoad === 'anticipated') {\n            _.lazyLoad();\n        }\n    };\n\n    Slick.prototype.setupInfinite = function () {\n\n        var _ = this,\n            i, slideIndex, infiniteCount;\n\n        if (_.options.fade === true) {\n            _.options.centerMode = false;\n        }\n\n        if (_.options.infinite === true && _.options.fade === false) {\n\n            slideIndex = null;\n\n            if (_.slideCount > _.options.slidesToShow) {\n\n                if (_.options.centerMode === true) {\n                    infiniteCount = _.options.slidesToShow + 1;\n                } else {\n                    infiniteCount = _.options.slidesToShow;\n                }\n\n                for (i = _.slideCount; i > (_.slideCount -\n                    infiniteCount); i -= 1) {\n                    slideIndex = i - 1;\n                    $(_.$slides[slideIndex]).clone(true).attr('id', '')\n                        .attr('data-slick-index', slideIndex - _.slideCount)\n                        .prependTo(_.$slideTrack).addClass('slick-cloned');\n                }\n                for (i = 0; i < infiniteCount + _.slideCount; i += 1) {\n                    slideIndex = i;\n                    $(_.$slides[slideIndex]).clone(true).attr('id', '')\n                        .attr('data-slick-index', slideIndex + _.slideCount)\n                        .appendTo(_.$slideTrack).addClass('slick-cloned');\n                }\n                _.$slideTrack.find('.slick-cloned').find('[id]').each(function () {\n                    $(this).attr('id', '');\n                });\n\n            }\n\n        }\n\n    };\n\n    Slick.prototype.interrupt = function (toggle) {\n\n        var _ = this;\n\n        if (!toggle) {\n            _.autoPlay();\n        }\n        _.interrupted = toggle;\n\n    };\n\n    Slick.prototype.selectHandler = function (event) {\n\n        var _ = this;\n\n        var targetElement =\n            $(event.target).is('.slick-slide') ?\n                $(event.target) :\n                $(event.target).parents('.slick-slide');\n\n        var index = parseInt(targetElement.attr('data-slick-index'));\n\n        if (!index) index = 0;\n\n        if (_.slideCount <= _.options.slidesToShow) {\n\n            _.slideHandler(index, false, true);\n            return;\n\n        }\n\n        _.slideHandler(index);\n\n    };\n\n    Slick.prototype.slideHandler = function (index, sync, dontAnimate) {\n\n        var targetSlide, animSlide, oldSlide, slideLeft, targetLeft = null,\n            _ = this, navTarget;\n\n        sync = sync || false;\n\n        if (_.animating === true && _.options.waitForAnimate === true) {\n            return;\n        }\n\n        if (_.options.fade === true && _.currentSlide === index) {\n            return;\n        }\n\n        if (sync === false) {\n            _.asNavFor(index);\n        }\n\n        targetSlide = index;\n        targetLeft = _.getLeft(targetSlide);\n        slideLeft = _.getLeft(_.currentSlide);\n\n        _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;\n\n        if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {\n            if (_.options.fade === false) {\n                targetSlide = _.currentSlide;\n                if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {\n                    _.animateSlide(slideLeft, function () {\n                        _.postSlide(targetSlide);\n                    });\n                } else {\n                    _.postSlide(targetSlide);\n                }\n            }\n            return;\n        } else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > (_.slideCount - _.options.slidesToScroll))) {\n            if (_.options.fade === false) {\n                targetSlide = _.currentSlide;\n                if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {\n                    _.animateSlide(slideLeft, function () {\n                        _.postSlide(targetSlide);\n                    });\n                } else {\n                    _.postSlide(targetSlide);\n                }\n            }\n            return;\n        }\n\n        if (_.options.autoplay) {\n            clearInterval(_.autoPlayTimer);\n        }\n\n        if (targetSlide < 0) {\n            if (_.slideCount % _.options.slidesToScroll !== 0) {\n                animSlide = _.slideCount - (_.slideCount % _.options.slidesToScroll);\n            } else {\n                animSlide = _.slideCount + targetSlide;\n            }\n        } else if (targetSlide >= _.slideCount) {\n            if (_.slideCount % _.options.slidesToScroll !== 0) {\n                animSlide = 0;\n            } else {\n                animSlide = targetSlide - _.slideCount;\n            }\n        } else {\n            animSlide = targetSlide;\n        }\n\n        _.animating = true;\n\n        _.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);\n\n        oldSlide = _.currentSlide;\n        _.currentSlide = animSlide;\n\n        _.setSlideClasses(_.currentSlide);\n\n        if (_.options.asNavFor) {\n\n            navTarget = _.getNavTarget();\n            navTarget = navTarget.slick('getSlick');\n\n            if (navTarget.slideCount <= navTarget.options.slidesToShow) {\n                navTarget.setSlideClasses(_.currentSlide);\n            }\n\n        }\n\n        _.updateDots();\n        _.updateArrows();\n\n        if (_.options.fade === true) {\n            if (dontAnimate !== true) {\n\n                _.fadeSlideOut(oldSlide);\n\n                _.fadeSlide(animSlide, function () {\n                    _.postSlide(animSlide);\n                });\n\n            } else {\n                _.postSlide(animSlide);\n            }\n            _.animateHeight();\n            return;\n        }\n\n        if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {\n            _.animateSlide(targetLeft, function () {\n                _.postSlide(animSlide);\n            });\n        } else {\n            _.postSlide(animSlide);\n        }\n\n    };\n\n    Slick.prototype.startLoad = function () {\n\n        var _ = this;\n\n        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {\n\n            _.$prevArrow.hide();\n            _.$nextArrow.hide();\n\n        }\n\n        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {\n\n            _.$dots.hide();\n\n        }\n\n        _.$slider.addClass('slick-loading');\n\n    };\n\n    Slick.prototype.swipeDirection = function () {\n\n        var xDist, yDist, r, swipeAngle, _ = this;\n\n        xDist = _.touchObject.startX - _.touchObject.curX;\n        yDist = _.touchObject.startY - _.touchObject.curY;\n        r = Math.atan2(yDist, xDist);\n\n        swipeAngle = Math.round(r * 180 / Math.PI);\n        if (swipeAngle < 0) {\n            swipeAngle = 360 - Math.abs(swipeAngle);\n        }\n\n        if ((swipeAngle <= 45) && (swipeAngle >= 0)) {\n            return (_.options.rtl === false ? 'left' : 'right');\n        }\n        if ((swipeAngle <= 360) && (swipeAngle >= 315)) {\n            return (_.options.rtl === false ? 'left' : 'right');\n        }\n        if ((swipeAngle >= 135) && (swipeAngle <= 225)) {\n            return (_.options.rtl === false ? 'right' : 'left');\n        }\n        if (_.options.verticalSwiping === true) {\n            if ((swipeAngle >= 35) && (swipeAngle <= 135)) {\n                return 'down';\n            } else {\n                return 'up';\n            }\n        }\n\n        return 'vertical';\n\n    };\n\n    Slick.prototype.swipeEnd = function (event) {\n\n        var _ = this,\n            slideCount,\n            direction;\n\n        _.dragging = false;\n        _.swiping = false;\n\n        if (_.scrolling) {\n            _.scrolling = false;\n            return false;\n        }\n\n        _.interrupted = false;\n        _.shouldClick = ( _.touchObject.swipeLength > 10 ) ? false : true;\n\n        if (_.touchObject.curX === undefined) {\n            return false;\n        }\n\n        if (_.touchObject.edgeHit === true) {\n            _.$slider.trigger('edge', [_, _.swipeDirection()]);\n        }\n\n        if (_.touchObject.swipeLength >= _.touchObject.minSwipe) {\n\n            direction = _.swipeDirection();\n\n            switch (direction) {\n\n                case 'left':\n                case 'down':\n\n                    slideCount =\n                        _.options.swipeToSlide ?\n                            _.checkNavigable(_.currentSlide + _.getSlideCount()) :\n                            _.currentSlide + _.getSlideCount();\n\n                    _.currentDirection = 0;\n\n                    break;\n\n                case 'right':\n                case 'up':\n\n                    slideCount =\n                        _.options.swipeToSlide ?\n                            _.checkNavigable(_.currentSlide - _.getSlideCount()) :\n                            _.currentSlide - _.getSlideCount();\n\n                    _.currentDirection = 1;\n\n                    break;\n\n                default:\n\n\n            }\n\n            if (direction != 'vertical') {\n\n                _.slideHandler(slideCount);\n                _.touchObject = {};\n                _.$slider.trigger('swipe', [_, direction]);\n\n            }\n\n        } else {\n\n            if (_.touchObject.startX !== _.touchObject.curX) {\n\n                _.slideHandler(_.currentSlide);\n                _.touchObject = {};\n\n            }\n\n        }\n\n    };\n\n    Slick.prototype.swipeHandler = function (event) {\n\n        var _ = this;\n\n        if ((_.options.swipe === false) || ('ontouchend' in document && _.options.swipe === false)) {\n            return;\n        } else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {\n            return;\n        }\n\n        _.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ?\n            event.originalEvent.touches.length : 1;\n\n        _.touchObject.minSwipe = _.listWidth / _.options\n            .touchThreshold;\n\n        if (_.options.verticalSwiping === true) {\n            _.touchObject.minSwipe = _.listHeight / _.options\n                .touchThreshold;\n        }\n\n        switch (event.data.action) {\n\n            case 'start':\n                _.swipeStart(event);\n                break;\n\n            case 'move':\n                _.swipeMove(event);\n                break;\n\n            case 'end':\n                _.swipeEnd(event);\n                break;\n\n        }\n\n    };\n\n    Slick.prototype.swipeMove = function (event) {\n\n        var _ = this,\n            edgeWasHit = false,\n            curLeft, swipeDirection, swipeLength, positionOffset, touches, verticalSwipeLength;\n\n        touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;\n\n        if (!_.dragging || _.scrolling || touches && touches.length !== 1) {\n            return false;\n        }\n\n        curLeft = _.getLeft(_.currentSlide);\n\n        _.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;\n        _.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;\n\n        _.touchObject.swipeLength = Math.round(Math.sqrt(\n            Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));\n\n        verticalSwipeLength = Math.round(Math.sqrt(\n            Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));\n\n        if (!_.options.verticalSwiping && !_.swiping && verticalSwipeLength > 4) {\n            _.scrolling = true;\n            return false;\n        }\n\n        if (_.options.verticalSwiping === true) {\n            _.touchObject.swipeLength = verticalSwipeLength;\n        }\n\n        swipeDirection = _.swipeDirection();\n\n        if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {\n            _.swiping = true;\n            event.preventDefault();\n        }\n\n        positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);\n        if (_.options.verticalSwiping === true) {\n            positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;\n        }\n\n\n        swipeLength = _.touchObject.swipeLength;\n\n        _.touchObject.edgeHit = false;\n\n        if (_.options.infinite === false) {\n            if ((_.currentSlide === 0 && swipeDirection === 'right') || (_.currentSlide >= _.getDotCount() && swipeDirection === 'left')) {\n                swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;\n                _.touchObject.edgeHit = true;\n            }\n        }\n\n        if (_.options.vertical === false) {\n            _.swipeLeft = curLeft + swipeLength * positionOffset;\n        } else {\n            _.swipeLeft = curLeft + (swipeLength * (_.$list.height() / _.listWidth)) * positionOffset;\n        }\n        if (_.options.verticalSwiping === true) {\n            _.swipeLeft = curLeft + swipeLength * positionOffset;\n        }\n\n        if (_.options.fade === true || _.options.touchMove === false) {\n            return false;\n        }\n\n        if (_.animating === true) {\n            _.swipeLeft = null;\n            return false;\n        }\n\n        _.setCSS(_.swipeLeft);\n\n    };\n\n    Slick.prototype.swipeStart = function (event) {\n\n        var _ = this,\n            touches;\n\n        _.interrupted = true;\n\n        if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {\n            _.touchObject = {};\n            return false;\n        }\n\n        if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {\n            touches = event.originalEvent.touches[0];\n        }\n\n        _.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;\n        _.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;\n\n        _.dragging = true;\n\n    };\n\n    Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function () {\n\n        var _ = this;\n\n        if (_.$slidesCache !== null) {\n\n            _.unload();\n\n            _.$slideTrack.children(this.options.slide).detach();\n\n            _.$slidesCache.appendTo(_.$slideTrack);\n\n            _.reinit();\n\n        }\n\n    };\n\n    Slick.prototype.unload = function () {\n\n        var _ = this;\n\n        $('.slick-cloned', _.$slider).remove();\n\n        if (_.$dots) {\n            _.$dots.remove();\n        }\n\n        if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {\n            _.$prevArrow.remove();\n        }\n\n        if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {\n            _.$nextArrow.remove();\n        }\n\n        _.$slides\n            .removeClass('slick-slide slick-active slick-visible slick-current')\n            .attr('aria-hidden', 'true')\n            .css('width', '');\n\n    };\n\n    Slick.prototype.unslick = function (fromBreakpoint) {\n\n        var _ = this;\n        _.$slider.trigger('unslick', [_, fromBreakpoint]);\n        _.destroy();\n\n    };\n\n    Slick.prototype.updateArrows = function () {\n\n        var _ = this,\n            centerOffset;\n\n        centerOffset = Math.floor(_.options.slidesToShow / 2);\n\n        if (_.options.arrows === true &&\n            _.slideCount > _.options.slidesToShow && !_.options.infinite) {\n\n            _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\n            _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\n\n            if (_.currentSlide === 0) {\n\n                _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');\n                _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\n\n            } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {\n\n                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');\n                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\n\n            } else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {\n\n                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');\n                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\n\n            }\n\n        }\n\n    };\n\n    Slick.prototype.updateDots = function () {\n\n        var _ = this;\n\n        if (_.$dots !== null) {\n\n            _.$dots\n                .find('li')\n                .removeClass('slick-active')\n                .end();\n\n            _.$dots\n                .find('li')\n                .eq(Math.floor(_.currentSlide / _.options.slidesToScroll))\n                .addClass('slick-active');\n\n        }\n\n    };\n\n    Slick.prototype.visibility = function () {\n\n        var _ = this;\n\n        if (_.options.autoplay) {\n\n            if (document[_.hidden]) {\n\n                _.interrupted = true;\n\n            } else {\n\n                _.interrupted = false;\n\n            }\n\n        }\n\n    };\n\n    $.fn.slick = function () {\n        var _ = this,\n            opt = arguments[0],\n            args = Array.prototype.slice.call(arguments, 1),\n            l = _.length,\n            i,\n            ret;\n        for (i = 0; i < l; i++) {\n            if (typeof opt == 'object' || typeof opt == 'undefined')\n                _[i].slick = new Slick(_[i], opt);\n            else\n                ret = _[i].slick[opt].apply(_[i].slick, args);\n            if (typeof ret != 'undefined') return ret;\n        }\n        return _;\n    };\n\n}));\n","js/swatch-renderer-mixin.js":"define([\r\n    'jquery'\r\n], function ($) {\r\n    'use strict';\r\n\r\n    return function (widget) {\r\n        $.widget('mage.SwatchRenderer', widget, {\r\n            _create: function () {\r\n                var options = this.options,\r\n                    gallery = $('[data-gallery-role=gallery-placeholder]', '.column.main'),\r\n                    productData = this._determineProductData(),\r\n                    $main = productData.isInProductView ?\r\n                        this.element.parents('.column.main') :\r\n                        this.element.parents('.product-item-info');\r\n                if (productData.isInProductView) {\r\n                    gallery.data('gallery') ?\r\n                        this._onGalleryLoaded(gallery) :\r\n                        gallery.on('gallery:loaded', this._onGalleryLoaded.bind(this, gallery));\r\n                } else {\r\n                    var _data_src = $main.find('.product-image-photo').attr('data-src'),\r\n                        _src = $main.find('.product-image-photo').attr('src');\r\n                    _data_src = typeof _data_src !== 'undefined' ? _data_src : _src;\r\n                    options.mediaGalleryInitial = [{\r\n                        'img': _data_src\r\n                    }];\r\n                }\r\n                this.productForm = this.element.parents(this.options.selectorProductTile).find('form:first');\r\n                this.inProductList = this.productForm.length > 0;\r\n            },\r\n            _Rebuild: function () {\r\n                return this._super();\r\n            }\r\n        });\r\n        return $.mage.SwatchRenderer;\r\n    }\r\n});","js/theme-js.js":"define([\r\n        \"jquery\",\r\n        \"unveil\",\r\n        \"owlcarousel\",\r\n        \"timecircles\",\r\n        \"kinetic\",\r\n        \"domReady!\"\r\n    ],\r\n    function ($) {\r\n        \"use strict\";\r\n\r\n        /**\r\n         * Theme custom javascript\r\n         */\r\n\r\n        // Fix hover on IOS\r\n        $('body').bind('touchstart', function () {\r\n        });\r\n\r\n        /**\r\n         * Add parent class to megamenu item\r\n         */\r\n\r\n        $('.sm_megamenu_menu > li > div').parent().addClass('parent-item');\r\n\r\n        /**\r\n         * Menu ontop\r\n         */\r\n\r\n        if ($('.enable-stickymenu').length) {\r\n            var wd = $(window);\r\n            if ($('.ontop-element').length) {\r\n                var menu_offset_top = $('.ontop-element').offset().top;\r\n\r\n                function processScroll() {\r\n                    var scrollTop = wd.scrollTop();\r\n                    if (scrollTop >= menu_offset_top) {\r\n                        $('.ontop-element').addClass('menu-on-top');\r\n                        $('body').addClass('body-on-top');\r\n                    } else if (scrollTop <= menu_offset_top) {\r\n                        $('.ontop-element').removeClass('menu-on-top');\r\n                        $('body').removeClass('body-on-top');\r\n                    }\r\n                }\r\n\r\n                processScroll();\r\n                wd.scroll(function () {\r\n                    processScroll();\r\n                });\r\n            }\r\n        }\r\n        // Countdown home page\r\n         $(\"#DateCountdown\").TimeCircles();\r\n        /**\r\n         * Menu sidebar mobile\r\n         */\r\n         $(\".icon-search\").click(function(){\r\n           $('.block-search').toggleClass('show-content');\r\n        })\r\n        $('.mobile-menu #btn-nav-mobile, .nav-overlay').click(function () {\r\n            $('body').toggleClass('show-sidebar-nav');\r\n        });\r\n\r\n        $('div[data-move=\"customer-mobile\"]  .header.links').clone().appendTo('#customer-mobile');\r\n\r\n        var menuType = $('#sm-header-mobile').data('menutype');\r\n\r\n        if (menuType == 'megamenu') {\r\n            $('.btn-submobile').click(function () {\r\n                $(this).prev().slideToggle(200);\r\n                $(this).toggleClass('btnsub-active');\r\n                $(this).parent().toggleClass('parent-active');\r\n                $(\".sm-megamenu-child img\").trigger(\"unveil\");\r\n            });\r\n\r\n            function cloneMegaMenu() {\r\n                var breakpoints = $('#sm-header-mobile').data('breakpoint');\r\n                var doc_width = $(window).width();\r\n                if (doc_width <= breakpoints) {\r\n                    var horizontalMegamenu = $('.sm_megamenu_wrapper_horizontal_menu .horizontal-type');\r\n                    var verticalMegamenu = $('.sm_megamenu_wrapper_vertical_menu .vertical-type');\r\n                    $('#navigation-mobile').append(horizontalMegamenu);\r\n                    $('#navigation-mobile').append(verticalMegamenu);\r\n                } else {\r\n                    var horizontalMegamenu = $('#navigation-mobile .horizontal-type');\r\n                    var verticalMegamenu = $('#navigation-mobile .vertical-type');\r\n                    $('.sm_megamenu_wrapper_horizontal_menu .sambar-inner .mega-content').append(horizontalMegamenu);\r\n                    $('.sm_megamenu_wrapper_vertical_menu .sambar-inner .mega-content').append(verticalMegamenu);\r\n                }\r\n            }\r\n\r\n            cloneMegaMenu();\r\n\r\n            $(window).resize(function () {\r\n                cloneMegaMenu();\r\n            });\r\n        } else {\r\n            $('.navigation-mobile > ul li').has('ul').append('<span class=\"touch-button\"><span>open</span></span>');\r\n\r\n            $('.touch-button').click(function () {\r\n                $(this).prev().slideToggle(200);\r\n                $(this).toggleClass('active');\r\n                $(this).parent().toggleClass('parent-active');\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Clone minicart mobile\r\n         */\r\n\r\n        function cloneCart() {\r\n            var breakpoints = $('#sm-header-mobile').data('breakpoint');\r\n            var doc_width = $(window).width();\r\n            if (doc_width <= breakpoints) {\r\n                var cartDesktop = $('div[data-move=\"minicart-mobile\"] > .minicart-wrapper');\r\n                $('#minicart-mobile').append(cartDesktop);\r\n            } else {\r\n                var cartMobile = $('#minicart-mobile > .minicart-wrapper');\r\n                $('div[data-move=\"minicart-mobile\"]').append(cartMobile);\r\n            }\r\n        }\r\n\r\n        cloneCart();\r\n\r\n        $(window).resize(function () {\r\n            cloneCart();\r\n        });\r\n        /**\r\n         * Hover item menu init lazyload image\r\n         */\r\n\r\n        $(\".sm_megamenu_menu > li\").hover(function () {\r\n            $(document).trigger(\"afterAjaxLazyLoad\");\r\n        });\r\n    });","js/TimeCircles.js":"/**\r\n * Basic structure: TC_Class is the public class that is returned upon being called\r\n * \r\n * So, if you do\r\n *      var tc = $(\".timer\").TimeCircles();\r\n *      \r\n * tc will contain an instance of the public TimeCircles class. It is important to\r\n * note that TimeCircles is not chained in the conventional way, check the\r\n * documentation for more info on how TimeCircles can be chained.\r\n * \r\n * After being called/created, the public TimerCircles class will then- for each element\r\n * within it's collection, either fetch or create an instance of the private class.\r\n * Each function called upon the public class will be forwarded to each instance\r\n * of the private classes within the relevant element collection\r\n **/\r\n define( [ \"jquery\" ], function ( $ ) {  \r\n(function($) {\r\n\r\n    var useWindow = window;\r\n    \r\n    // From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\r\n    if (!Object.keys) {\r\n        Object.keys = (function() {\r\n            'use strict';\r\n            var hasOwnProperty = Object.prototype.hasOwnProperty,\r\n                    hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),\r\n                    dontEnums = [\r\n                        'toString',\r\n                        'toLocaleString',\r\n                        'valueOf',\r\n                        'hasOwnProperty',\r\n                        'isPrototypeOf',\r\n                        'propertyIsEnumerable',\r\n                        'constructor'\r\n                    ],\r\n                    dontEnumsLength = dontEnums.length;\r\n\r\n            return function(obj) {\r\n                if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {\r\n                    throw new TypeError('Object.keys called on non-object');\r\n                }\r\n\r\n                var result = [], prop, i;\r\n\r\n                for (prop in obj) {\r\n                    if (hasOwnProperty.call(obj, prop)) {\r\n                        result.push(prop);\r\n                    }\r\n                }\r\n\r\n                if (hasDontEnumBug) {\r\n                    for (i = 0; i < dontEnumsLength; i++) {\r\n                        if (hasOwnProperty.call(obj, dontEnums[i])) {\r\n                            result.push(dontEnums[i]);\r\n                        }\r\n                    }\r\n                }\r\n                return result;\r\n            };\r\n        }());\r\n    }\r\n    \r\n    // Used to disable some features on IE8\r\n    var limited_mode = false;\r\n    var tick_duration = 200; // in ms\r\n    \r\n    var debug = (location.hash === \"#debug\");\r\n    function debug_log(msg) {\r\n        if (debug) {\r\n            console.log(msg);\r\n        }\r\n    }\r\n\r\n    var allUnits = [\"Days\", \"Hours\", \"Minutes\", \"Seconds\"];\r\n    var nextUnits = {\r\n        Seconds: \"Minutes\",\r\n        Minutes: \"Hours\",\r\n        Hours: \"Days\",\r\n        Days: \"Years\"\r\n    };\r\n    var secondsIn = {\r\n        Seconds: 1,\r\n        Minutes: 60,\r\n        Hours: 3600,\r\n        Days: 86400,\r\n        Months: 2678400,\r\n        Years: 31536000\r\n    };\r\n\r\n    /**\r\n     * Converts hex color code into object containing integer values for the r,g,b use\r\n     * This function (hexToRgb) originates from:\r\n     * http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\r\n     * @param {string} hex color code\r\n     */\r\n    function hexToRgb(hex) {\r\n        // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\r\n        var shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\r\n        hex = hex.replace(shorthandRegex, function(m, r, g, b) {\r\n            return r + r + g + g + b + b;\r\n        });\r\n\r\n        var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n        return result ? {\r\n            r: parseInt(result[1], 16),\r\n            g: parseInt(result[2], 16),\r\n            b: parseInt(result[3], 16)\r\n        } : null;\r\n    }\r\n    \r\n    function isCanvasSupported() {\r\n        var elem = document.createElement('canvas');\r\n        return !!(elem.getContext && elem.getContext('2d'));\r\n    }\r\n\r\n    /**\r\n     * Function s4() and guid() originate from:\r\n     * http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\r\n     */\r\n    function s4() {\r\n        return Math.floor((1 + Math.random()) * 0x10000)\r\n                .toString(16)\r\n                .substring(1);\r\n    }\r\n\r\n    /**\r\n     * Creates a unique id\r\n     * @returns {String}\r\n     */\r\n    function guid() {\r\n        return s4() + s4() + '-' + s4() + '-' + s4() + '-' +\r\n                s4() + '-' + s4() + s4() + s4();\r\n    }\r\n\r\n    /**\r\n     * Array.prototype.indexOf fallback for IE8\r\n     * @param {Mixed} mixed\r\n     * @returns {Number}\r\n     */\r\n    if (!Array.prototype.indexOf) {\r\n        Array.prototype.indexOf = function(elt /*, from*/)\r\n        {\r\n            var len = this.length >>> 0;\r\n\r\n            var from = Number(arguments[1]) || 0;\r\n            from = (from < 0)\r\n                    ? Math.ceil(from)\r\n                    : Math.floor(from);\r\n            if (from < 0)\r\n                from += len;\r\n\r\n            for (; from < len; from++)\r\n            {\r\n                if (from in this &&\r\n                        this[from] === elt)\r\n                    return from;\r\n            }\r\n            return -1;\r\n        };\r\n    }\r\n\r\n    function parse_date(str) {\r\n        var match = str.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}\\s[0-9]{1,2}:[0-9]{2}:[0-9]{2}$/);\r\n        if (match !== null && match.length > 0) {\r\n            var parts = str.split(\" \");\r\n            var date = parts[0].split(\"-\");\r\n            var time = parts[1].split(\":\");\r\n            return new Date(date[0], date[1] - 1, date[2], time[0], time[1], time[2]);\r\n        }\r\n        // Fallback for different date formats\r\n        var d = Date.parse(str);\r\n        if (!isNaN(d))\r\n            return d;\r\n        d = Date.parse(str.replace(/-/g, '/').replace('T', ' '));\r\n        if (!isNaN(d))\r\n            return d;\r\n        // Cant find anything\r\n        return new Date();\r\n    }\r\n\r\n    function parse_times(diff, old_diff, total_duration, units, floor) {\r\n        var raw_time = {};\r\n        var raw_old_time = {};\r\n        var time = {};\r\n        var pct = {};\r\n        var old_pct = {};\r\n        var old_time = {};\r\n\r\n        var greater_unit = null;\r\n        for(var i = 0; i < units.length; i++) {\r\n            var unit = units[i];\r\n            var maxUnits;\r\n\r\n            if (greater_unit === null) {\r\n                maxUnits = total_duration / secondsIn[unit];\r\n            }\r\n            else {\r\n                maxUnits = secondsIn[greater_unit] / secondsIn[unit];\r\n            }\r\n\r\n            var curUnits = (diff / secondsIn[unit]);\r\n            var oldUnits = (old_diff / secondsIn[unit]);\r\n            \r\n            if(floor) {\r\n                if(curUnits > 0) curUnits = Math.floor(curUnits);\r\n                else curUnits = Math.ceil(curUnits);\r\n                if(oldUnits > 0) oldUnits = Math.floor(oldUnits);\r\n                else oldUnits = Math.ceil(oldUnits);\r\n            }\r\n            \r\n            if (unit !== \"Days\") {\r\n                curUnits = curUnits % maxUnits;\r\n                oldUnits = oldUnits % maxUnits;\r\n            }\r\n\r\n            raw_time[unit] = curUnits;\r\n            time[unit] = Math.abs(curUnits);\r\n            raw_old_time[unit] = oldUnits;\r\n            old_time[unit] = Math.abs(oldUnits);\r\n            pct[unit] = Math.abs(curUnits) / maxUnits;\r\n            old_pct[unit] = Math.abs(oldUnits) / maxUnits;\r\n\r\n            greater_unit = unit;\r\n        }\r\n\r\n        return {\r\n            raw_time: raw_time,\r\n            raw_old_time: raw_old_time,\r\n            time: time,\r\n            old_time: old_time,\r\n            pct: pct,\r\n            old_pct: old_pct\r\n        };\r\n    }\r\n\r\n    var TC_Instance_List = {};\r\n    function updateUsedWindow() {\r\n        if(typeof useWindow.TC_Instance_List !== \"undefined\") {\r\n            TC_Instance_List = useWindow.TC_Instance_List;\r\n        }\r\n        else {\r\n            useWindow.TC_Instance_List = TC_Instance_List;\r\n        }\r\n        initializeAnimationFrameHandler(useWindow);\r\n    };\r\n    \r\n    function initializeAnimationFrameHandler(w) {\r\n        var vendors = ['webkit', 'moz'];\r\n        for (var x = 0; x < vendors.length && !w.requestAnimationFrame; ++x) {\r\n            w.requestAnimationFrame = w[vendors[x] + 'RequestAnimationFrame'];\r\n            w.cancelAnimationFrame = w[vendors[x] + 'CancelAnimationFrame'];\r\n        }\r\n\r\n        if (!w.requestAnimationFrame || !w.cancelAnimationFrame) {\r\n            w.requestAnimationFrame = function(callback, element, instance) {\r\n                if (typeof instance === \"undefined\")\r\n                    instance = {data: {last_frame: 0}};\r\n                var currTime = new Date().getTime();\r\n                var timeToCall = Math.max(0, 16 - (currTime - instance.data.last_frame));\r\n                var id = w.setTimeout(function() {\r\n                    callback(currTime + timeToCall);\r\n                }, timeToCall);\r\n                instance.data.last_frame = currTime + timeToCall;\r\n                return id;\r\n            };\r\n            w.cancelAnimationFrame = function(id) {\r\n                clearTimeout(id);\r\n            };\r\n        }\r\n    };\r\n    \r\n\r\n    var TC_Instance = function(element, options) {\r\n        this.element = element;\r\n        this.container;\r\n        this.listeners = null;\r\n        this.data = {\r\n            paused: false,\r\n            last_frame: 0,\r\n            animation_frame: null,\r\n            interval_fallback: null,\r\n            timer: false,\r\n            total_duration: null,\r\n            prev_time: null,\r\n            drawn_units: [],\r\n            text_elements: {\r\n                Days: null,\r\n                Hours: null,\r\n                Minutes: null,\r\n                Seconds: null\r\n            },\r\n            attributes: {\r\n                canvas: null,\r\n                context: null,\r\n                item_size: null,\r\n                line_width: null,\r\n                radius: null,\r\n                outer_radius: null\r\n            },\r\n            state: {\r\n                fading: {\r\n                    Days: false,\r\n                    Hours: false,\r\n                    Minutes: false,\r\n                    Seconds: false\r\n                }\r\n            }\r\n        };\r\n\r\n        this.config = null;\r\n        this.setOptions(options);\r\n        this.initialize();\r\n    };\r\n\r\n    TC_Instance.prototype.clearListeners = function() {\r\n        this.listeners = { all: [], visible: [] };\r\n    };\r\n    \r\n    TC_Instance.prototype.addTime = function(seconds_to_add) {\r\n        if(this.data.attributes.ref_date instanceof Date) {\r\n            var d = this.data.attributes.ref_date;\r\n            d.setSeconds(d.getSeconds() + seconds_to_add);\r\n        }\r\n        else if(!isNaN(this.data.attributes.ref_date)) {\r\n            this.data.attributes.ref_date += (seconds_to_add * 1000);\r\n        }\r\n    };\r\n    \r\n    TC_Instance.prototype.initialize = function(clear_listeners) {\r\n        // Initialize drawn units\r\n        this.data.drawn_units = [];\r\n        for(var i = 0; i < Object.keys(this.config.time).length; i++) {\r\n            var unit = Object.keys(this.config.time)[i];\r\n            if (this.config.time[unit].show) {\r\n                this.data.drawn_units.push(unit);\r\n            }\r\n        }\r\n\r\n        // Avoid stacking\r\n        $(this.element).children('div.time_circles').remove();\r\n\r\n        if (typeof clear_listeners === \"undefined\")\r\n            clear_listeners = true;\r\n        if (clear_listeners || this.listeners === null) {\r\n            this.clearListeners();\r\n        }\r\n        this.container = $(\"<div>\");\r\n        this.container.addClass('time_circles');\r\n        this.container.appendTo(this.element);\r\n        \r\n        // Determine the needed width and height of TimeCircles\r\n        var height = this.element.offsetHeight;\r\n        var width = this.element.offsetWidth;\r\n        if (height === 0)\r\n            height = $(this.element).height();\r\n        if (width === 0)\r\n            width = $(this.element).width();\r\n\r\n        if (height === 0 && width > 0)\r\n            height = width / this.data.drawn_units.length;\r\n        else if (width === 0 && height > 0)\r\n            width = height * this.data.drawn_units.length;\r\n        \r\n        // Create our canvas and set it to the appropriate size\r\n        var canvasElement = document.createElement('canvas');\r\n        canvasElement.width = width;\r\n        canvasElement.height = height;\r\n        \r\n        // Add canvas elements\r\n        this.data.attributes.canvas = $(canvasElement);\r\n        this.data.attributes.canvas.appendTo(this.container);\r\n        \r\n        // Check if the browser has browser support\r\n        var canvasSupported = isCanvasSupported();\r\n        // If the browser doesn't have browser support, check if explorer canvas is loaded\r\n        // (A javascript library that adds canvas support to browsers that don't have it)\r\n        if(!canvasSupported && typeof G_vmlCanvasManager !== \"undefined\") {\r\n            G_vmlCanvasManager.initElement(canvasElement);\r\n            limited_mode = true;\r\n            canvasSupported = true;\r\n        }\r\n        if(canvasSupported) {\r\n            this.data.attributes.context = canvasElement.getContext('2d');\r\n        }\r\n\r\n        this.data.attributes.item_size = Math.min(width / this.data.drawn_units.length, height);\r\n        this.data.attributes.line_width = this.data.attributes.item_size * this.config.fg_width;\r\n        this.data.attributes.radius = ((this.data.attributes.item_size * 0.8) - this.data.attributes.line_width) / 2;\r\n        this.data.attributes.outer_radius = this.data.attributes.radius + 0.5 * Math.max(this.data.attributes.line_width, this.data.attributes.line_width * this.config.bg_width);\r\n\r\n        // Prepare Time Elements\r\n        var i = 0;\r\n        for (var key in this.data.text_elements) {\r\n            if (!this.config.time[key].show)\r\n                continue;\r\n\r\n            var textElement = $(\"<div>\");\r\n            textElement.addClass('textDiv_' + key);\r\n            textElement.css(\"top\", Math.round(0.35 * this.data.attributes.item_size));\r\n            textElement.css(\"left\", Math.round(i++ * this.data.attributes.item_size));\r\n            textElement.css(\"width\", this.data.attributes.item_size);\r\n            textElement.appendTo(this.container);\r\n\r\n            \r\n\r\n            var numberElement = $(\"<span>\");\r\n            numberElement.css(\"font-size\", Math.round(3 * this.config.text_size * this.data.attributes.item_size));\r\n            numberElement.css(\"line-height\", Math.round(this.config.text_size * this.data.attributes.item_size) + \"px\");\r\n            numberElement.appendTo(textElement);\r\n            \r\n            var headerElement = $(\"<h4>\");\r\n            headerElement.text(this.config.time[key].text); // Options\r\n            headerElement.css(\"font-size\", Math.round(this.config.text_size * this.data.attributes.item_size));\r\n            headerElement.css(\"line-height\", Math.round(this.config.text_size * this.data.attributes.item_size) + \"px\");\r\n            headerElement.appendTo(textElement);\r\n\r\n            this.data.text_elements[key] = numberElement;\r\n        }\r\n\r\n        this.start();\r\n        if (!this.config.start) {\r\n            this.data.paused = true;\r\n        }\r\n        \r\n        // Set up interval fallback\r\n        var _this = this;\r\n        this.data.interval_fallback = useWindow.setInterval(function(){\r\n            _this.update.call(_this, true);\r\n        }, 100);\r\n    };\r\n\r\n    TC_Instance.prototype.update = function(nodraw) {\r\n        if(typeof nodraw === \"undefined\") {\r\n            nodraw = false;\r\n        }\r\n        else if(nodraw && this.data.paused) {\r\n            return;\r\n        }\r\n        \r\n        if(limited_mode) {\r\n            //Per unit clearing doesn't work in IE8 using explorer canvas, so do it in one time. The downside is that radial fade cant be used\r\n            this.data.attributes.context.clearRect(0, 0, this.data.attributes.canvas[0].width, this.data.attributes.canvas[0].hright);\r\n        }\r\n        var diff, old_diff;\r\n\r\n        var prevDate = this.data.prev_time;\r\n        var curDate = new Date();\r\n        this.data.prev_time = curDate;\r\n\r\n        if (prevDate === null)\r\n            prevDate = curDate;\r\n\r\n        // If not counting past zero, and time < 0, then simply draw the zero point once, and call stop\r\n        if (!this.config.count_past_zero) {\r\n            if (curDate > this.data.attributes.ref_date) {\r\n                for(var i = 0; i < this.data.drawn_units.length; i++) {\r\n                    var key = this.data.drawn_units[i];\r\n\r\n                    // Set the text value\r\n                    this.data.text_elements[key].text(\"0\");\r\n                    var x = (i * this.data.attributes.item_size) + (this.data.attributes.item_size / 2);\r\n                    var y = this.data.attributes.item_size / 2;\r\n                    var color = this.config.time[key].color;\r\n                    this.drawArc(x, y, color, 0);\r\n                }\r\n                this.stop();\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Compare current time with reference\r\n        diff = (this.data.attributes.ref_date - curDate) / 1000;\r\n        old_diff = (this.data.attributes.ref_date - prevDate) / 1000;\r\n\r\n        var floor = this.config.animation !== \"smooth\";\r\n\r\n        var visible_times = parse_times(diff, old_diff, this.data.total_duration, this.data.drawn_units, floor);\r\n        var all_times = parse_times(diff, old_diff, secondsIn[\"Years\"], allUnits, floor);\r\n\r\n        var i = 0;\r\n        var j = 0;\r\n        var lastKey = null;\r\n\r\n        var cur_shown = this.data.drawn_units.slice();\r\n        for (var i in allUnits) {\r\n            var key = allUnits[i];\r\n\r\n            // Notify (all) listeners\r\n            if (Math.floor(all_times.raw_time[key]) !== Math.floor(all_times.raw_old_time[key])) {\r\n                this.notifyListeners(key, Math.floor(all_times.time[key]), Math.floor(diff), \"all\");\r\n            }\r\n\r\n            if (cur_shown.indexOf(key) < 0)\r\n                continue;\r\n\r\n            // Notify (visible) listeners\r\n            if (Math.floor(visible_times.raw_time[key]) !== Math.floor(visible_times.raw_old_time[key])) {\r\n                this.notifyListeners(key, Math.floor(visible_times.time[key]), Math.floor(diff), \"visible\");\r\n            }\r\n            \r\n            if(!nodraw) {\r\n                // Set the text value\r\n                this.data.text_elements[key].text(Math.floor(Math.abs(visible_times.time[key])));\r\n\r\n                var x = (j * this.data.attributes.item_size) + (this.data.attributes.item_size / 2);\r\n                var y = this.data.attributes.item_size / 2;\r\n                var color = this.config.time[key].color;\r\n\r\n                if (this.config.animation === \"smooth\") {\r\n                    if (lastKey !== null && !limited_mode) {\r\n                        if (Math.floor(visible_times.time[lastKey]) > Math.floor(visible_times.old_time[lastKey])) {\r\n                            this.radialFade(x, y, color, 1, key);\r\n                            this.data.state.fading[key] = true;\r\n                        }\r\n                        else if (Math.floor(visible_times.time[lastKey]) < Math.floor(visible_times.old_time[lastKey])) {\r\n                            this.radialFade(x, y, color, 0, key);\r\n                            this.data.state.fading[key] = true;\r\n                        }\r\n                    }\r\n                    if (!this.data.state.fading[key]) {\r\n                        this.drawArc(x, y, color, visible_times.pct[key]);\r\n                    }\r\n                }\r\n                else {\r\n                    this.animateArc(x, y, color, visible_times.pct[key], visible_times.old_pct[key], (new Date()).getTime() + tick_duration);\r\n                }\r\n            }\r\n            lastKey = key;\r\n            j++;\r\n        }\r\n\r\n        // Dont request another update if we should be paused\r\n        if(this.data.paused || nodraw) {\r\n            return;\r\n        }\r\n        \r\n        // We need this for our next frame either way\r\n        var _this = this;\r\n        var update = function() {\r\n            _this.update.call(_this);\r\n        };\r\n\r\n        // Either call next update immediately, or in a second\r\n        if (this.config.animation === \"smooth\") {\r\n            // Smooth animation, Queue up the next frame\r\n            this.data.animation_frame = useWindow.requestAnimationFrame(update, _this.element, _this);\r\n        }\r\n        else {\r\n            // Tick animation, Don't queue until very slightly after the next second happens\r\n            var delay = (diff % 1) * 1000;\r\n            if (delay < 0)\r\n                delay = 1000 + delay;\r\n            delay += 50;\r\n\r\n            _this.data.animation_frame = useWindow.setTimeout(function() {\r\n                _this.data.animation_frame = useWindow.requestAnimationFrame(update, _this.element, _this);\r\n            }, delay);\r\n        }\r\n    };\r\n\r\n    TC_Instance.prototype.animateArc = function(x, y, color, target_pct, cur_pct, animation_end) {\r\n        if (this.data.attributes.context === null)\r\n            return;\r\n\r\n        var diff = cur_pct - target_pct;\r\n        if (Math.abs(diff) > 0.5) {\r\n            if (target_pct === 0) {\r\n                this.radialFade(x, y, color, 1);\r\n            }\r\n            else {\r\n                this.radialFade(x, y, color, 0);\r\n            }\r\n        }\r\n        else {\r\n            var progress = (tick_duration - (animation_end - (new Date()).getTime())) / tick_duration;\r\n            if (progress > 1)\r\n                progress = 1;\r\n\r\n            var pct = (cur_pct * (1 - progress)) + (target_pct * progress);\r\n            this.drawArc(x, y, color, pct);\r\n\r\n            //var show_pct =\r\n            if (progress >= 1)\r\n                return;\r\n            var _this = this;\r\n            useWindow.requestAnimationFrame(function() {\r\n                _this.animateArc(x, y, color, target_pct, cur_pct, animation_end);\r\n            }, this.element);\r\n        }\r\n    };\r\n\r\n    TC_Instance.prototype.drawArc = function(x, y, color, pct) {\r\n        if (this.data.attributes.context === null)\r\n            return;\r\n\r\n        var clear_radius = Math.max(this.data.attributes.outer_radius, this.data.attributes.item_size / 2);\r\n        if(!limited_mode) {\r\n            this.data.attributes.context.clearRect(\r\n                    x - clear_radius,\r\n                    y - clear_radius,\r\n                    clear_radius * 2,\r\n                    clear_radius * 2\r\n                    );\r\n        }\r\n        \r\n        if (this.config.use_background) {\r\n            this.data.attributes.context.beginPath();\r\n            this.data.attributes.context.arc(x, y, this.data.attributes.radius, 0, 2 * Math.PI, false);\r\n            this.data.attributes.context.lineWidth = this.data.attributes.line_width * this.config.bg_width;\r\n\r\n            // line color\r\n            this.data.attributes.context.strokeStyle = this.config.circle_bg_color;\r\n            this.data.attributes.context.stroke();\r\n        }\r\n\r\n        // Direction\r\n        var startAngle, endAngle, counterClockwise;\r\n        var defaultOffset = (-0.5 * Math.PI);\r\n        var fullCircle = 2 * Math.PI;\r\n        startAngle = defaultOffset + (this.config.start_angle / 360 * fullCircle);\r\n        var offset = (2 * pct * Math.PI);\r\n\r\n        if (this.config.direction === \"Both\") {\r\n            counterClockwise = false;\r\n            startAngle -= (offset / 2);\r\n            endAngle = startAngle + offset;\r\n        }\r\n        else {\r\n            if (this.config.direction === \"Clockwise\") {\r\n                counterClockwise = false;\r\n                endAngle = startAngle + offset;\r\n            }\r\n            else {\r\n                counterClockwise = true;\r\n                endAngle = startAngle - offset;\r\n            }\r\n        }\r\n\r\n        this.data.attributes.context.beginPath();\r\n        this.data.attributes.context.arc(x, y, this.data.attributes.radius, startAngle, endAngle, counterClockwise);\r\n        this.data.attributes.context.lineWidth = this.data.attributes.line_width;\r\n\r\n        // line color\r\n        this.data.attributes.context.strokeStyle = color;\r\n        this.data.attributes.context.stroke();\r\n    };\r\n\r\n    TC_Instance.prototype.radialFade = function(x, y, color, from, key) {\r\n        // TODO: Make fade_time option\r\n        var rgb = hexToRgb(color);\r\n        var _this = this; // We have a few inner scopes here that will need access to our instance\r\n\r\n        var step = 0.2 * ((from === 1) ? -1 : 1);\r\n        var i;\r\n        for (i = 0; from <= 1 && from >= 0; i++) {\r\n            // Create inner scope so our variables are not changed by the time the Timeout triggers\r\n            (function() {\r\n                var delay = 50 * i;\r\n                var rgba = \"rgba(\" + rgb.r + \", \" + rgb.g + \", \" + rgb.b + \", \" + (Math.round(from * 10) / 10) + \")\";\r\n                useWindow.setTimeout(function() {\r\n                    _this.drawArc(x, y, rgba, 1);\r\n                }, delay);\r\n            }());\r\n            from += step;\r\n        }\r\n        if (typeof key !== undefined) {\r\n            useWindow.setTimeout(function() {\r\n                _this.data.state.fading[key] = false;\r\n            }, 50 * i);\r\n        }\r\n    };\r\n\r\n    TC_Instance.prototype.timeLeft = function() {\r\n        if (this.data.paused && typeof this.data.timer === \"number\") {\r\n            return this.data.timer;\r\n        }\r\n        var now = new Date();\r\n        return ((this.data.attributes.ref_date - now) / 1000);\r\n    };\r\n\r\n    TC_Instance.prototype.start = function() {\r\n        useWindow.cancelAnimationFrame(this.data.animation_frame);\r\n        useWindow.clearTimeout(this.data.animation_frame)\r\n\r\n        // Check if a date was passed in html attribute or jquery data\r\n        var attr_data_date = $(this.element).data('date');\r\n        if (typeof attr_data_date === \"undefined\") {\r\n            attr_data_date = $(this.element).attr('data-date');\r\n        }\r\n        if (typeof attr_data_date === \"string\") {\r\n            this.data.attributes.ref_date = parse_date(attr_data_date);\r\n        }\r\n        // Check if this is an unpause of a timer\r\n        else if (typeof this.data.timer === \"number\") {\r\n            if (this.data.paused) {\r\n                this.data.attributes.ref_date = (new Date()).getTime() + (this.data.timer * 1000);\r\n            }\r\n        }\r\n        else {\r\n            // Try to get data-timer\r\n            var attr_data_timer = $(this.element).data('timer');\r\n            if (typeof attr_data_timer === \"undefined\") {\r\n                attr_data_timer = $(this.element).attr('data-timer');\r\n            }\r\n            if (typeof attr_data_timer === \"string\") {\r\n                attr_data_timer = parseFloat(attr_data_timer);\r\n            }\r\n            if (typeof attr_data_timer === \"number\") {\r\n                this.data.timer = attr_data_timer;\r\n                this.data.attributes.ref_date = (new Date()).getTime() + (attr_data_timer * 1000);\r\n            }\r\n            else {\r\n                // data-timer and data-date were both not set\r\n                // use config date\r\n                this.data.attributes.ref_date = this.config.ref_date;\r\n            }\r\n        }\r\n\r\n        // Start running\r\n        this.data.paused = false;\r\n        this.update.call(this);\r\n    };\r\n\r\n    TC_Instance.prototype.restart = function() {\r\n        this.data.timer = false;\r\n        this.start();\r\n    };\r\n\r\n    TC_Instance.prototype.stop = function() {\r\n        if (typeof this.data.timer === \"number\") {\r\n            this.data.timer = this.timeLeft(this);\r\n        }\r\n        // Stop running\r\n        this.data.paused = true;\r\n        useWindow.cancelAnimationFrame(this.data.animation_frame);\r\n    };\r\n\r\n    TC_Instance.prototype.destroy = function() {\r\n        this.clearListeners();\r\n        this.stop();\r\n        useWindow.clearInterval(this.data.interval_fallback);\r\n        this.data.interval_fallback = null;\r\n        \r\n        this.container.remove();\r\n        $(this.element).removeAttr('data-tc-id');\r\n        $(this.element).removeData('tc-id');\r\n    };\r\n\r\n    TC_Instance.prototype.setOptions = function(options) {\r\n        if (this.config === null) {\r\n            this.default_options.ref_date = new Date();\r\n            this.config = $.extend(true, {}, this.default_options);\r\n        }\r\n        $.extend(true, this.config, options);\r\n\r\n        // Use window.top if use_top_frame is true\r\n        if(this.config.use_top_frame) {\r\n            useWindow = window.top;\r\n        }\r\n        else {\r\n            useWindow = window;\r\n        }\r\n        updateUsedWindow();\r\n        \r\n        this.data.total_duration = this.config.total_duration;\r\n        if (typeof this.data.total_duration === \"string\") {\r\n            if (typeof secondsIn[this.data.total_duration] !== \"undefined\") {\r\n                // If set to Years, Months, Days, Hours or Minutes, fetch the secondsIn value for that\r\n                this.data.total_duration = secondsIn[this.data.total_duration];\r\n            }\r\n            else if (this.data.total_duration === \"Auto\") {\r\n                // If set to auto, total_duration is the size of 1 unit, of the unit type bigger than the largest shown\r\n                for(var i = 0; i < Object.keys(this.config.time).length; i++) {\r\n                    var unit = Object.keys(this.config.time)[i];\r\n                    if (this.config.time[unit].show) {\r\n                        this.data.total_duration = secondsIn[nextUnits[unit]];\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // If it's a string, but neither of the above, user screwed up.\r\n                this.data.total_duration = secondsIn[\"Years\"];\r\n                console.error(\"Valid values for TimeCircles config.total_duration are either numeric, or (string) Years, Months, Days, Hours, Minutes, Auto\");\r\n            }\r\n        }\r\n    };\r\n\r\n    TC_Instance.prototype.addListener = function(f, context, type) {\r\n        if (typeof f !== \"function\")\r\n            return;\r\n        if (typeof type === \"undefined\")\r\n            type = \"visible\";\r\n        this.listeners[type].push({func: f, scope: context});\r\n    };\r\n\r\n    TC_Instance.prototype.notifyListeners = function(unit, value, total, type) {\r\n        for (var i = 0; i < this.listeners[type].length; i++) {\r\n            var listener = this.listeners[type][i];\r\n            listener.func.apply(listener.scope, [unit, value, total]);\r\n        }\r\n    };\r\n\r\n    TC_Instance.prototype.default_options = {\r\n        ref_date: new Date(),\r\n        start: true,\r\n        animation: \"smooth\",\r\n        count_past_zero: true,\r\n        circle_bg_color: \"rgba(255,255,255,.1)\",\r\n        use_background: true,\r\n        fg_width: 0.04,\r\n        bg_width: 1,\r\n        text_size: 0.12,\r\n        number_size: 0.28,\r\n        total_duration: \"Auto\",\r\n        direction: \"Clockwise\",\r\n        use_top_frame: false,\r\n        start_angle: 0,\r\n        time: {\r\n            Days: {\r\n                show: true,\r\n                text: \"Days\",\r\n                color: \"#82B236\"\r\n            },\r\n            Hours: {\r\n                show: true,\r\n                text: \"Hours\",\r\n                color: \"#82B236\"\r\n            },\r\n            Minutes: {\r\n                show: true,\r\n                text: \"Minutes\",\r\n                color: \"#82B236\"\r\n            },\r\n            Seconds: {\r\n                show: true,\r\n                text: \"Seconds\",\r\n                color: \"#82B236\"\r\n            }\r\n        }\r\n    };\r\n\r\n    // Time circle class\r\n    var TC_Class = function(elements, options) {\r\n        this.elements = elements;\r\n        this.options = options;\r\n        this.foreach();\r\n    };\r\n\r\n    TC_Class.prototype.getInstance = function(element) {\r\n        var instance;\r\n\r\n        var cur_id = $(element).data(\"tc-id\");\r\n        if (typeof cur_id === \"undefined\") {\r\n            cur_id = guid();\r\n            $(element).attr(\"data-tc-id\", cur_id);\r\n        }\r\n        if (typeof TC_Instance_List[cur_id] === \"undefined\") {\r\n            var options = this.options;\r\n            var element_options = $(element).data('options');\r\n            if (typeof element_options === \"string\") {\r\n                element_options = JSON.parse(element_options);\r\n            }\r\n            if (typeof element_options === \"object\") {\r\n                options = $.extend(true, {}, this.options, element_options);\r\n            }\r\n            instance = new TC_Instance(element, options);\r\n            TC_Instance_List[cur_id] = instance;\r\n        }\r\n        else {\r\n            instance = TC_Instance_List[cur_id];\r\n            if (typeof this.options !== \"undefined\") {\r\n                instance.setOptions(this.options);\r\n            }\r\n        }\r\n        return instance;\r\n    };\r\n\r\n    TC_Class.prototype.addTime = function(seconds_to_add) {\r\n        this.foreach(function(instance) {\r\n            instance.addTime(seconds_to_add);\r\n        });\r\n    };\r\n    \r\n    TC_Class.prototype.foreach = function(callback) {\r\n        var _this = this;\r\n        this.elements.each(function() {\r\n            var instance = _this.getInstance(this);\r\n            if (typeof callback === \"function\") {\r\n                callback(instance);\r\n            }\r\n        });\r\n        return this;\r\n    };\r\n\r\n    TC_Class.prototype.start = function() {\r\n        this.foreach(function(instance) {\r\n            instance.start();\r\n        });\r\n        return this;\r\n    };\r\n\r\n    TC_Class.prototype.stop = function() {\r\n        this.foreach(function(instance) {\r\n            instance.stop();\r\n        });\r\n        return this;\r\n    };\r\n\r\n    TC_Class.prototype.restart = function() {\r\n        this.foreach(function(instance) {\r\n            instance.restart();\r\n        });\r\n        return this;\r\n    };\r\n\r\n    TC_Class.prototype.rebuild = function() {\r\n        this.foreach(function(instance) {\r\n            instance.initialize(false);\r\n        });\r\n        return this;\r\n    };\r\n\r\n    TC_Class.prototype.getTime = function() {\r\n        return this.getInstance(this.elements[0]).timeLeft();\r\n    };\r\n\r\n    TC_Class.prototype.addListener = function(f, type) {\r\n        if (typeof type === \"undefined\")\r\n            type = \"visible\";\r\n        var _this = this;\r\n        this.foreach(function(instance) {\r\n            instance.addListener(f, _this.elements, type);\r\n        });\r\n        return this;\r\n    };\r\n\r\n    TC_Class.prototype.destroy = function() {\r\n        this.foreach(function(instance) {\r\n            instance.destroy();\r\n        });\r\n        return this;\r\n    };\r\n\r\n    TC_Class.prototype.end = function() {\r\n        return this.elements;\r\n    };\r\n\r\n    $.fn.TimeCircles = function(options) {\r\n        return new TC_Class(this, options);\r\n    };\r\n}(jQuery));\r\n });","js/bootstrap/bootstrap.min.js":"/*!\r\n * Bootstrap v4.1.1 (https://getbootstrap.com/)\r\n * Copyright 2011-2018 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\r\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\r\n */\r\n!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?e(exports,require(\"jquery\")):\"function\"==typeof define&&define.amd?define([\"exports\",\"jquery\"],e):e(t.bootstrap={},t.jQuery)}(this,function(t,e){\"use strict\";function i(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,\"value\"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}function s(t,e,n){return e&&i(t.prototype,e),n&&i(t,n),t}function c(r){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{},e=Object.keys(o);\"function\"==typeof Object.getOwnPropertySymbols&&(e=e.concat(Object.getOwnPropertySymbols(o).filter(function(t){return Object.getOwnPropertyDescriptor(o,t).enumerable}))),e.forEach(function(t){var e,n,i;e=r,i=o[n=t],n in e?Object.defineProperty(e,n,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[n]=i})}return r}for(var r,n,o,a,l,f,h,u,d,p,g,m,_,v,E,y,b,T,C,w,I,D,A,S,O,N,k,L,P,x,j,M,R,H,W,F,U,B,K,V,Q,Y,G,q,z,X,J,Z,$,tt,et,nt,it,rt,ot,st,at,lt,ct,ft,ht,ut,dt,pt,gt=function(i){var e=\"transitionend\";function t(t){var e=this,n=!1;return i(this).one(l.TRANSITION_END,function(){n=!0}),setTimeout(function(){n||l.triggerTransitionEnd(e)},t),this}var l={TRANSITION_END:\"bsTransitionEnd\",getUID:function(t){for(;t+=~~(1e6*Math.random()),document.getElementById(t););return t},getSelectorFromElement:function(t){var e=t.getAttribute(\"data-target\");e&&\"#\"!==e||(e=t.getAttribute(\"href\")||\"\");try{return 0<i(document).find(e).length?e:null}catch(t){return null}},getTransitionDurationFromElement:function(t){if(!t)return 0;var e=i(t).css(\"transition-duration\");return parseFloat(e)?(e=e.split(\",\")[0],1e3*parseFloat(e)):0},reflow:function(t){return t.offsetHeight},triggerTransitionEnd:function(t){i(t).trigger(e)},supportsTransitionEnd:function(){return Boolean(e)},isElement:function(t){return(t[0]||t).nodeType},typeCheckConfig:function(t,e,n){for(var i in n)if(Object.prototype.hasOwnProperty.call(n,i)){var r=n[i],o=e[i],s=o&&l.isElement(o)?\"element\":(a=o,{}.toString.call(a).match(/\\s([a-z]+)/i)[1].toLowerCase());if(!new RegExp(r).test(s))throw new Error(t.toUpperCase()+': Option \"'+i+'\" provided type \"'+s+'\" but expected type \"'+r+'\".')}var a}};return i.fn.emulateTransitionEnd=t,i.event.special[l.TRANSITION_END]={bindType:e,delegateType:e,handle:function(t){if(i(t.target).is(this))return t.handleObj.handler.apply(this,arguments)}},l}(e=e&&e.hasOwnProperty(\"default\")?e.default:e),mt=(n=\"alert\",a=\".\"+(o=\"bs.alert\"),l=(r=e).fn[n],f={CLOSE:\"close\"+a,CLOSED:\"closed\"+a,CLICK_DATA_API:\"click\"+a+\".data-api\"},h=\"alert\",u=\"fade\",d=\"show\",p=function(){function i(t){this._element=t}var t=i.prototype;return t.close=function(t){var e=this._element;t&&(e=this._getRootElement(t)),this._triggerCloseEvent(e).isDefaultPrevented()||this._removeElement(e)},t.dispose=function(){r.removeData(this._element,o),this._element=null},t._getRootElement=function(t){var e=gt.getSelectorFromElement(t),n=!1;return e&&(n=r(e)[0]),n||(n=r(t).closest(\".\"+h)[0]),n},t._triggerCloseEvent=function(t){var e=r.Event(f.CLOSE);return r(t).trigger(e),e},t._removeElement=function(e){var n=this;if(r(e).removeClass(d),r(e).hasClass(u)){var t=gt.getTransitionDurationFromElement(e);r(e).one(gt.TRANSITION_END,function(t){return n._destroyElement(e,t)}).emulateTransitionEnd(t)}else this._destroyElement(e)},t._destroyElement=function(t){r(t).detach().trigger(f.CLOSED).remove()},i._jQueryInterface=function(n){return this.each(function(){var t=r(this),e=t.data(o);e||(e=new i(this),t.data(o,e)),\"close\"===n&&e[n](this)})},i._handleDismiss=function(e){return function(t){t&&t.preventDefault(),e.close(this)}},s(i,null,[{key:\"VERSION\",get:function(){return\"4.1.1\"}}]),i}(),r(document).on(f.CLICK_DATA_API,'[data-dismiss=\"alert\"]',p._handleDismiss(new p)),r.fn[n]=p._jQueryInterface,r.fn[n].Constructor=p,r.fn[n].noConflict=function(){return r.fn[n]=l,p._jQueryInterface},p),_t=(m=\"button\",v=\".\"+(_=\"bs.button\"),E=\".data-api\",y=(g=e).fn[m],b=\"active\",T=\"btn\",w='[data-toggle^=\"button\"]',I='[data-toggle=\"buttons\"]',D=\"input\",A=\".active\",S=\".btn\",O={CLICK_DATA_API:\"click\"+v+E,FOCUS_BLUR_DATA_API:(C=\"focus\")+v+E+\" blur\"+v+E},N=function(){function n(t){this._element=t}var t=n.prototype;return t.toggle=function(){var t=!0,e=!0,n=g(this._element).closest(I)[0];if(n){var i=g(this._element).find(D)[0];if(i){if(\"radio\"===i.type)if(i.checked&&g(this._element).hasClass(b))t=!1;else{var r=g(n).find(A)[0];r&&g(r).removeClass(b)}if(t){if(i.hasAttribute(\"disabled\")||n.hasAttribute(\"disabled\")||i.classList.contains(\"disabled\")||n.classList.contains(\"disabled\"))return;i.checked=!g(this._element).hasClass(b),g(i).trigger(\"change\")}i.focus(),e=!1}}e&&this._element.setAttribute(\"aria-pressed\",!g(this._element).hasClass(b)),t&&g(this._element).toggleClass(b)},t.dispose=function(){g.removeData(this._element,_),this._element=null},n._jQueryInterface=function(e){return this.each(function(){var t=g(this).data(_);t||(t=new n(this),g(this).data(_,t)),\"toggle\"===e&&t[e]()})},s(n,null,[{key:\"VERSION\",get:function(){return\"4.1.1\"}}]),n}(),g(document).on(O.CLICK_DATA_API,w,function(t){t.preventDefault();var e=t.target;g(e).hasClass(T)||(e=g(e).closest(S)),N._jQueryInterface.call(g(e),\"toggle\")}).on(O.FOCUS_BLUR_DATA_API,w,function(t){var e=g(t.target).closest(S)[0];g(e).toggleClass(C,/^focus(in)?$/.test(t.type))}),g.fn[m]=N._jQueryInterface,g.fn[m].Constructor=N,g.fn[m].noConflict=function(){return g.fn[m]=y,N._jQueryInterface},N),vt=(L=\"carousel\",x=\".\"+(P=\"bs.carousel\"),j=\".data-api\",M=(k=e).fn[L],R={interval:5e3,keyboard:!0,slide:!1,pause:\"hover\",wrap:!0},H={interval:\"(number|boolean)\",keyboard:\"boolean\",slide:\"(boolean|string)\",pause:\"(string|boolean)\",wrap:\"boolean\"},W=\"next\",F=\"prev\",U=\"left\",B=\"right\",K={SLIDE:\"slide\"+x,SLID:\"slid\"+x,KEYDOWN:\"keydown\"+x,MOUSEENTER:\"mouseenter\"+x,MOUSELEAVE:\"mouseleave\"+x,TOUCHEND:\"touchend\"+x,LOAD_DATA_API:\"load\"+x+j,CLICK_DATA_API:\"click\"+x+j},V=\"carousel\",Q=\"active\",Y=\"slide\",G=\"carousel-item-right\",q=\"carousel-item-left\",z=\"carousel-item-next\",X=\"carousel-item-prev\",J={ACTIVE:\".active\",ACTIVE_ITEM:\".active.carousel-item\",ITEM:\".carousel-item\",NEXT_PREV:\".carousel-item-next, .carousel-item-prev\",INDICATORS:\".carousel-indicators\",DATA_SLIDE:\"[data-slide], [data-slide-to]\",DATA_RIDE:'[data-ride=\"carousel\"]'},Z=function(){function o(t,e){this._items=null,this._interval=null,this._activeElement=null,this._isPaused=!1,this._isSliding=!1,this.touchTimeout=null,this._config=this._getConfig(e),this._element=k(t)[0],this._indicatorsElement=k(this._element).find(J.INDICATORS)[0],this._addEventListeners()}var t=o.prototype;return t.next=function(){this._isSliding||this._slide(W)},t.nextWhenVisible=function(){!document.hidden&&k(this._element).is(\":visible\")&&\"hidden\"!==k(this._element).css(\"visibility\")&&this.next()},t.prev=function(){this._isSliding||this._slide(F)},t.pause=function(t){t||(this._isPaused=!0),k(this._element).find(J.NEXT_PREV)[0]&&(gt.triggerTransitionEnd(this._element),this.cycle(!0)),clearInterval(this._interval),this._interval=null},t.cycle=function(t){t||(this._isPaused=!1),this._interval&&(clearInterval(this._interval),this._interval=null),this._config.interval&&!this._isPaused&&(this._interval=setInterval((document.visibilityState?this.nextWhenVisible:this.next).bind(this),this._config.interval))},t.to=function(t){var e=this;this._activeElement=k(this._element).find(J.ACTIVE_ITEM)[0];var n=this._getItemIndex(this._activeElement);if(!(t>this._items.length-1||t<0))if(this._isSliding)k(this._element).one(K.SLID,function(){return e.to(t)});else{if(n===t)return this.pause(),void this.cycle();var i=n<t?W:F;this._slide(i,this._items[t])}},t.dispose=function(){k(this._element).off(x),k.removeData(this._element,P),this._items=null,this._config=null,this._element=null,this._interval=null,this._isPaused=null,this._isSliding=null,this._activeElement=null,this._indicatorsElement=null},t._getConfig=function(t){return t=c({},R,t),gt.typeCheckConfig(L,t,H),t},t._addEventListeners=function(){var e=this;this._config.keyboard&&k(this._element).on(K.KEYDOWN,function(t){return e._keydown(t)}),\"hover\"===this._config.pause&&(k(this._element).on(K.MOUSEENTER,function(t){return e.pause(t)}).on(K.MOUSELEAVE,function(t){return e.cycle(t)}),\"ontouchstart\"in document.documentElement&&k(this._element).on(K.TOUCHEND,function(){e.pause(),e.touchTimeout&&clearTimeout(e.touchTimeout),e.touchTimeout=setTimeout(function(t){return e.cycle(t)},500+e._config.interval)}))},t._keydown=function(t){if(!/input|textarea/i.test(t.target.tagName))switch(t.which){case 37:t.preventDefault(),this.prev();break;case 39:t.preventDefault(),this.next()}},t._getItemIndex=function(t){return this._items=k.makeArray(k(t).parent().find(J.ITEM)),this._items.indexOf(t)},t._getItemByDirection=function(t,e){var n=t===W,i=t===F,r=this._getItemIndex(e),o=this._items.length-1;if((i&&0===r||n&&r===o)&&!this._config.wrap)return e;var s=(r+(t===F?-1:1))%this._items.length;return-1===s?this._items[this._items.length-1]:this._items[s]},t._triggerSlideEvent=function(t,e){var n=this._getItemIndex(t),i=this._getItemIndex(k(this._element).find(J.ACTIVE_ITEM)[0]),r=k.Event(K.SLIDE,{relatedTarget:t,direction:e,from:i,to:n});return k(this._element).trigger(r),r},t._setActiveIndicatorElement=function(t){if(this._indicatorsElement){k(this._indicatorsElement).find(J.ACTIVE).removeClass(Q);var e=this._indicatorsElement.children[this._getItemIndex(t)];e&&k(e).addClass(Q)}},t._slide=function(t,e){var n,i,r,o=this,s=k(this._element).find(J.ACTIVE_ITEM)[0],a=this._getItemIndex(s),l=e||s&&this._getItemByDirection(t,s),c=this._getItemIndex(l),f=Boolean(this._interval);if(t===W?(n=q,i=z,r=U):(n=G,i=X,r=B),l&&k(l).hasClass(Q))this._isSliding=!1;else if(!this._triggerSlideEvent(l,r).isDefaultPrevented()&&s&&l){this._isSliding=!0,f&&this.pause(),this._setActiveIndicatorElement(l);var h=k.Event(K.SLID,{relatedTarget:l,direction:r,from:a,to:c});if(k(this._element).hasClass(Y)){k(l).addClass(i),gt.reflow(l),k(s).addClass(n),k(l).addClass(n);var u=gt.getTransitionDurationFromElement(s);k(s).one(gt.TRANSITION_END,function(){k(l).removeClass(n+\" \"+i).addClass(Q),k(s).removeClass(Q+\" \"+i+\" \"+n),o._isSliding=!1,setTimeout(function(){return k(o._element).trigger(h)},0)}).emulateTransitionEnd(u)}else k(s).removeClass(Q),k(l).addClass(Q),this._isSliding=!1,k(this._element).trigger(h);f&&this.cycle()}},o._jQueryInterface=function(i){return this.each(function(){var t=k(this).data(P),e=c({},R,k(this).data());\"object\"==typeof i&&(e=c({},e,i));var n=\"string\"==typeof i?i:e.slide;if(t||(t=new o(this,e),k(this).data(P,t)),\"number\"==typeof i)t.to(i);else if(\"string\"==typeof n){if(\"undefined\"==typeof t[n])throw new TypeError('No method named \"'+n+'\"');t[n]()}else e.interval&&(t.pause(),t.cycle())})},o._dataApiClickHandler=function(t){var e=gt.getSelectorFromElement(this);if(e){var n=k(e)[0];if(n&&k(n).hasClass(V)){var i=c({},k(n).data(),k(this).data()),r=this.getAttribute(\"data-slide-to\");r&&(i.interval=!1),o._jQueryInterface.call(k(n),i),r&&k(n).data(P).to(r),t.preventDefault()}}},s(o,null,[{key:\"VERSION\",get:function(){return\"4.1.1\"}},{key:\"Default\",get:function(){return R}}]),o}(),k(document).on(K.CLICK_DATA_API,J.DATA_SLIDE,Z._dataApiClickHandler),k(window).on(K.LOAD_DATA_API,function(){k(J.DATA_RIDE).each(function(){var t=k(this);Z._jQueryInterface.call(t,t.data())})}),k.fn[L]=Z._jQueryInterface,k.fn[L].Constructor=Z,k.fn[L].noConflict=function(){return k.fn[L]=M,Z._jQueryInterface},Z),Et=(tt=\"collapse\",nt=\".\"+(et=\"bs.collapse\"),it=($=e).fn[tt],rt={toggle:!0,parent:\"\"},ot={toggle:\"boolean\",parent:\"(string|element)\"},st={SHOW:\"show\"+nt,SHOWN:\"shown\"+nt,HIDE:\"hide\"+nt,HIDDEN:\"hidden\"+nt,CLICK_DATA_API:\"click\"+nt+\".data-api\"},at=\"show\",lt=\"collapse\",ct=\"collapsing\",ft=\"collapsed\",ht=\"width\",ut=\"height\",dt={ACTIVES:\".show, .collapsing\",DATA_TOGGLE:'[data-toggle=\"collapse\"]'},pt=function(){function a(t,e){this._isTransitioning=!1,this._element=t,this._config=this._getConfig(e),this._triggerArray=$.makeArray($('[data-toggle=\"collapse\"][href=\"#'+t.id+'\"],[data-toggle=\"collapse\"][data-target=\"#'+t.id+'\"]'));for(var n=$(dt.DATA_TOGGLE),i=0;i<n.length;i++){var r=n[i],o=gt.getSelectorFromElement(r);null!==o&&0<$(o).filter(t).length&&(this._selector=o,this._triggerArray.push(r))}this._parent=this._config.parent?this._getParent():null,this._config.parent||this._addAriaAndCollapsedClass(this._element,this._triggerArray),this._config.toggle&&this.toggle()}var t=a.prototype;return t.toggle=function(){$(this._element).hasClass(at)?this.hide():this.show()},t.show=function(){var t,e,n=this;if(!this._isTransitioning&&!$(this._element).hasClass(at)&&(this._parent&&0===(t=$.makeArray($(this._parent).find(dt.ACTIVES).filter('[data-parent=\"'+this._config.parent+'\"]'))).length&&(t=null),!(t&&(e=$(t).not(this._selector).data(et))&&e._isTransitioning))){var i=$.Event(st.SHOW);if($(this._element).trigger(i),!i.isDefaultPrevented()){t&&(a._jQueryInterface.call($(t).not(this._selector),\"hide\"),e||$(t).data(et,null));var r=this._getDimension();$(this._element).removeClass(lt).addClass(ct),(this._element.style[r]=0)<this._triggerArray.length&&$(this._triggerArray).removeClass(ft).attr(\"aria-expanded\",!0),this.setTransitioning(!0);var o=\"scroll\"+(r[0].toUpperCase()+r.slice(1)),s=gt.getTransitionDurationFromElement(this._element);$(this._element).one(gt.TRANSITION_END,function(){$(n._element).removeClass(ct).addClass(lt).addClass(at),n._element.style[r]=\"\",n.setTransitioning(!1),$(n._element).trigger(st.SHOWN)}).emulateTransitionEnd(s),this._element.style[r]=this._element[o]+\"px\"}}},t.hide=function(){var t=this;if(!this._isTransitioning&&$(this._element).hasClass(at)){var e=$.Event(st.HIDE);if($(this._element).trigger(e),!e.isDefaultPrevented()){var n=this._getDimension();if(this._element.style[n]=this._element.getBoundingClientRect()[n]+\"px\",gt.reflow(this._element),$(this._element).addClass(ct).removeClass(lt).removeClass(at),0<this._triggerArray.length)for(var i=0;i<this._triggerArray.length;i++){var r=this._triggerArray[i],o=gt.getSelectorFromElement(r);if(null!==o)$(o).hasClass(at)||$(r).addClass(ft).attr(\"aria-expanded\",!1)}this.setTransitioning(!0);this._element.style[n]=\"\";var s=gt.getTransitionDurationFromElement(this._element);$(this._element).one(gt.TRANSITION_END,function(){t.setTransitioning(!1),$(t._element).removeClass(ct).addClass(lt).trigger(st.HIDDEN)}).emulateTransitionEnd(s)}}},t.setTransitioning=function(t){this._isTransitioning=t},t.dispose=function(){$.removeData(this._element,et),this._config=null,this._parent=null,this._element=null,this._triggerArray=null,this._isTransitioning=null},t._getConfig=function(t){return(t=c({},rt,t)).toggle=Boolean(t.toggle),gt.typeCheckConfig(tt,t,ot),t},t._getDimension=function(){return $(this._element).hasClass(ht)?ht:ut},t._getParent=function(){var n=this,t=null;gt.isElement(this._config.parent)?(t=this._config.parent,\"undefined\"!=typeof this._config.parent.jquery&&(t=this._config.parent[0])):t=$(this._config.parent)[0];var e='[data-toggle=\"collapse\"][data-parent=\"'+this._config.parent+'\"]';return $(t).find(e).each(function(t,e){n._addAriaAndCollapsedClass(a._getTargetFromElement(e),[e])}),t},t._addAriaAndCollapsedClass=function(t,e){if(t){var n=$(t).hasClass(at);0<e.length&&$(e).toggleClass(ft,!n).attr(\"aria-expanded\",n)}},a._getTargetFromElement=function(t){var e=gt.getSelectorFromElement(t);return e?$(e)[0]:null},a._jQueryInterface=function(i){return this.each(function(){var t=$(this),e=t.data(et),n=c({},rt,t.data(),\"object\"==typeof i&&i?i:{});if(!e&&n.toggle&&/show|hide/.test(i)&&(n.toggle=!1),e||(e=new a(this,n),t.data(et,e)),\"string\"==typeof i){if(\"undefined\"==typeof e[i])throw new TypeError('No method named \"'+i+'\"');e[i]()}})},s(a,null,[{key:\"VERSION\",get:function(){return\"4.1.1\"}},{key:\"Default\",get:function(){return rt}}]),a}(),$(document).on(st.CLICK_DATA_API,dt.DATA_TOGGLE,function(t){\"A\"===t.currentTarget.tagName&&t.preventDefault();var n=$(this),e=gt.getSelectorFromElement(this);$(e).each(function(){var t=$(this),e=t.data(et)?\"toggle\":n.data();pt._jQueryInterface.call(t,e)})}),$.fn[tt]=pt._jQueryInterface,$.fn[tt].Constructor=pt,$.fn[tt].noConflict=function(){return $.fn[tt]=it,pt._jQueryInterface},pt),yt=\"undefined\"!=typeof window&&\"undefined\"!=typeof document,bt=[\"Edge\",\"Trident\",\"Firefox\"],Tt=0,Ct=0;Ct<bt.length;Ct+=1)if(yt&&0<=navigator.userAgent.indexOf(bt[Ct])){Tt=1;break}var wt=yt&&window.Promise?function(t){var e=!1;return function(){e||(e=!0,window.Promise.resolve().then(function(){e=!1,t()}))}}:function(t){var e=!1;return function(){e||(e=!0,setTimeout(function(){e=!1,t()},Tt))}};function It(t){return t&&\"[object Function]\"==={}.toString.call(t)}function Dt(t,e){if(1!==t.nodeType)return[];var n=getComputedStyle(t,null);return e?n[e]:n}function At(t){return\"HTML\"===t.nodeName?t:t.parentNode||t.host}function St(t){if(!t)return document.body;switch(t.nodeName){case\"HTML\":case\"BODY\":return t.ownerDocument.body;case\"#document\":return t.body}var e=Dt(t),n=e.overflow,i=e.overflowX,r=e.overflowY;return/(auto|scroll|overlay)/.test(n+r+i)?t:St(At(t))}var Ot=yt&&!(!window.MSInputMethodContext||!document.documentMode),Nt=yt&&/MSIE 10/.test(navigator.userAgent);function kt(t){return 11===t?Ot:10===t?Nt:Ot||Nt}function Lt(t){if(!t)return document.documentElement;for(var e=kt(10)?document.body:null,n=t.offsetParent;n===e&&t.nextElementSibling;)n=(t=t.nextElementSibling).offsetParent;var i=n&&n.nodeName;return i&&\"BODY\"!==i&&\"HTML\"!==i?-1!==[\"TD\",\"TABLE\"].indexOf(n.nodeName)&&\"static\"===Dt(n,\"position\")?Lt(n):n:t?t.ownerDocument.documentElement:document.documentElement}function Pt(t){return null!==t.parentNode?Pt(t.parentNode):t}function xt(t,e){if(!(t&&t.nodeType&&e&&e.nodeType))return document.documentElement;var n=t.compareDocumentPosition(e)&Node.DOCUMENT_POSITION_FOLLOWING,i=n?t:e,r=n?e:t,o=document.createRange();o.setStart(i,0),o.setEnd(r,0);var s,a,l=o.commonAncestorContainer;if(t!==l&&e!==l||i.contains(r))return\"BODY\"===(a=(s=l).nodeName)||\"HTML\"!==a&&Lt(s.firstElementChild)!==s?Lt(l):l;var c=Pt(t);return c.host?xt(c.host,e):xt(t,Pt(e).host)}function jt(t){var e=\"top\"===(1<arguments.length&&void 0!==arguments[1]?arguments[1]:\"top\")?\"scrollTop\":\"scrollLeft\",n=t.nodeName;if(\"BODY\"===n||\"HTML\"===n){var i=t.ownerDocument.documentElement;return(t.ownerDocument.scrollingElement||i)[e]}return t[e]}function Mt(t,e){var n=\"x\"===e?\"Left\":\"Top\",i=\"Left\"===n?\"Right\":\"Bottom\";return parseFloat(t[\"border\"+n+\"Width\"],10)+parseFloat(t[\"border\"+i+\"Width\"],10)}function Rt(t,e,n,i){return Math.max(e[\"offset\"+t],e[\"scroll\"+t],n[\"client\"+t],n[\"offset\"+t],n[\"scroll\"+t],kt(10)?n[\"offset\"+t]+i[\"margin\"+(\"Height\"===t?\"Top\":\"Left\")]+i[\"margin\"+(\"Height\"===t?\"Bottom\":\"Right\")]:0)}function Ht(){var t=document.body,e=document.documentElement,n=kt(10)&&getComputedStyle(e);return{height:Rt(\"Height\",t,e,n),width:Rt(\"Width\",t,e,n)}}var Wt=function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")},Ft=function(){function i(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,\"value\"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(t,e,n){return e&&i(t.prototype,e),n&&i(t,n),t}}(),Ut=function(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t},Bt=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])}return t};function Kt(t){return Bt({},t,{right:t.left+t.width,bottom:t.top+t.height})}function Vt(t){var e={};try{if(kt(10)){e=t.getBoundingClientRect();var n=jt(t,\"top\"),i=jt(t,\"left\");e.top+=n,e.left+=i,e.bottom+=n,e.right+=i}else e=t.getBoundingClientRect()}catch(t){}var r={left:e.left,top:e.top,width:e.right-e.left,height:e.bottom-e.top},o=\"HTML\"===t.nodeName?Ht():{},s=o.width||t.clientWidth||r.right-r.left,a=o.height||t.clientHeight||r.bottom-r.top,l=t.offsetWidth-s,c=t.offsetHeight-a;if(l||c){var f=Dt(t);l-=Mt(f,\"x\"),c-=Mt(f,\"y\"),r.width-=l,r.height-=c}return Kt(r)}function Qt(t,e){var n=2<arguments.length&&void 0!==arguments[2]&&arguments[2],i=kt(10),r=\"HTML\"===e.nodeName,o=Vt(t),s=Vt(e),a=St(t),l=Dt(e),c=parseFloat(l.borderTopWidth,10),f=parseFloat(l.borderLeftWidth,10);n&&\"HTML\"===e.nodeName&&(s.top=Math.max(s.top,0),s.left=Math.max(s.left,0));var h=Kt({top:o.top-s.top-c,left:o.left-s.left-f,width:o.width,height:o.height});if(h.marginTop=0,h.marginLeft=0,!i&&r){var u=parseFloat(l.marginTop,10),d=parseFloat(l.marginLeft,10);h.top-=c-u,h.bottom-=c-u,h.left-=f-d,h.right-=f-d,h.marginTop=u,h.marginLeft=d}return(i&&!n?e.contains(a):e===a&&\"BODY\"!==a.nodeName)&&(h=function(t,e){var n=2<arguments.length&&void 0!==arguments[2]&&arguments[2],i=jt(e,\"top\"),r=jt(e,\"left\"),o=n?-1:1;return t.top+=i*o,t.bottom+=i*o,t.left+=r*o,t.right+=r*o,t}(h,e)),h}function Yt(t){if(!t||!t.parentElement||kt())return document.documentElement;for(var e=t.parentElement;e&&\"none\"===Dt(e,\"transform\");)e=e.parentElement;return e||document.documentElement}function Gt(t,e,n,i){var r=4<arguments.length&&void 0!==arguments[4]&&arguments[4],o={top:0,left:0},s=r?Yt(t):xt(t,e);if(\"viewport\"===i)o=function(t){var e=1<arguments.length&&void 0!==arguments[1]&&arguments[1],n=t.ownerDocument.documentElement,i=Qt(t,n),r=Math.max(n.clientWidth,window.innerWidth||0),o=Math.max(n.clientHeight,window.innerHeight||0),s=e?0:jt(n),a=e?0:jt(n,\"left\");return Kt({top:s-i.top+i.marginTop,left:a-i.left+i.marginLeft,width:r,height:o})}(s,r);else{var a=void 0;\"scrollParent\"===i?\"BODY\"===(a=St(At(e))).nodeName&&(a=t.ownerDocument.documentElement):a=\"window\"===i?t.ownerDocument.documentElement:i;var l=Qt(a,s,r);if(\"HTML\"!==a.nodeName||function t(e){var n=e.nodeName;return\"BODY\"!==n&&\"HTML\"!==n&&(\"fixed\"===Dt(e,\"position\")||t(At(e)))}(s))o=l;else{var c=Ht(),f=c.height,h=c.width;o.top+=l.top-l.marginTop,o.bottom=f+l.top,o.left+=l.left-l.marginLeft,o.right=h+l.left}}return o.left+=n,o.top+=n,o.right-=n,o.bottom-=n,o}function qt(t,e,i,n,r){var o=5<arguments.length&&void 0!==arguments[5]?arguments[5]:0;if(-1===t.indexOf(\"auto\"))return t;var s=Gt(i,n,o,r),a={top:{width:s.width,height:e.top-s.top},right:{width:s.right-e.right,height:s.height},bottom:{width:s.width,height:s.bottom-e.bottom},left:{width:e.left-s.left,height:s.height}},l=Object.keys(a).map(function(t){return Bt({key:t},a[t],{area:(e=a[t],e.width*e.height)});var e}).sort(function(t,e){return e.area-t.area}),c=l.filter(function(t){var e=t.width,n=t.height;return e>=i.clientWidth&&n>=i.clientHeight}),f=0<c.length?c[0].key:l[0].key,h=t.split(\"-\")[1];return f+(h?\"-\"+h:\"\")}function zt(t,e,n){var i=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return Qt(n,i?Yt(e):xt(e,n),i)}function Xt(t){var e=getComputedStyle(t),n=parseFloat(e.marginTop)+parseFloat(e.marginBottom),i=parseFloat(e.marginLeft)+parseFloat(e.marginRight);return{width:t.offsetWidth+i,height:t.offsetHeight+n}}function Jt(t){var e={left:\"right\",right:\"left\",bottom:\"top\",top:\"bottom\"};return t.replace(/left|right|bottom|top/g,function(t){return e[t]})}function Zt(t,e,n){n=n.split(\"-\")[0];var i=Xt(t),r={width:i.width,height:i.height},o=-1!==[\"right\",\"left\"].indexOf(n),s=o?\"top\":\"left\",a=o?\"left\":\"top\",l=o?\"height\":\"width\",c=o?\"width\":\"height\";return r[s]=e[s]+e[l]/2-i[l]/2,r[a]=n===a?e[a]-i[c]:e[Jt(a)],r}function $t(t,e){return Array.prototype.find?t.find(e):t.filter(e)[0]}function te(t,n,e){return(void 0===e?t:t.slice(0,function(t,e,n){if(Array.prototype.findIndex)return t.findIndex(function(t){return t[e]===n});var i=$t(t,function(t){return t[e]===n});return t.indexOf(i)}(t,\"name\",e))).forEach(function(t){t.function&&console.warn(\"`modifier.function` is deprecated, use `modifier.fn`!\");var e=t.function||t.fn;t.enabled&&It(e)&&(n.offsets.popper=Kt(n.offsets.popper),n.offsets.reference=Kt(n.offsets.reference),n=e(n,t))}),n}function ee(t,n){return t.some(function(t){var e=t.name;return t.enabled&&e===n})}function ne(t){for(var e=[!1,\"ms\",\"Webkit\",\"Moz\",\"O\"],n=t.charAt(0).toUpperCase()+t.slice(1),i=0;i<e.length;i++){var r=e[i],o=r?\"\"+r+n:t;if(\"undefined\"!=typeof document.body.style[o])return o}return null}function ie(t){var e=t.ownerDocument;return e?e.defaultView:window}function re(t,e,n,i){n.updateBound=i,ie(t).addEventListener(\"resize\",n.updateBound,{passive:!0});var r=St(t);return function t(e,n,i,r){var o=\"BODY\"===e.nodeName,s=o?e.ownerDocument.defaultView:e;s.addEventListener(n,i,{passive:!0}),o||t(St(s.parentNode),n,i,r),r.push(s)}(r,\"scroll\",n.updateBound,n.scrollParents),n.scrollElement=r,n.eventsEnabled=!0,n}function oe(){var t,e;this.state.eventsEnabled&&(cancelAnimationFrame(this.scheduleUpdate),this.state=(t=this.reference,e=this.state,ie(t).removeEventListener(\"resize\",e.updateBound),e.scrollParents.forEach(function(t){t.removeEventListener(\"scroll\",e.updateBound)}),e.updateBound=null,e.scrollParents=[],e.scrollElement=null,e.eventsEnabled=!1,e))}function se(t){return\"\"!==t&&!isNaN(parseFloat(t))&&isFinite(t)}function ae(n,i){Object.keys(i).forEach(function(t){var e=\"\";-1!==[\"width\",\"height\",\"top\",\"right\",\"bottom\",\"left\"].indexOf(t)&&se(i[t])&&(e=\"px\"),n.style[t]=i[t]+e})}function le(t,e,n){var i=$t(t,function(t){return t.name===e}),r=!!i&&t.some(function(t){return t.name===n&&t.enabled&&t.order<i.order});if(!r){var o=\"`\"+e+\"`\",s=\"`\"+n+\"`\";console.warn(s+\" modifier is required by \"+o+\" modifier in order to work, be sure to include it before \"+o+\"!\")}return r}var ce=[\"auto-start\",\"auto\",\"auto-end\",\"top-start\",\"top\",\"top-end\",\"right-start\",\"right\",\"right-end\",\"bottom-end\",\"bottom\",\"bottom-start\",\"left-end\",\"left\",\"left-start\"],fe=ce.slice(3);function he(t){var e=1<arguments.length&&void 0!==arguments[1]&&arguments[1],n=fe.indexOf(t),i=fe.slice(n+1).concat(fe.slice(0,n));return e?i.reverse():i}var ue={FLIP:\"flip\",CLOCKWISE:\"clockwise\",COUNTERCLOCKWISE:\"counterclockwise\"};function de(t,r,o,e){var s=[0,0],a=-1!==[\"right\",\"left\"].indexOf(e),n=t.split(/(\\+|\\-)/).map(function(t){return t.trim()}),i=n.indexOf($t(n,function(t){return-1!==t.search(/,|\\s/)}));n[i]&&-1===n[i].indexOf(\",\")&&console.warn(\"Offsets separated by white space(s) are deprecated, use a comma (,) instead.\");var l=/\\s*,\\s*|\\s+/,c=-1!==i?[n.slice(0,i).concat([n[i].split(l)[0]]),[n[i].split(l)[1]].concat(n.slice(i+1))]:[n];return(c=c.map(function(t,e){var n=(1===e?!a:a)?\"height\":\"width\",i=!1;return t.reduce(function(t,e){return\"\"===t[t.length-1]&&-1!==[\"+\",\"-\"].indexOf(e)?(t[t.length-1]=e,i=!0,t):i?(t[t.length-1]+=e,i=!1,t):t.concat(e)},[]).map(function(t){return function(t,e,n,i){var r=t.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/),o=+r[1],s=r[2];if(!o)return t;if(0===s.indexOf(\"%\")){var a=void 0;switch(s){case\"%p\":a=n;break;case\"%\":case\"%r\":default:a=i}return Kt(a)[e]/100*o}if(\"vh\"===s||\"vw\"===s)return(\"vh\"===s?Math.max(document.documentElement.clientHeight,window.innerHeight||0):Math.max(document.documentElement.clientWidth,window.innerWidth||0))/100*o;return o}(t,n,r,o)})})).forEach(function(n,i){n.forEach(function(t,e){se(t)&&(s[i]+=t*(\"-\"===n[e-1]?-1:1))})}),s}var pe={placement:\"bottom\",positionFixed:!1,eventsEnabled:!0,removeOnDestroy:!1,onCreate:function(){},onUpdate:function(){},modifiers:{shift:{order:100,enabled:!0,fn:function(t){var e=t.placement,n=e.split(\"-\")[0],i=e.split(\"-\")[1];if(i){var r=t.offsets,o=r.reference,s=r.popper,a=-1!==[\"bottom\",\"top\"].indexOf(n),l=a?\"left\":\"top\",c=a?\"width\":\"height\",f={start:Ut({},l,o[l]),end:Ut({},l,o[l]+o[c]-s[c])};t.offsets.popper=Bt({},s,f[i])}return t}},offset:{order:200,enabled:!0,fn:function(t,e){var n=e.offset,i=t.placement,r=t.offsets,o=r.popper,s=r.reference,a=i.split(\"-\")[0],l=void 0;return l=se(+n)?[+n,0]:de(n,o,s,a),\"left\"===a?(o.top+=l[0],o.left-=l[1]):\"right\"===a?(o.top+=l[0],o.left+=l[1]):\"top\"===a?(o.left+=l[0],o.top-=l[1]):\"bottom\"===a&&(o.left+=l[0],o.top+=l[1]),t.popper=o,t},offset:0},preventOverflow:{order:300,enabled:!0,fn:function(t,i){var e=i.boundariesElement||Lt(t.instance.popper);t.instance.reference===e&&(e=Lt(e));var n=ne(\"transform\"),r=t.instance.popper.style,o=r.top,s=r.left,a=r[n];r.top=\"\",r.left=\"\",r[n]=\"\";var l=Gt(t.instance.popper,t.instance.reference,i.padding,e,t.positionFixed);r.top=o,r.left=s,r[n]=a,i.boundaries=l;var c=i.priority,f=t.offsets.popper,h={primary:function(t){var e=f[t];return f[t]<l[t]&&!i.escapeWithReference&&(e=Math.max(f[t],l[t])),Ut({},t,e)},secondary:function(t){var e=\"right\"===t?\"left\":\"top\",n=f[e];return f[t]>l[t]&&!i.escapeWithReference&&(n=Math.min(f[e],l[t]-(\"right\"===t?f.width:f.height))),Ut({},e,n)}};return c.forEach(function(t){var e=-1!==[\"left\",\"top\"].indexOf(t)?\"primary\":\"secondary\";f=Bt({},f,h[e](t))}),t.offsets.popper=f,t},priority:[\"left\",\"right\",\"top\",\"bottom\"],padding:5,boundariesElement:\"scrollParent\"},keepTogether:{order:400,enabled:!0,fn:function(t){var e=t.offsets,n=e.popper,i=e.reference,r=t.placement.split(\"-\")[0],o=Math.floor,s=-1!==[\"top\",\"bottom\"].indexOf(r),a=s?\"right\":\"bottom\",l=s?\"left\":\"top\",c=s?\"width\":\"height\";return n[a]<o(i[l])&&(t.offsets.popper[l]=o(i[l])-n[c]),n[l]>o(i[a])&&(t.offsets.popper[l]=o(i[a])),t}},arrow:{order:500,enabled:!0,fn:function(t,e){var n;if(!le(t.instance.modifiers,\"arrow\",\"keepTogether\"))return t;var i=e.element;if(\"string\"==typeof i){if(!(i=t.instance.popper.querySelector(i)))return t}else if(!t.instance.popper.contains(i))return console.warn(\"WARNING: `arrow.element` must be child of its popper element!\"),t;var r=t.placement.split(\"-\")[0],o=t.offsets,s=o.popper,a=o.reference,l=-1!==[\"left\",\"right\"].indexOf(r),c=l?\"height\":\"width\",f=l?\"Top\":\"Left\",h=f.toLowerCase(),u=l?\"left\":\"top\",d=l?\"bottom\":\"right\",p=Xt(i)[c];a[d]-p<s[h]&&(t.offsets.popper[h]-=s[h]-(a[d]-p)),a[h]+p>s[d]&&(t.offsets.popper[h]+=a[h]+p-s[d]),t.offsets.popper=Kt(t.offsets.popper);var g=a[h]+a[c]/2-p/2,m=Dt(t.instance.popper),_=parseFloat(m[\"margin\"+f],10),v=parseFloat(m[\"border\"+f+\"Width\"],10),E=g-t.offsets.popper[h]-_-v;return E=Math.max(Math.min(s[c]-p,E),0),t.arrowElement=i,t.offsets.arrow=(Ut(n={},h,Math.round(E)),Ut(n,u,\"\"),n),t},element:\"[x-arrow]\"},flip:{order:600,enabled:!0,fn:function(p,g){if(ee(p.instance.modifiers,\"inner\"))return p;if(p.flipped&&p.placement===p.originalPlacement)return p;var m=Gt(p.instance.popper,p.instance.reference,g.padding,g.boundariesElement,p.positionFixed),_=p.placement.split(\"-\")[0],v=Jt(_),E=p.placement.split(\"-\")[1]||\"\",y=[];switch(g.behavior){case ue.FLIP:y=[_,v];break;case ue.CLOCKWISE:y=he(_);break;case ue.COUNTERCLOCKWISE:y=he(_,!0);break;default:y=g.behavior}return y.forEach(function(t,e){if(_!==t||y.length===e+1)return p;_=p.placement.split(\"-\")[0],v=Jt(_);var n,i=p.offsets.popper,r=p.offsets.reference,o=Math.floor,s=\"left\"===_&&o(i.right)>o(r.left)||\"right\"===_&&o(i.left)<o(r.right)||\"top\"===_&&o(i.bottom)>o(r.top)||\"bottom\"===_&&o(i.top)<o(r.bottom),a=o(i.left)<o(m.left),l=o(i.right)>o(m.right),c=o(i.top)<o(m.top),f=o(i.bottom)>o(m.bottom),h=\"left\"===_&&a||\"right\"===_&&l||\"top\"===_&&c||\"bottom\"===_&&f,u=-1!==[\"top\",\"bottom\"].indexOf(_),d=!!g.flipVariations&&(u&&\"start\"===E&&a||u&&\"end\"===E&&l||!u&&\"start\"===E&&c||!u&&\"end\"===E&&f);(s||h||d)&&(p.flipped=!0,(s||h)&&(_=y[e+1]),d&&(E=\"end\"===(n=E)?\"start\":\"start\"===n?\"end\":n),p.placement=_+(E?\"-\"+E:\"\"),p.offsets.popper=Bt({},p.offsets.popper,Zt(p.instance.popper,p.offsets.reference,p.placement)),p=te(p.instance.modifiers,p,\"flip\"))}),p},behavior:\"flip\",padding:5,boundariesElement:\"viewport\"},inner:{order:700,enabled:!1,fn:function(t){var e=t.placement,n=e.split(\"-\")[0],i=t.offsets,r=i.popper,o=i.reference,s=-1!==[\"left\",\"right\"].indexOf(n),a=-1===[\"top\",\"left\"].indexOf(n);return r[s?\"left\":\"top\"]=o[n]-(a?r[s?\"width\":\"height\"]:0),t.placement=Jt(e),t.offsets.popper=Kt(r),t}},hide:{order:800,enabled:!0,fn:function(t){if(!le(t.instance.modifiers,\"hide\",\"preventOverflow\"))return t;var e=t.offsets.reference,n=$t(t.instance.modifiers,function(t){return\"preventOverflow\"===t.name}).boundaries;if(e.bottom<n.top||e.left>n.right||e.top>n.bottom||e.right<n.left){if(!0===t.hide)return t;t.hide=!0,t.attributes[\"x-out-of-boundaries\"]=\"\"}else{if(!1===t.hide)return t;t.hide=!1,t.attributes[\"x-out-of-boundaries\"]=!1}return t}},computeStyle:{order:850,enabled:!0,fn:function(t,e){var n=e.x,i=e.y,r=t.offsets.popper,o=$t(t.instance.modifiers,function(t){return\"applyStyle\"===t.name}).gpuAcceleration;void 0!==o&&console.warn(\"WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!\");var s=void 0!==o?o:e.gpuAcceleration,a=Vt(Lt(t.instance.popper)),l={position:r.position},c={left:Math.floor(r.left),top:Math.round(r.top),bottom:Math.round(r.bottom),right:Math.floor(r.right)},f=\"bottom\"===n?\"top\":\"bottom\",h=\"right\"===i?\"left\":\"right\",u=ne(\"transform\"),d=void 0,p=void 0;if(p=\"bottom\"===f?-a.height+c.bottom:c.top,d=\"right\"===h?-a.width+c.right:c.left,s&&u)l[u]=\"translate3d(\"+d+\"px, \"+p+\"px, 0)\",l[f]=0,l[h]=0,l.willChange=\"transform\";else{var g=\"bottom\"===f?-1:1,m=\"right\"===h?-1:1;l[f]=p*g,l[h]=d*m,l.willChange=f+\", \"+h}var _={\"x-placement\":t.placement};return t.attributes=Bt({},_,t.attributes),t.styles=Bt({},l,t.styles),t.arrowStyles=Bt({},t.offsets.arrow,t.arrowStyles),t},gpuAcceleration:!0,x:\"bottom\",y:\"right\"},applyStyle:{order:900,enabled:!0,fn:function(t){var e,n;return ae(t.instance.popper,t.styles),e=t.instance.popper,n=t.attributes,Object.keys(n).forEach(function(t){!1!==n[t]?e.setAttribute(t,n[t]):e.removeAttribute(t)}),t.arrowElement&&Object.keys(t.arrowStyles).length&&ae(t.arrowElement,t.arrowStyles),t},onLoad:function(t,e,n,i,r){var o=zt(r,e,t,n.positionFixed),s=qt(n.placement,o,e,t,n.modifiers.flip.boundariesElement,n.modifiers.flip.padding);return e.setAttribute(\"x-placement\",s),ae(e,{position:n.positionFixed?\"fixed\":\"absolute\"}),n},gpuAcceleration:void 0}}},ge=function(){function o(t,e){var n=this,i=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};Wt(this,o),this.scheduleUpdate=function(){return requestAnimationFrame(n.update)},this.update=wt(this.update.bind(this)),this.options=Bt({},o.Defaults,i),this.state={isDestroyed:!1,isCreated:!1,scrollParents:[]},this.reference=t&&t.jquery?t[0]:t,this.popper=e&&e.jquery?e[0]:e,this.options.modifiers={},Object.keys(Bt({},o.Defaults.modifiers,i.modifiers)).forEach(function(t){n.options.modifiers[t]=Bt({},o.Defaults.modifiers[t]||{},i.modifiers?i.modifiers[t]:{})}),this.modifiers=Object.keys(this.options.modifiers).map(function(t){return Bt({name:t},n.options.modifiers[t])}).sort(function(t,e){return t.order-e.order}),this.modifiers.forEach(function(t){t.enabled&&It(t.onLoad)&&t.onLoad(n.reference,n.popper,n.options,t,n.state)}),this.update();var r=this.options.eventsEnabled;r&&this.enableEventListeners(),this.state.eventsEnabled=r}return Ft(o,[{key:\"update\",value:function(){return function(){if(!this.state.isDestroyed){var t={instance:this,styles:{},arrowStyles:{},attributes:{},flipped:!1,offsets:{}};t.offsets.reference=zt(this.state,this.popper,this.reference,this.options.positionFixed),t.placement=qt(this.options.placement,t.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding),t.originalPlacement=t.placement,t.positionFixed=this.options.positionFixed,t.offsets.popper=Zt(this.popper,t.offsets.reference,t.placement),t.offsets.popper.position=this.options.positionFixed?\"fixed\":\"absolute\",t=te(this.modifiers,t),this.state.isCreated?this.options.onUpdate(t):(this.state.isCreated=!0,this.options.onCreate(t))}}.call(this)}},{key:\"destroy\",value:function(){return function(){return this.state.isDestroyed=!0,ee(this.modifiers,\"applyStyle\")&&(this.popper.removeAttribute(\"x-placement\"),this.popper.style.position=\"\",this.popper.style.top=\"\",this.popper.style.left=\"\",this.popper.style.right=\"\",this.popper.style.bottom=\"\",this.popper.style.willChange=\"\",this.popper.style[ne(\"transform\")]=\"\"),this.disableEventListeners(),this.options.removeOnDestroy&&this.popper.parentNode.removeChild(this.popper),this}.call(this)}},{key:\"enableEventListeners\",value:function(){return function(){this.state.eventsEnabled||(this.state=re(this.reference,this.options,this.state,this.scheduleUpdate))}.call(this)}},{key:\"disableEventListeners\",value:function(){return oe.call(this)}}]),o}();ge.Utils=(\"undefined\"!=typeof window?window:global).PopperUtils,ge.placements=ce,ge.Defaults=pe;var me,_e,ve,Ee,ye,be,Te,Ce,we,Ie,De,Ae,Se,Oe,Ne,ke,Le,Pe,xe,je,Me,Re,He,We,Fe,Ue,Be,Ke,Ve,Qe,Ye,Ge,qe,ze,Xe,Je,Ze,$e,tn,en,nn,rn,on,sn,an,ln,cn,fn,hn,un,dn,pn,gn,mn,_n,vn,En,yn,bn,Tn,Cn,wn,In,Dn,An,Sn,On,Nn,kn,Ln,Pn,xn,jn,Mn,Rn,Hn,Wn,Fn,Un,Bn,Kn,Vn,Qn,Yn,Gn,qn,zn,Xn,Jn,Zn,$n,ti,ei,ni,ii,ri,oi,si,ai,li,ci,fi,hi,ui,di,pi,gi,mi,_i,vi,Ei,yi,bi,Ti=(_e=\"dropdown\",Ee=\".\"+(ve=\"bs.dropdown\"),ye=\".data-api\",be=(me=e).fn[_e],Te=new RegExp(\"38|40|27\"),Ce={HIDE:\"hide\"+Ee,HIDDEN:\"hidden\"+Ee,SHOW:\"show\"+Ee,SHOWN:\"shown\"+Ee,CLICK:\"click\"+Ee,CLICK_DATA_API:\"click\"+Ee+ye,KEYDOWN_DATA_API:\"keydown\"+Ee+ye,KEYUP_DATA_API:\"keyup\"+Ee+ye},we=\"disabled\",Ie=\"show\",De=\"dropup\",Ae=\"dropright\",Se=\"dropleft\",Oe=\"dropdown-menu-right\",Ne=\"position-static\",ke='[data-toggle=\"dropdown\"]',Le=\".dropdown form\",Pe=\".dropdown-menu\",xe=\".navbar-nav\",je=\".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)\",Me=\"top-start\",Re=\"top-end\",He=\"bottom-start\",We=\"bottom-end\",Fe=\"right-start\",Ue=\"left-start\",Be={offset:0,flip:!0,boundary:\"scrollParent\",reference:\"toggle\",display:\"dynamic\"},Ke={offset:\"(number|string|function)\",flip:\"boolean\",boundary:\"(string|element)\",reference:\"(string|element)\",display:\"string\"},Ve=function(){function l(t,e){this._element=t,this._popper=null,this._config=this._getConfig(e),this._menu=this._getMenuElement(),this._inNavbar=this._detectNavbar(),this._addEventListeners()}var t=l.prototype;return t.toggle=function(){if(!this._element.disabled&&!me(this._element).hasClass(we)){var t=l._getParentFromElement(this._element),e=me(this._menu).hasClass(Ie);if(l._clearMenus(),!e){var n={relatedTarget:this._element},i=me.Event(Ce.SHOW,n);if(me(t).trigger(i),!i.isDefaultPrevented()){if(!this._inNavbar){if(\"undefined\"==typeof ge)throw new TypeError(\"Bootstrap dropdown require Popper.js (https://popper.js.org)\");var r=this._element;\"parent\"===this._config.reference?r=t:gt.isElement(this._config.reference)&&(r=this._config.reference,\"undefined\"!=typeof this._config.reference.jquery&&(r=this._config.reference[0])),\"scrollParent\"!==this._config.boundary&&me(t).addClass(Ne),this._popper=new ge(r,this._menu,this._getPopperConfig())}\"ontouchstart\"in document.documentElement&&0===me(t).closest(xe).length&&me(document.body).children().on(\"mouseover\",null,me.noop),this._element.focus(),this._element.setAttribute(\"aria-expanded\",!0),me(this._menu).toggleClass(Ie),me(t).toggleClass(Ie).trigger(me.Event(Ce.SHOWN,n))}}}},t.dispose=function(){me.removeData(this._element,ve),me(this._element).off(Ee),this._element=null,(this._menu=null)!==this._popper&&(this._popper.destroy(),this._popper=null)},t.update=function(){this._inNavbar=this._detectNavbar(),null!==this._popper&&this._popper.scheduleUpdate()},t._addEventListeners=function(){var e=this;me(this._element).on(Ce.CLICK,function(t){t.preventDefault(),t.stopPropagation(),e.toggle()})},t._getConfig=function(t){return t=c({},this.constructor.Default,me(this._element).data(),t),gt.typeCheckConfig(_e,t,this.constructor.DefaultType),t},t._getMenuElement=function(){if(!this._menu){var t=l._getParentFromElement(this._element);this._menu=me(t).find(Pe)[0]}return this._menu},t._getPlacement=function(){var t=me(this._element).parent(),e=He;return t.hasClass(De)?(e=Me,me(this._menu).hasClass(Oe)&&(e=Re)):t.hasClass(Ae)?e=Fe:t.hasClass(Se)?e=Ue:me(this._menu).hasClass(Oe)&&(e=We),e},t._detectNavbar=function(){return 0<me(this._element).closest(\".navbar\").length},t._getPopperConfig=function(){var e=this,t={};\"function\"==typeof this._config.offset?t.fn=function(t){return t.offsets=c({},t.offsets,e._config.offset(t.offsets)||{}),t}:t.offset=this._config.offset;var n={placement:this._getPlacement(),modifiers:{offset:t,flip:{enabled:this._config.flip},preventOverflow:{boundariesElement:this._config.boundary}}};return\"static\"===this._config.display&&(n.modifiers.applyStyle={enabled:!1}),n},l._jQueryInterface=function(e){return this.each(function(){var t=me(this).data(ve);if(t||(t=new l(this,\"object\"==typeof e?e:null),me(this).data(ve,t)),\"string\"==typeof e){if(\"undefined\"==typeof t[e])throw new TypeError('No method named \"'+e+'\"');t[e]()}})},l._clearMenus=function(t){if(!t||3!==t.which&&(\"keyup\"!==t.type||9===t.which))for(var e=me.makeArray(me(ke)),n=0;n<e.length;n++){var i=l._getParentFromElement(e[n]),r=me(e[n]).data(ve),o={relatedTarget:e[n]};if(r){var s=r._menu;if(me(i).hasClass(Ie)&&!(t&&(\"click\"===t.type&&/input|textarea/i.test(t.target.tagName)||\"keyup\"===t.type&&9===t.which)&&me.contains(i,t.target))){var a=me.Event(Ce.HIDE,o);me(i).trigger(a),a.isDefaultPrevented()||(\"ontouchstart\"in document.documentElement&&me(document.body).children().off(\"mouseover\",null,me.noop),e[n].setAttribute(\"aria-expanded\",\"false\"),me(s).removeClass(Ie),me(i).removeClass(Ie).trigger(me.Event(Ce.HIDDEN,o)))}}}},l._getParentFromElement=function(t){var e,n=gt.getSelectorFromElement(t);return n&&(e=me(n)[0]),e||t.parentNode},l._dataApiKeydownHandler=function(t){if((/input|textarea/i.test(t.target.tagName)?!(32===t.which||27!==t.which&&(40!==t.which&&38!==t.which||me(t.target).closest(Pe).length)):Te.test(t.which))&&(t.preventDefault(),t.stopPropagation(),!this.disabled&&!me(this).hasClass(we))){var e=l._getParentFromElement(this),n=me(e).hasClass(Ie);if((n||27===t.which&&32===t.which)&&(!n||27!==t.which&&32!==t.which)){var i=me(e).find(je).get();if(0!==i.length){var r=i.indexOf(t.target);38===t.which&&0<r&&r--,40===t.which&&r<i.length-1&&r++,r<0&&(r=0),i[r].focus()}}else{if(27===t.which){var o=me(e).find(ke)[0];me(o).trigger(\"focus\")}me(this).trigger(\"click\")}}},s(l,null,[{key:\"VERSION\",get:function(){return\"4.1.1\"}},{key:\"Default\",get:function(){return Be}},{key:\"DefaultType\",get:function(){return Ke}}]),l}(),me(document).on(Ce.KEYDOWN_DATA_API,ke,Ve._dataApiKeydownHandler).on(Ce.KEYDOWN_DATA_API,Pe,Ve._dataApiKeydownHandler).on(Ce.CLICK_DATA_API+\" \"+Ce.KEYUP_DATA_API,Ve._clearMenus).on(Ce.CLICK_DATA_API,ke,function(t){t.preventDefault(),t.stopPropagation(),Ve._jQueryInterface.call(me(this),\"toggle\")}).on(Ce.CLICK_DATA_API,Le,function(t){t.stopPropagation()}),me.fn[_e]=Ve._jQueryInterface,me.fn[_e].Constructor=Ve,me.fn[_e].noConflict=function(){return me.fn[_e]=be,Ve._jQueryInterface},Ve),Ci=(Ye=\"modal\",qe=\".\"+(Ge=\"bs.modal\"),ze=(Qe=e).fn[Ye],Xe={backdrop:!0,keyboard:!0,focus:!0,show:!0},Je={backdrop:\"(boolean|string)\",keyboard:\"boolean\",focus:\"boolean\",show:\"boolean\"},Ze={HIDE:\"hide\"+qe,HIDDEN:\"hidden\"+qe,SHOW:\"show\"+qe,SHOWN:\"shown\"+qe,FOCUSIN:\"focusin\"+qe,RESIZE:\"resize\"+qe,CLICK_DISMISS:\"click.dismiss\"+qe,KEYDOWN_DISMISS:\"keydown.dismiss\"+qe,MOUSEUP_DISMISS:\"mouseup.dismiss\"+qe,MOUSEDOWN_DISMISS:\"mousedown.dismiss\"+qe,CLICK_DATA_API:\"click\"+qe+\".data-api\"},$e=\"modal-scrollbar-measure\",tn=\"modal-backdrop\",en=\"modal-open\",nn=\"fade\",rn=\"show\",on={DIALOG:\".modal-dialog\",DATA_TOGGLE:'[data-toggle=\"modal\"]',DATA_DISMISS:'[data-dismiss=\"modal\"]',FIXED_CONTENT:\".fixed-top, .fixed-bottom, .is-fixed, .sticky-top\",STICKY_CONTENT:\".sticky-top\",NAVBAR_TOGGLER:\".navbar-toggler\"},sn=function(){function r(t,e){this._config=this._getConfig(e),this._element=t,this._dialog=Qe(t).find(on.DIALOG)[0],this._backdrop=null,this._isShown=!1,this._isBodyOverflowing=!1,this._ignoreBackdropClick=!1,this._scrollbarWidth=0}var t=r.prototype;return t.toggle=function(t){return this._isShown?this.hide():this.show(t)},t.show=function(t){var e=this;if(!this._isTransitioning&&!this._isShown){Qe(this._element).hasClass(nn)&&(this._isTransitioning=!0);var n=Qe.Event(Ze.SHOW,{relatedTarget:t});Qe(this._element).trigger(n),this._isShown||n.isDefaultPrevented()||(this._isShown=!0,this._checkScrollbar(),this._setScrollbar(),this._adjustDialog(),Qe(document.body).addClass(en),this._setEscapeEvent(),this._setResizeEvent(),Qe(this._element).on(Ze.CLICK_DISMISS,on.DATA_DISMISS,function(t){return e.hide(t)}),Qe(this._dialog).on(Ze.MOUSEDOWN_DISMISS,function(){Qe(e._element).one(Ze.MOUSEUP_DISMISS,function(t){Qe(t.target).is(e._element)&&(e._ignoreBackdropClick=!0)})}),this._showBackdrop(function(){return e._showElement(t)}))}},t.hide=function(t){var e=this;if(t&&t.preventDefault(),!this._isTransitioning&&this._isShown){var n=Qe.Event(Ze.HIDE);if(Qe(this._element).trigger(n),this._isShown&&!n.isDefaultPrevented()){this._isShown=!1;var i=Qe(this._element).hasClass(nn);if(i&&(this._isTransitioning=!0),this._setEscapeEvent(),this._setResizeEvent(),Qe(document).off(Ze.FOCUSIN),Qe(this._element).removeClass(rn),Qe(this._element).off(Ze.CLICK_DISMISS),Qe(this._dialog).off(Ze.MOUSEDOWN_DISMISS),i){var r=gt.getTransitionDurationFromElement(this._element);Qe(this._element).one(gt.TRANSITION_END,function(t){return e._hideModal(t)}).emulateTransitionEnd(r)}else this._hideModal()}}},t.dispose=function(){Qe.removeData(this._element,Ge),Qe(window,document,this._element,this._backdrop).off(qe),this._config=null,this._element=null,this._dialog=null,this._backdrop=null,this._isShown=null,this._isBodyOverflowing=null,this._ignoreBackdropClick=null,this._scrollbarWidth=null},t.handleUpdate=function(){this._adjustDialog()},t._getConfig=function(t){return t=c({},Xe,t),gt.typeCheckConfig(Ye,t,Je),t},t._showElement=function(t){var e=this,n=Qe(this._element).hasClass(nn);this._element.parentNode&&this._element.parentNode.nodeType===Node.ELEMENT_NODE||document.body.appendChild(this._element),this._element.style.display=\"block\",this._element.removeAttribute(\"aria-hidden\"),this._element.scrollTop=0,n&&gt.reflow(this._element),Qe(this._element).addClass(rn),this._config.focus&&this._enforceFocus();var i=Qe.Event(Ze.SHOWN,{relatedTarget:t}),r=function(){e._config.focus&&e._element.focus(),e._isTransitioning=!1,Qe(e._element).trigger(i)};if(n){var o=gt.getTransitionDurationFromElement(this._element);Qe(this._dialog).one(gt.TRANSITION_END,r).emulateTransitionEnd(o)}else r()},t._enforceFocus=function(){var e=this;Qe(document).off(Ze.FOCUSIN).on(Ze.FOCUSIN,function(t){document!==t.target&&e._element!==t.target&&0===Qe(e._element).has(t.target).length&&e._element.focus()})},t._setEscapeEvent=function(){var e=this;this._isShown&&this._config.keyboard?Qe(this._element).on(Ze.KEYDOWN_DISMISS,function(t){27===t.which&&(t.preventDefault(),e.hide())}):this._isShown||Qe(this._element).off(Ze.KEYDOWN_DISMISS)},t._setResizeEvent=function(){var e=this;this._isShown?Qe(window).on(Ze.RESIZE,function(t){return e.handleUpdate(t)}):Qe(window).off(Ze.RESIZE)},t._hideModal=function(){var t=this;this._element.style.display=\"none\",this._element.setAttribute(\"aria-hidden\",!0),this._isTransitioning=!1,this._showBackdrop(function(){Qe(document.body).removeClass(en),t._resetAdjustments(),t._resetScrollbar(),Qe(t._element).trigger(Ze.HIDDEN)})},t._removeBackdrop=function(){this._backdrop&&(Qe(this._backdrop).remove(),this._backdrop=null)},t._showBackdrop=function(t){var e=this,n=Qe(this._element).hasClass(nn)?nn:\"\";if(this._isShown&&this._config.backdrop){if(this._backdrop=document.createElement(\"div\"),this._backdrop.className=tn,n&&Qe(this._backdrop).addClass(n),Qe(this._backdrop).appendTo(document.body),Qe(this._element).on(Ze.CLICK_DISMISS,function(t){e._ignoreBackdropClick?e._ignoreBackdropClick=!1:t.target===t.currentTarget&&(\"static\"===e._config.backdrop?e._element.focus():e.hide())}),n&&gt.reflow(this._backdrop),Qe(this._backdrop).addClass(rn),!t)return;if(!n)return void t();var i=gt.getTransitionDurationFromElement(this._backdrop);Qe(this._backdrop).one(gt.TRANSITION_END,t).emulateTransitionEnd(i)}else if(!this._isShown&&this._backdrop){Qe(this._backdrop).removeClass(rn);var r=function(){e._removeBackdrop(),t&&t()};if(Qe(this._element).hasClass(nn)){var o=gt.getTransitionDurationFromElement(this._backdrop);Qe(this._backdrop).one(gt.TRANSITION_END,r).emulateTransitionEnd(o)}else r()}else t&&t()},t._adjustDialog=function(){var t=this._element.scrollHeight>document.documentElement.clientHeight;!this._isBodyOverflowing&&t&&(this._element.style.paddingLeft=this._scrollbarWidth+\"px\"),this._isBodyOverflowing&&!t&&(this._element.style.paddingRight=this._scrollbarWidth+\"px\")},t._resetAdjustments=function(){this._element.style.paddingLeft=\"\",this._element.style.paddingRight=\"\"},t._checkScrollbar=function(){var t=document.body.getBoundingClientRect();this._isBodyOverflowing=t.left+t.right<window.innerWidth,this._scrollbarWidth=this._getScrollbarWidth()},t._setScrollbar=function(){var r=this;if(this._isBodyOverflowing){Qe(on.FIXED_CONTENT).each(function(t,e){var n=Qe(e)[0].style.paddingRight,i=Qe(e).css(\"padding-right\");Qe(e).data(\"padding-right\",n).css(\"padding-right\",parseFloat(i)+r._scrollbarWidth+\"px\")}),Qe(on.STICKY_CONTENT).each(function(t,e){var n=Qe(e)[0].style.marginRight,i=Qe(e).css(\"margin-right\");Qe(e).data(\"margin-right\",n).css(\"margin-right\",parseFloat(i)-r._scrollbarWidth+\"px\")}),Qe(on.NAVBAR_TOGGLER).each(function(t,e){var n=Qe(e)[0].style.marginRight,i=Qe(e).css(\"margin-right\");Qe(e).data(\"margin-right\",n).css(\"margin-right\",parseFloat(i)+r._scrollbarWidth+\"px\")});var t=document.body.style.paddingRight,e=Qe(document.body).css(\"padding-right\");Qe(document.body).data(\"padding-right\",t).css(\"padding-right\",parseFloat(e)+this._scrollbarWidth+\"px\")}},t._resetScrollbar=function(){Qe(on.FIXED_CONTENT).each(function(t,e){var n=Qe(e).data(\"padding-right\");\"undefined\"!=typeof n&&Qe(e).css(\"padding-right\",n).removeData(\"padding-right\")}),Qe(on.STICKY_CONTENT+\", \"+on.NAVBAR_TOGGLER).each(function(t,e){var n=Qe(e).data(\"margin-right\");\"undefined\"!=typeof n&&Qe(e).css(\"margin-right\",n).removeData(\"margin-right\")});var t=Qe(document.body).data(\"padding-right\");\"undefined\"!=typeof t&&Qe(document.body).css(\"padding-right\",t).removeData(\"padding-right\")},t._getScrollbarWidth=function(){var t=document.createElement(\"div\");t.className=$e,document.body.appendChild(t);var e=t.getBoundingClientRect().width-t.clientWidth;return document.body.removeChild(t),e},r._jQueryInterface=function(n,i){return this.each(function(){var t=Qe(this).data(Ge),e=c({},Xe,Qe(this).data(),\"object\"==typeof n&&n?n:{});if(t||(t=new r(this,e),Qe(this).data(Ge,t)),\"string\"==typeof n){if(\"undefined\"==typeof t[n])throw new TypeError('No method named \"'+n+'\"');t[n](i)}else e.show&&t.show(i)})},s(r,null,[{key:\"VERSION\",get:function(){return\"4.1.1\"}},{key:\"Default\",get:function(){return Xe}}]),r}(),Qe(document).on(Ze.CLICK_DATA_API,on.DATA_TOGGLE,function(t){var e,n=this,i=gt.getSelectorFromElement(this);i&&(e=Qe(i)[0]);var r=Qe(e).data(Ge)?\"toggle\":c({},Qe(e).data(),Qe(this).data());\"A\"!==this.tagName&&\"AREA\"!==this.tagName||t.preventDefault();var o=Qe(e).one(Ze.SHOW,function(t){t.isDefaultPrevented()||o.one(Ze.HIDDEN,function(){Qe(n).is(\":visible\")&&n.focus()})});sn._jQueryInterface.call(Qe(e),r,this)}),Qe.fn[Ye]=sn._jQueryInterface,Qe.fn[Ye].Constructor=sn,Qe.fn[Ye].noConflict=function(){return Qe.fn[Ye]=ze,sn._jQueryInterface},sn),wi=(ln=\"tooltip\",fn=\".\"+(cn=\"bs.tooltip\"),hn=(an=e).fn[ln],un=\"bs-tooltip\",dn=new RegExp(\"(^|\\\\s)\"+un+\"\\\\S+\",\"g\"),mn={animation:!0,template:'<div class=\"tooltip\" role=\"tooltip\"><div class=\"arrow\"></div><div class=\"tooltip-inner\"></div></div>',trigger:\"hover focus\",title:\"\",delay:0,html:!(gn={AUTO:\"auto\",TOP:\"top\",RIGHT:\"right\",BOTTOM:\"bottom\",LEFT:\"left\"}),selector:!(pn={animation:\"boolean\",template:\"string\",title:\"(string|element|function)\",trigger:\"string\",delay:\"(number|object)\",html:\"boolean\",selector:\"(string|boolean)\",placement:\"(string|function)\",offset:\"(number|string)\",container:\"(string|element|boolean)\",fallbackPlacement:\"(string|array)\",boundary:\"(string|element)\"}),placement:\"top\",offset:0,container:!1,fallbackPlacement:\"flip\",boundary:\"scrollParent\"},vn=\"out\",En={HIDE:\"hide\"+fn,HIDDEN:\"hidden\"+fn,SHOW:(_n=\"show\")+fn,SHOWN:\"shown\"+fn,INSERTED:\"inserted\"+fn,CLICK:\"click\"+fn,FOCUSIN:\"focusin\"+fn,FOCUSOUT:\"focusout\"+fn,MOUSEENTER:\"mouseenter\"+fn,MOUSELEAVE:\"mouseleave\"+fn},yn=\"fade\",bn=\"show\",Tn=\".tooltip-inner\",Cn=\".arrow\",wn=\"hover\",In=\"focus\",Dn=\"click\",An=\"manual\",Sn=function(){function i(t,e){if(\"undefined\"==typeof ge)throw new TypeError(\"Bootstrap tooltips require Popper.js (https://popper.js.org)\");this._isEnabled=!0,this._timeout=0,this._hoverState=\"\",this._activeTrigger={},this._popper=null,this.element=t,this.config=this._getConfig(e),this.tip=null,this._setListeners()}var t=i.prototype;return t.enable=function(){this._isEnabled=!0},t.disable=function(){this._isEnabled=!1},t.toggleEnabled=function(){this._isEnabled=!this._isEnabled},t.toggle=function(t){if(this._isEnabled)if(t){var e=this.constructor.DATA_KEY,n=an(t.currentTarget).data(e);n||(n=new this.constructor(t.currentTarget,this._getDelegateConfig()),an(t.currentTarget).data(e,n)),n._activeTrigger.click=!n._activeTrigger.click,n._isWithActiveTrigger()?n._enter(null,n):n._leave(null,n)}else{if(an(this.getTipElement()).hasClass(bn))return void this._leave(null,this);this._enter(null,this)}},t.dispose=function(){clearTimeout(this._timeout),an.removeData(this.element,this.constructor.DATA_KEY),an(this.element).off(this.constructor.EVENT_KEY),an(this.element).closest(\".modal\").off(\"hide.bs.modal\"),this.tip&&an(this.tip).remove(),this._isEnabled=null,this._timeout=null,this._hoverState=null,(this._activeTrigger=null)!==this._popper&&this._popper.destroy(),this._popper=null,this.element=null,this.config=null,this.tip=null},t.show=function(){var e=this;if(\"none\"===an(this.element).css(\"display\"))throw new Error(\"Please use show on visible elements\");var t=an.Event(this.constructor.Event.SHOW);if(this.isWithContent()&&this._isEnabled){an(this.element).trigger(t);var n=an.contains(this.element.ownerDocument.documentElement,this.element);if(t.isDefaultPrevented()||!n)return;var i=this.getTipElement(),r=gt.getUID(this.constructor.NAME);i.setAttribute(\"id\",r),this.element.setAttribute(\"aria-describedby\",r),this.setContent(),this.config.animation&&an(i).addClass(yn);var o=\"function\"==typeof this.config.placement?this.config.placement.call(this,i,this.element):this.config.placement,s=this._getAttachment(o);this.addAttachmentClass(s);var a=!1===this.config.container?document.body:an(this.config.container);an(i).data(this.constructor.DATA_KEY,this),an.contains(this.element.ownerDocument.documentElement,this.tip)||an(i).appendTo(a),an(this.element).trigger(this.constructor.Event.INSERTED),this._popper=new ge(this.element,i,{placement:s,modifiers:{offset:{offset:this.config.offset},flip:{behavior:this.config.fallbackPlacement},arrow:{element:Cn},preventOverflow:{boundariesElement:this.config.boundary}},onCreate:function(t){t.originalPlacement!==t.placement&&e._handlePopperPlacementChange(t)},onUpdate:function(t){e._handlePopperPlacementChange(t)}}),an(i).addClass(bn),\"ontouchstart\"in document.documentElement&&an(document.body).children().on(\"mouseover\",null,an.noop);var l=function(){e.config.animation&&e._fixTransition();var t=e._hoverState;e._hoverState=null,an(e.element).trigger(e.constructor.Event.SHOWN),t===vn&&e._leave(null,e)};if(an(this.tip).hasClass(yn)){var c=gt.getTransitionDurationFromElement(this.tip);an(this.tip).one(gt.TRANSITION_END,l).emulateTransitionEnd(c)}else l()}},t.hide=function(t){var e=this,n=this.getTipElement(),i=an.Event(this.constructor.Event.HIDE),r=function(){e._hoverState!==_n&&n.parentNode&&n.parentNode.removeChild(n),e._cleanTipClass(),e.element.removeAttribute(\"aria-describedby\"),an(e.element).trigger(e.constructor.Event.HIDDEN),null!==e._popper&&e._popper.destroy(),t&&t()};if(an(this.element).trigger(i),!i.isDefaultPrevented()){if(an(n).removeClass(bn),\"ontouchstart\"in document.documentElement&&an(document.body).children().off(\"mouseover\",null,an.noop),this._activeTrigger[Dn]=!1,this._activeTrigger[In]=!1,this._activeTrigger[wn]=!1,an(this.tip).hasClass(yn)){var o=gt.getTransitionDurationFromElement(n);an(n).one(gt.TRANSITION_END,r).emulateTransitionEnd(o)}else r();this._hoverState=\"\"}},t.update=function(){null!==this._popper&&this._popper.scheduleUpdate()},t.isWithContent=function(){return Boolean(this.getTitle())},t.addAttachmentClass=function(t){an(this.getTipElement()).addClass(un+\"-\"+t)},t.getTipElement=function(){return this.tip=this.tip||an(this.config.template)[0],this.tip},t.setContent=function(){var t=an(this.getTipElement());this.setElementContent(t.find(Tn),this.getTitle()),t.removeClass(yn+\" \"+bn)},t.setElementContent=function(t,e){var n=this.config.html;\"object\"==typeof e&&(e.nodeType||e.jquery)?n?an(e).parent().is(t)||t.empty().append(e):t.text(an(e).text()):t[n?\"html\":\"text\"](e)},t.getTitle=function(){var t=this.element.getAttribute(\"data-original-title\");return t||(t=\"function\"==typeof this.config.title?this.config.title.call(this.element):this.config.title),t},t._getAttachment=function(t){return gn[t.toUpperCase()]},t._setListeners=function(){var i=this;this.config.trigger.split(\" \").forEach(function(t){if(\"click\"===t)an(i.element).on(i.constructor.Event.CLICK,i.config.selector,function(t){return i.toggle(t)});else if(t!==An){var e=t===wn?i.constructor.Event.MOUSEENTER:i.constructor.Event.FOCUSIN,n=t===wn?i.constructor.Event.MOUSELEAVE:i.constructor.Event.FOCUSOUT;an(i.element).on(e,i.config.selector,function(t){return i._enter(t)}).on(n,i.config.selector,function(t){return i._leave(t)})}an(i.element).closest(\".modal\").on(\"hide.bs.modal\",function(){return i.hide()})}),this.config.selector?this.config=c({},this.config,{trigger:\"manual\",selector:\"\"}):this._fixTitle()},t._fixTitle=function(){var t=typeof this.element.getAttribute(\"data-original-title\");(this.element.getAttribute(\"title\")||\"string\"!==t)&&(this.element.setAttribute(\"data-original-title\",this.element.getAttribute(\"title\")||\"\"),this.element.setAttribute(\"title\",\"\"))},t._enter=function(t,e){var n=this.constructor.DATA_KEY;(e=e||an(t.currentTarget).data(n))||(e=new this.constructor(t.currentTarget,this._getDelegateConfig()),an(t.currentTarget).data(n,e)),t&&(e._activeTrigger[\"focusin\"===t.type?In:wn]=!0),an(e.getTipElement()).hasClass(bn)||e._hoverState===_n?e._hoverState=_n:(clearTimeout(e._timeout),e._hoverState=_n,e.config.delay&&e.config.delay.show?e._timeout=setTimeout(function(){e._hoverState===_n&&e.show()},e.config.delay.show):e.show())},t._leave=function(t,e){var n=this.constructor.DATA_KEY;(e=e||an(t.currentTarget).data(n))||(e=new this.constructor(t.currentTarget,this._getDelegateConfig()),an(t.currentTarget).data(n,e)),t&&(e._activeTrigger[\"focusout\"===t.type?In:wn]=!1),e._isWithActiveTrigger()||(clearTimeout(e._timeout),e._hoverState=vn,e.config.delay&&e.config.delay.hide?e._timeout=setTimeout(function(){e._hoverState===vn&&e.hide()},e.config.delay.hide):e.hide())},t._isWithActiveTrigger=function(){for(var t in this._activeTrigger)if(this._activeTrigger[t])return!0;return!1},t._getConfig=function(t){return\"number\"==typeof(t=c({},this.constructor.Default,an(this.element).data(),\"object\"==typeof t&&t?t:{})).delay&&(t.delay={show:t.delay,hide:t.delay}),\"number\"==typeof t.title&&(t.title=t.title.toString()),\"number\"==typeof t.content&&(t.content=t.content.toString()),gt.typeCheckConfig(ln,t,this.constructor.DefaultType),t},t._getDelegateConfig=function(){var t={};if(this.config)for(var e in this.config)this.constructor.Default[e]!==this.config[e]&&(t[e]=this.config[e]);return t},t._cleanTipClass=function(){var t=an(this.getTipElement()),e=t.attr(\"class\").match(dn);null!==e&&0<e.length&&t.removeClass(e.join(\"\"))},t._handlePopperPlacementChange=function(t){this._cleanTipClass(),this.addAttachmentClass(this._getAttachment(t.placement))},t._fixTransition=function(){var t=this.getTipElement(),e=this.config.animation;null===t.getAttribute(\"x-placement\")&&(an(t).removeClass(yn),this.config.animation=!1,this.hide(),this.show(),this.config.animation=e)},i._jQueryInterface=function(n){return this.each(function(){var t=an(this).data(cn),e=\"object\"==typeof n&&n;if((t||!/dispose|hide/.test(n))&&(t||(t=new i(this,e),an(this).data(cn,t)),\"string\"==typeof n)){if(\"undefined\"==typeof t[n])throw new TypeError('No method named \"'+n+'\"');t[n]()}})},s(i,null,[{key:\"VERSION\",get:function(){return\"4.1.1\"}},{key:\"Default\",get:function(){return mn}},{key:\"NAME\",get:function(){return ln}},{key:\"DATA_KEY\",get:function(){return cn}},{key:\"Event\",get:function(){return En}},{key:\"EVENT_KEY\",get:function(){return fn}},{key:\"DefaultType\",get:function(){return pn}}]),i}(),an.fn[ln]=Sn._jQueryInterface,an.fn[ln].Constructor=Sn,an.fn[ln].noConflict=function(){return an.fn[ln]=hn,Sn._jQueryInterface},Sn),Ii=(Nn=\"popover\",Ln=\".\"+(kn=\"bs.popover\"),Pn=(On=e).fn[Nn],xn=\"bs-popover\",jn=new RegExp(\"(^|\\\\s)\"+xn+\"\\\\S+\",\"g\"),Mn=c({},wi.Default,{placement:\"right\",trigger:\"click\",content:\"\",template:'<div class=\"popover\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-header\"></h3><div class=\"popover-body\"></div></div>'}),Rn=c({},wi.DefaultType,{content:\"(string|element|function)\"}),Hn=\"fade\",Fn=\".popover-header\",Un=\".popover-body\",Bn={HIDE:\"hide\"+Ln,HIDDEN:\"hidden\"+Ln,SHOW:(Wn=\"show\")+Ln,SHOWN:\"shown\"+Ln,INSERTED:\"inserted\"+Ln,CLICK:\"click\"+Ln,FOCUSIN:\"focusin\"+Ln,FOCUSOUT:\"focusout\"+Ln,MOUSEENTER:\"mouseenter\"+Ln,MOUSELEAVE:\"mouseleave\"+Ln},Kn=function(t){var e,n;function i(){return t.apply(this,arguments)||this}n=t,(e=i).prototype=Object.create(n.prototype),(e.prototype.constructor=e).__proto__=n;var r=i.prototype;return r.isWithContent=function(){return this.getTitle()||this._getContent()},r.addAttachmentClass=function(t){On(this.getTipElement()).addClass(xn+\"-\"+t)},r.getTipElement=function(){return this.tip=this.tip||On(this.config.template)[0],this.tip},r.setContent=function(){var t=On(this.getTipElement());this.setElementContent(t.find(Fn),this.getTitle());var e=this._getContent();\"function\"==typeof e&&(e=e.call(this.element)),this.setElementContent(t.find(Un),e),t.removeClass(Hn+\" \"+Wn)},r._getContent=function(){return this.element.getAttribute(\"data-content\")||this.config.content},r._cleanTipClass=function(){var t=On(this.getTipElement()),e=t.attr(\"class\").match(jn);null!==e&&0<e.length&&t.removeClass(e.join(\"\"))},i._jQueryInterface=function(n){return this.each(function(){var t=On(this).data(kn),e=\"object\"==typeof n?n:null;if((t||!/destroy|hide/.test(n))&&(t||(t=new i(this,e),On(this).data(kn,t)),\"string\"==typeof n)){if(\"undefined\"==typeof t[n])throw new TypeError('No method named \"'+n+'\"');t[n]()}})},s(i,null,[{key:\"VERSION\",get:function(){return\"4.1.1\"}},{key:\"Default\",get:function(){return Mn}},{key:\"NAME\",get:function(){return Nn}},{key:\"DATA_KEY\",get:function(){return kn}},{key:\"Event\",get:function(){return Bn}},{key:\"EVENT_KEY\",get:function(){return Ln}},{key:\"DefaultType\",get:function(){return Rn}}]),i}(wi),On.fn[Nn]=Kn._jQueryInterface,On.fn[Nn].Constructor=Kn,On.fn[Nn].noConflict=function(){return On.fn[Nn]=Pn,Kn._jQueryInterface},Kn),Di=(Qn=\"scrollspy\",Gn=\".\"+(Yn=\"bs.scrollspy\"),qn=(Vn=e).fn[Qn],zn={offset:10,method:\"auto\",target:\"\"},Xn={offset:\"number\",method:\"string\",target:\"(string|element)\"},Jn={ACTIVATE:\"activate\"+Gn,SCROLL:\"scroll\"+Gn,LOAD_DATA_API:\"load\"+Gn+\".data-api\"},Zn=\"dropdown-item\",$n=\"active\",ti={DATA_SPY:'[data-spy=\"scroll\"]',ACTIVE:\".active\",NAV_LIST_GROUP:\".nav, .list-group\",NAV_LINKS:\".nav-link\",NAV_ITEMS:\".nav-item\",LIST_ITEMS:\".list-group-item\",DROPDOWN:\".dropdown\",DROPDOWN_ITEMS:\".dropdown-item\",DROPDOWN_TOGGLE:\".dropdown-toggle\"},ei=\"offset\",ni=\"position\",ii=function(){function n(t,e){var n=this;this._element=t,this._scrollElement=\"BODY\"===t.tagName?window:t,this._config=this._getConfig(e),this._selector=this._config.target+\" \"+ti.NAV_LINKS+\",\"+this._config.target+\" \"+ti.LIST_ITEMS+\",\"+this._config.target+\" \"+ti.DROPDOWN_ITEMS,this._offsets=[],this._targets=[],this._activeTarget=null,this._scrollHeight=0,Vn(this._scrollElement).on(Jn.SCROLL,function(t){return n._process(t)}),this.refresh(),this._process()}var t=n.prototype;return t.refresh=function(){var e=this,t=this._scrollElement===this._scrollElement.window?ei:ni,r=\"auto\"===this._config.method?t:this._config.method,o=r===ni?this._getScrollTop():0;this._offsets=[],this._targets=[],this._scrollHeight=this._getScrollHeight(),Vn.makeArray(Vn(this._selector)).map(function(t){var e,n=gt.getSelectorFromElement(t);if(n&&(e=Vn(n)[0]),e){var i=e.getBoundingClientRect();if(i.width||i.height)return[Vn(e)[r]().top+o,n]}return null}).filter(function(t){return t}).sort(function(t,e){return t[0]-e[0]}).forEach(function(t){e._offsets.push(t[0]),e._targets.push(t[1])})},t.dispose=function(){Vn.removeData(this._element,Yn),Vn(this._scrollElement).off(Gn),this._element=null,this._scrollElement=null,this._config=null,this._selector=null,this._offsets=null,this._targets=null,this._activeTarget=null,this._scrollHeight=null},t._getConfig=function(t){if(\"string\"!=typeof(t=c({},zn,\"object\"==typeof t&&t?t:{})).target){var e=Vn(t.target).attr(\"id\");e||(e=gt.getUID(Qn),Vn(t.target).attr(\"id\",e)),t.target=\"#\"+e}return gt.typeCheckConfig(Qn,t,Xn),t},t._getScrollTop=function(){return this._scrollElement===window?this._scrollElement.pageYOffset:this._scrollElement.scrollTop},t._getScrollHeight=function(){return this._scrollElement.scrollHeight||Math.max(document.body.scrollHeight,document.documentElement.scrollHeight)},t._getOffsetHeight=function(){return this._scrollElement===window?window.innerHeight:this._scrollElement.getBoundingClientRect().height},t._process=function(){var t=this._getScrollTop()+this._config.offset,e=this._getScrollHeight(),n=this._config.offset+e-this._getOffsetHeight();if(this._scrollHeight!==e&&this.refresh(),n<=t){var i=this._targets[this._targets.length-1];this._activeTarget!==i&&this._activate(i)}else{if(this._activeTarget&&t<this._offsets[0]&&0<this._offsets[0])return this._activeTarget=null,void this._clear();for(var r=this._offsets.length;r--;){this._activeTarget!==this._targets[r]&&t>=this._offsets[r]&&(\"undefined\"==typeof this._offsets[r+1]||t<this._offsets[r+1])&&this._activate(this._targets[r])}}},t._activate=function(e){this._activeTarget=e,this._clear();var t=this._selector.split(\",\");t=t.map(function(t){return t+'[data-target=\"'+e+'\"],'+t+'[href=\"'+e+'\"]'});var n=Vn(t.join(\",\"));n.hasClass(Zn)?(n.closest(ti.DROPDOWN).find(ti.DROPDOWN_TOGGLE).addClass($n),n.addClass($n)):(n.addClass($n),n.parents(ti.NAV_LIST_GROUP).prev(ti.NAV_LINKS+\", \"+ti.LIST_ITEMS).addClass($n),n.parents(ti.NAV_LIST_GROUP).prev(ti.NAV_ITEMS).children(ti.NAV_LINKS).addClass($n)),Vn(this._scrollElement).trigger(Jn.ACTIVATE,{relatedTarget:e})},t._clear=function(){Vn(this._selector).filter(ti.ACTIVE).removeClass($n)},n._jQueryInterface=function(e){return this.each(function(){var t=Vn(this).data(Yn);if(t||(t=new n(this,\"object\"==typeof e&&e),Vn(this).data(Yn,t)),\"string\"==typeof e){if(\"undefined\"==typeof t[e])throw new TypeError('No method named \"'+e+'\"');t[e]()}})},s(n,null,[{key:\"VERSION\",get:function(){return\"4.1.1\"}},{key:\"Default\",get:function(){return zn}}]),n}(),Vn(window).on(Jn.LOAD_DATA_API,function(){for(var t=Vn.makeArray(Vn(ti.DATA_SPY)),e=t.length;e--;){var n=Vn(t[e]);ii._jQueryInterface.call(n,n.data())}}),Vn.fn[Qn]=ii._jQueryInterface,Vn.fn[Qn].Constructor=ii,Vn.fn[Qn].noConflict=function(){return Vn.fn[Qn]=qn,ii._jQueryInterface},ii),Ai=(si=\".\"+(oi=\"bs.tab\"),ai=(ri=e).fn.tab,li={HIDE:\"hide\"+si,HIDDEN:\"hidden\"+si,SHOW:\"show\"+si,SHOWN:\"shown\"+si,CLICK_DATA_API:\"click\"+si+\".data-api\"},ci=\"dropdown-menu\",fi=\"active\",hi=\"disabled\",ui=\"fade\",di=\"show\",pi=\".dropdown\",gi=\".nav, .list-group\",mi=\".active\",_i=\"> li > .active\",vi='[data-toggle=\"tab\"], [data-toggle=\"pill\"], [data-toggle=\"list\"]',Ei=\".dropdown-toggle\",yi=\"> .dropdown-menu .active\",bi=function(){function i(t){this._element=t}var t=i.prototype;return t.show=function(){var n=this;if(!(this._element.parentNode&&this._element.parentNode.nodeType===Node.ELEMENT_NODE&&ri(this._element).hasClass(fi)||ri(this._element).hasClass(hi))){var t,i,e=ri(this._element).closest(gi)[0],r=gt.getSelectorFromElement(this._element);if(e){var o=\"UL\"===e.nodeName?_i:mi;i=(i=ri.makeArray(ri(e).find(o)))[i.length-1]}var s=ri.Event(li.HIDE,{relatedTarget:this._element}),a=ri.Event(li.SHOW,{relatedTarget:i});if(i&&ri(i).trigger(s),ri(this._element).trigger(a),!a.isDefaultPrevented()&&!s.isDefaultPrevented()){r&&(t=ri(r)[0]),this._activate(this._element,e);var l=function(){var t=ri.Event(li.HIDDEN,{relatedTarget:n._element}),e=ri.Event(li.SHOWN,{relatedTarget:i});ri(i).trigger(t),ri(n._element).trigger(e)};t?this._activate(t,t.parentNode,l):l()}}},t.dispose=function(){ri.removeData(this._element,oi),this._element=null},t._activate=function(t,e,n){var i=this,r=(\"UL\"===e.nodeName?ri(e).find(_i):ri(e).children(mi))[0],o=n&&r&&ri(r).hasClass(ui),s=function(){return i._transitionComplete(t,r,n)};if(r&&o){var a=gt.getTransitionDurationFromElement(r);ri(r).one(gt.TRANSITION_END,s).emulateTransitionEnd(a)}else s()},t._transitionComplete=function(t,e,n){if(e){ri(e).removeClass(di+\" \"+fi);var i=ri(e.parentNode).find(yi)[0];i&&ri(i).removeClass(fi),\"tab\"===e.getAttribute(\"role\")&&e.setAttribute(\"aria-selected\",!1)}if(ri(t).addClass(fi),\"tab\"===t.getAttribute(\"role\")&&t.setAttribute(\"aria-selected\",!0),gt.reflow(t),ri(t).addClass(di),t.parentNode&&ri(t.parentNode).hasClass(ci)){var r=ri(t).closest(pi)[0];r&&ri(r).find(Ei).addClass(fi),t.setAttribute(\"aria-expanded\",!0)}n&&n()},i._jQueryInterface=function(n){return this.each(function(){var t=ri(this),e=t.data(oi);if(e||(e=new i(this),t.data(oi,e)),\"string\"==typeof n){if(\"undefined\"==typeof e[n])throw new TypeError('No method named \"'+n+'\"');e[n]()}})},s(i,null,[{key:\"VERSION\",get:function(){return\"4.1.1\"}}]),i}(),ri(document).on(li.CLICK_DATA_API,vi,function(t){t.preventDefault(),bi._jQueryInterface.call(ri(this),\"show\")}),ri.fn.tab=bi._jQueryInterface,ri.fn.tab.Constructor=bi,ri.fn.tab.noConflict=function(){return ri.fn.tab=ai,bi._jQueryInterface},bi);!function(t){if(\"undefined\"==typeof t)throw new TypeError(\"Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.\");var e=t.fn.jquery.split(\" \")[0].split(\".\");if(e[0]<2&&e[1]<9||1===e[0]&&9===e[1]&&e[2]<1||4<=e[0])throw new Error(\"Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0\")}(e),t.Util=gt,t.Alert=mt,t.Button=_t,t.Carousel=vt,t.Collapse=Et,t.Dropdown=Ti,t.Modal=Ci,t.Popover=Ii,t.Scrollspy=Di,t.Tab=Ai,t.Tooltip=wi,Object.defineProperty(t,\"__esModule\",{value:!0})});\r\n","js/bootstrap/popper.js":"/**!\r\n * @fileOverview Kickass library to create and place poppers near their reference elements.\r\n * @version 1.14.3\r\n * @license\r\n * Copyright (c) 2016 Federico Zivolo and contributors\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n(function (global, factory) {\r\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\r\n        typeof define === 'function' && define.amd ? define(factory) :\r\n            (global.Popper = factory());\r\n}(this, (function () {\r\n    'use strict';\r\n\r\n    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\r\n\r\n    var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\r\n    var timeoutDuration = 0;\r\n    for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\r\n        if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\r\n            timeoutDuration = 1;\r\n            break;\r\n        }\r\n    }\r\n\r\n    function microtaskDebounce(fn) {\r\n        var called = false;\r\n        return function () {\r\n            if (called) {\r\n                return;\r\n            }\r\n            called = true;\r\n            window.Promise.resolve().then(function () {\r\n                called = false;\r\n                fn();\r\n            });\r\n        };\r\n    }\r\n\r\n    function taskDebounce(fn) {\r\n        var scheduled = false;\r\n        return function () {\r\n            if (!scheduled) {\r\n                scheduled = true;\r\n                setTimeout(function () {\r\n                    scheduled = false;\r\n                    fn();\r\n                }, timeoutDuration);\r\n            }\r\n        };\r\n    }\r\n\r\n    var supportsMicroTasks = isBrowser && window.Promise;\r\n\r\n    /**\r\n     * Create a debounced version of a method, that's asynchronously deferred\r\n     * but called in the minimum time possible.\r\n     *\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @argument {Function} fn\r\n     * @returns {Function}\r\n     */\r\n    var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;\r\n\r\n    /**\r\n     * Check if the given variable is a function\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @argument {Any} functionToCheck - variable to check\r\n     * @returns {Boolean} answer to: is a function?\r\n     */\r\n    function isFunction(functionToCheck) {\r\n        var getType = {};\r\n        return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\r\n    }\r\n\r\n    /**\r\n     * Get CSS computed property of the given element\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @argument {Eement} element\r\n     * @argument {String} property\r\n     */\r\n    function getStyleComputedProperty(element, property) {\r\n        if (element.nodeType !== 1) {\r\n            return [];\r\n        }\r\n        // NOTE: 1 DOM access here\r\n        var css = getComputedStyle(element, null);\r\n        return property ? css[property] : css;\r\n    }\r\n\r\n    /**\r\n     * Returns the parentNode or the host of the element\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @argument {Element} element\r\n     * @returns {Element} parent\r\n     */\r\n    function getParentNode(element) {\r\n        if (element.nodeName === 'HTML') {\r\n            return element;\r\n        }\r\n        return element.parentNode || element.host;\r\n    }\r\n\r\n    /**\r\n     * Returns the scrolling parent of the given element\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @argument {Element} element\r\n     * @returns {Element} scroll parent\r\n     */\r\n    function getScrollParent(element) {\r\n        // Return body, `getScroll` will take care to get the correct `scrollTop` from it\r\n        if (!element) {\r\n            return document.body;\r\n        }\r\n\r\n        switch (element.nodeName) {\r\n            case 'HTML':\r\n            case 'BODY':\r\n                return element.ownerDocument.body;\r\n            case '#document':\r\n                return element.body;\r\n        }\r\n\r\n        // Firefox want us to check `-x` and `-y` variations as well\r\n\r\n        var _getStyleComputedProp = getStyleComputedProperty(element),\r\n            overflow = _getStyleComputedProp.overflow,\r\n            overflowX = _getStyleComputedProp.overflowX,\r\n            overflowY = _getStyleComputedProp.overflowY;\r\n\r\n        if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\r\n            return element;\r\n        }\r\n\r\n        return getScrollParent(getParentNode(element));\r\n    }\r\n\r\n    var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\r\n    var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\r\n\r\n    /**\r\n     * Determines if the browser is Internet Explorer\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @param {Number} version to check\r\n     * @returns {Boolean} isIE\r\n     */\r\n    function isIE(version) {\r\n        if (version === 11) {\r\n            return isIE11;\r\n        }\r\n        if (version === 10) {\r\n            return isIE10;\r\n        }\r\n        return isIE11 || isIE10;\r\n    }\r\n\r\n    /**\r\n     * Returns the offset parent of the given element\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @argument {Element} element\r\n     * @returns {Element} offset parent\r\n     */\r\n    function getOffsetParent(element) {\r\n        if (!element) {\r\n            return document.documentElement;\r\n        }\r\n\r\n        var noOffsetParent = isIE(10) ? document.body : null;\r\n\r\n        // NOTE: 1 DOM access here\r\n        var offsetParent = element.offsetParent;\r\n        // Skip hidden elements which don't have an offsetParent\r\n        while (offsetParent === noOffsetParent && element.nextElementSibling) {\r\n            offsetParent = (element = element.nextElementSibling).offsetParent;\r\n        }\r\n\r\n        var nodeName = offsetParent && offsetParent.nodeName;\r\n\r\n        if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\r\n            return element ? element.ownerDocument.documentElement : document.documentElement;\r\n        }\r\n\r\n        // .offsetParent will return the closest TD or TABLE in case\r\n        // no offsetParent is present, I hate this job...\r\n        if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\r\n            return getOffsetParent(offsetParent);\r\n        }\r\n\r\n        return offsetParent;\r\n    }\r\n\r\n    function isOffsetContainer(element) {\r\n        var nodeName = element.nodeName;\r\n\r\n        if (nodeName === 'BODY') {\r\n            return false;\r\n        }\r\n        return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\r\n    }\r\n\r\n    /**\r\n     * Finds the root node (document, shadowDOM root) of the given element\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @argument {Element} node\r\n     * @returns {Element} root node\r\n     */\r\n    function getRoot(node) {\r\n        if (node.parentNode !== null) {\r\n            return getRoot(node.parentNode);\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * Finds the offset parent common to the two provided nodes\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @argument {Element} element1\r\n     * @argument {Element} element2\r\n     * @returns {Element} common offset parent\r\n     */\r\n    function findCommonOffsetParent(element1, element2) {\r\n        // This check is needed to avoid errors in case one of the elements isn't defined for any reason\r\n        if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\r\n            return document.documentElement;\r\n        }\r\n\r\n        // Here we make sure to give as \"start\" the element that comes first in the DOM\r\n        var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\r\n        var start = order ? element1 : element2;\r\n        var end = order ? element2 : element1;\r\n\r\n        // Get common ancestor container\r\n        var range = document.createRange();\r\n        range.setStart(start, 0);\r\n        range.setEnd(end, 0);\r\n        var commonAncestorContainer = range.commonAncestorContainer;\r\n\r\n        // Both nodes are inside #document\r\n\r\n        if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\r\n            if (isOffsetContainer(commonAncestorContainer)) {\r\n                return commonAncestorContainer;\r\n            }\r\n\r\n            return getOffsetParent(commonAncestorContainer);\r\n        }\r\n\r\n        // one of the nodes is inside shadowDOM, find which one\r\n        var element1root = getRoot(element1);\r\n        if (element1root.host) {\r\n            return findCommonOffsetParent(element1root.host, element2);\r\n        } else {\r\n            return findCommonOffsetParent(element1, getRoot(element2).host);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the scroll value of the given element in the given side (top and left)\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @argument {Element} element\r\n     * @argument {String} side `top` or `left`\r\n     * @returns {number} amount of scrolled pixels\r\n     */\r\n    function getScroll(element) {\r\n        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\r\n\r\n        var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\r\n        var nodeName = element.nodeName;\r\n\r\n        if (nodeName === 'BODY' || nodeName === 'HTML') {\r\n            var html = element.ownerDocument.documentElement;\r\n            var scrollingElement = element.ownerDocument.scrollingElement || html;\r\n            return scrollingElement[upperSide];\r\n        }\r\n\r\n        return element[upperSide];\r\n    }\r\n\r\n    /*\r\n     * Sum or subtract the element scroll values (left and top) from a given rect object\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @param {Object} rect - Rect object you want to change\r\n     * @param {HTMLElement} element - The element from the function reads the scroll values\r\n     * @param {Boolean} subtract - set to true if you want to subtract the scroll values\r\n     * @return {Object} rect - The modifier rect object\r\n     */\r\n    function includeScroll(rect, element) {\r\n        var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n\r\n        var scrollTop = getScroll(element, 'top');\r\n        var scrollLeft = getScroll(element, 'left');\r\n        var modifier = subtract ? -1 : 1;\r\n        rect.top += scrollTop * modifier;\r\n        rect.bottom += scrollTop * modifier;\r\n        rect.left += scrollLeft * modifier;\r\n        rect.right += scrollLeft * modifier;\r\n        return rect;\r\n    }\r\n\r\n    /*\r\n     * Helper to detect borders of a given element\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @param {CSSStyleDeclaration} styles\r\n     * Result of `getStyleComputedProperty` on the given element\r\n     * @param {String} axis - `x` or `y`\r\n     * @return {number} borders - The borders size of the given axis\r\n     */\r\n\r\n    function getBordersSize(styles, axis) {\r\n        var sideA = axis === 'x' ? 'Left' : 'Top';\r\n        var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\r\n\r\n        return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);\r\n    }\r\n\r\n    function getSize(axis, body, html, computedStyle) {\r\n        return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);\r\n    }\r\n\r\n    function getWindowSizes() {\r\n        var body = document.body;\r\n        var html = document.documentElement;\r\n        var computedStyle = isIE(10) && getComputedStyle(html);\r\n\r\n        return {\r\n            height: getSize('Height', body, html, computedStyle),\r\n            width: getSize('Width', body, html, computedStyle)\r\n        };\r\n    }\r\n\r\n    var classCallCheck = function (instance, Constructor) {\r\n        if (!(instance instanceof Constructor)) {\r\n            throw new TypeError(\"Cannot call a class as a function\");\r\n        }\r\n    };\r\n\r\n    var createClass = function () {\r\n        function defineProperties(target, props) {\r\n            for (var i = 0; i < props.length; i++) {\r\n                var descriptor = props[i];\r\n                descriptor.enumerable = descriptor.enumerable || false;\r\n                descriptor.configurable = true;\r\n                if (\"value\" in descriptor) descriptor.writable = true;\r\n                Object.defineProperty(target, descriptor.key, descriptor);\r\n            }\r\n        }\r\n\r\n        return function (Constructor, protoProps, staticProps) {\r\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\r\n            if (staticProps) defineProperties(Constructor, staticProps);\r\n            return Constructor;\r\n        };\r\n    }();\r\n\r\n\r\n    var defineProperty = function (obj, key, value) {\r\n        if (key in obj) {\r\n            Object.defineProperty(obj, key, {\r\n                value: value,\r\n                enumerable: true,\r\n                configurable: true,\r\n                writable: true\r\n            });\r\n        } else {\r\n            obj[key] = value;\r\n        }\r\n\r\n        return obj;\r\n    };\r\n\r\n    var _extends = Object.assign || function (target) {\r\n        for (var i = 1; i < arguments.length; i++) {\r\n            var source = arguments[i];\r\n\r\n            for (var key in source) {\r\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n                    target[key] = source[key];\r\n                }\r\n            }\r\n        }\r\n\r\n        return target;\r\n    };\r\n\r\n    /**\r\n     * Given element offsets, generate an output similar to getBoundingClientRect\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @argument {Object} offsets\r\n     * @returns {Object} ClientRect like output\r\n     */\r\n    function getClientRect(offsets) {\r\n        return _extends({}, offsets, {\r\n            right: offsets.left + offsets.width,\r\n            bottom: offsets.top + offsets.height\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get bounding client rect of given element\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @param {HTMLElement} element\r\n     * @return {Object} client rect\r\n     */\r\n    function getBoundingClientRect(element) {\r\n        var rect = {};\r\n\r\n        // IE10 10 FIX: Please, don't ask, the element isn't\r\n        // considered in DOM in some circumstances...\r\n        // This isn't reproducible in IE10 compatibility mode of IE11\r\n        try {\r\n            if (isIE(10)) {\r\n                rect = element.getBoundingClientRect();\r\n                var scrollTop = getScroll(element, 'top');\r\n                var scrollLeft = getScroll(element, 'left');\r\n                rect.top += scrollTop;\r\n                rect.left += scrollLeft;\r\n                rect.bottom += scrollTop;\r\n                rect.right += scrollLeft;\r\n            } else {\r\n                rect = element.getBoundingClientRect();\r\n            }\r\n        } catch (e) {\r\n        }\r\n\r\n        var result = {\r\n            left: rect.left,\r\n            top: rect.top,\r\n            width: rect.right - rect.left,\r\n            height: rect.bottom - rect.top\r\n        };\r\n\r\n        // subtract scrollbar size from sizes\r\n        var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};\r\n        var width = sizes.width || element.clientWidth || result.right - result.left;\r\n        var height = sizes.height || element.clientHeight || result.bottom - result.top;\r\n\r\n        var horizScrollbar = element.offsetWidth - width;\r\n        var vertScrollbar = element.offsetHeight - height;\r\n\r\n        // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\r\n        // we make this check conditional for performance reasons\r\n        if (horizScrollbar || vertScrollbar) {\r\n            var styles = getStyleComputedProperty(element);\r\n            horizScrollbar -= getBordersSize(styles, 'x');\r\n            vertScrollbar -= getBordersSize(styles, 'y');\r\n\r\n            result.width -= horizScrollbar;\r\n            result.height -= vertScrollbar;\r\n        }\r\n\r\n        return getClientRect(result);\r\n    }\r\n\r\n    function getOffsetRectRelativeToArbitraryNode(children, parent) {\r\n        var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n\r\n        var isIE10 = isIE(10);\r\n        var isHTML = parent.nodeName === 'HTML';\r\n        var childrenRect = getBoundingClientRect(children);\r\n        var parentRect = getBoundingClientRect(parent);\r\n        var scrollParent = getScrollParent(children);\r\n\r\n        var styles = getStyleComputedProperty(parent);\r\n        var borderTopWidth = parseFloat(styles.borderTopWidth, 10);\r\n        var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);\r\n\r\n        // In cases where the parent is fixed, we must ignore negative scroll in offset calc\r\n        if (fixedPosition && parent.nodeName === 'HTML') {\r\n            parentRect.top = Math.max(parentRect.top, 0);\r\n            parentRect.left = Math.max(parentRect.left, 0);\r\n        }\r\n        var offsets = getClientRect({\r\n            top: childrenRect.top - parentRect.top - borderTopWidth,\r\n            left: childrenRect.left - parentRect.left - borderLeftWidth,\r\n            width: childrenRect.width,\r\n            height: childrenRect.height\r\n        });\r\n        offsets.marginTop = 0;\r\n        offsets.marginLeft = 0;\r\n\r\n        // Subtract margins of documentElement in case it's being used as parent\r\n        // we do this only on HTML because it's the only element that behaves\r\n        // differently when margins are applied to it. The margins are included in\r\n        // the box of the documentElement, in the other cases not.\r\n        if (!isIE10 && isHTML) {\r\n            var marginTop = parseFloat(styles.marginTop, 10);\r\n            var marginLeft = parseFloat(styles.marginLeft, 10);\r\n\r\n            offsets.top -= borderTopWidth - marginTop;\r\n            offsets.bottom -= borderTopWidth - marginTop;\r\n            offsets.left -= borderLeftWidth - marginLeft;\r\n            offsets.right -= borderLeftWidth - marginLeft;\r\n\r\n            // Attach marginTop and marginLeft because in some circumstances we may need them\r\n            offsets.marginTop = marginTop;\r\n            offsets.marginLeft = marginLeft;\r\n        }\r\n\r\n        if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\r\n            offsets = includeScroll(offsets, parent);\r\n        }\r\n\r\n        return offsets;\r\n    }\r\n\r\n    function getViewportOffsetRectRelativeToArtbitraryNode(element) {\r\n        var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\r\n\r\n        var html = element.ownerDocument.documentElement;\r\n        var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\r\n        var width = Math.max(html.clientWidth, window.innerWidth || 0);\r\n        var height = Math.max(html.clientHeight, window.innerHeight || 0);\r\n\r\n        var scrollTop = !excludeScroll ? getScroll(html) : 0;\r\n        var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\r\n\r\n        var offset = {\r\n            top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\r\n            left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\r\n            width: width,\r\n            height: height\r\n        };\r\n\r\n        return getClientRect(offset);\r\n    }\r\n\r\n    /**\r\n     * Check if the given element is fixed or is inside a fixed parent\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @argument {Element} element\r\n     * @argument {Element} customContainer\r\n     * @returns {Boolean} answer to \"isFixed?\"\r\n     */\r\n    function isFixed(element) {\r\n        var nodeName = element.nodeName;\r\n        if (nodeName === 'BODY' || nodeName === 'HTML') {\r\n            return false;\r\n        }\r\n        if (getStyleComputedProperty(element, 'position') === 'fixed') {\r\n            return true;\r\n        }\r\n        return isFixed(getParentNode(element));\r\n    }\r\n\r\n    /**\r\n     * Finds the first parent of an element that has a transformed property defined\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @argument {Element} element\r\n     * @returns {Element} first transformed parent or documentElement\r\n     */\r\n\r\n    function getFixedPositionOffsetParent(element) {\r\n        // This check is needed to avoid errors in case one of the elements isn't defined for any reason\r\n        if (!element || !element.parentElement || isIE()) {\r\n            return document.documentElement;\r\n        }\r\n        var el = element.parentElement;\r\n        while (el && getStyleComputedProperty(el, 'transform') === 'none') {\r\n            el = el.parentElement;\r\n        }\r\n        return el || document.documentElement;\r\n    }\r\n\r\n    /**\r\n     * Computed the boundaries limits and return them\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @param {HTMLElement} popper\r\n     * @param {HTMLElement} reference\r\n     * @param {number} padding\r\n     * @param {HTMLElement} boundariesElement - Element used to define the boundaries\r\n     * @param {Boolean} fixedPosition - Is in fixed position mode\r\n     * @returns {Object} Coordinates of the boundaries\r\n     */\r\n    function getBoundaries(popper, reference, padding, boundariesElement) {\r\n        var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\r\n\r\n        // NOTE: 1 DOM access here\r\n\r\n        var boundaries = {top: 0, left: 0};\r\n        var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);\r\n\r\n        // Handle viewport case\r\n        if (boundariesElement === 'viewport') {\r\n            boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\r\n        } else {\r\n            // Handle other cases based on DOM element used as boundaries\r\n            var boundariesNode = void 0;\r\n            if (boundariesElement === 'scrollParent') {\r\n                boundariesNode = getScrollParent(getParentNode(reference));\r\n                if (boundariesNode.nodeName === 'BODY') {\r\n                    boundariesNode = popper.ownerDocument.documentElement;\r\n                }\r\n            } else if (boundariesElement === 'window') {\r\n                boundariesNode = popper.ownerDocument.documentElement;\r\n            } else {\r\n                boundariesNode = boundariesElement;\r\n            }\r\n\r\n            var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\r\n\r\n            // In case of HTML, we need a different computation\r\n            if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\r\n                var _getWindowSizes = getWindowSizes(),\r\n                    height = _getWindowSizes.height,\r\n                    width = _getWindowSizes.width;\r\n\r\n                boundaries.top += offsets.top - offsets.marginTop;\r\n                boundaries.bottom = height + offsets.top;\r\n                boundaries.left += offsets.left - offsets.marginLeft;\r\n                boundaries.right = width + offsets.left;\r\n            } else {\r\n                // for all the other DOM elements, this one is good\r\n                boundaries = offsets;\r\n            }\r\n        }\r\n\r\n        // Add paddings\r\n        boundaries.left += padding;\r\n        boundaries.top += padding;\r\n        boundaries.right -= padding;\r\n        boundaries.bottom -= padding;\r\n\r\n        return boundaries;\r\n    }\r\n\r\n    function getArea(_ref) {\r\n        var width = _ref.width,\r\n            height = _ref.height;\r\n\r\n        return width * height;\r\n    }\r\n\r\n    /**\r\n     * Utility used to transform the `auto` placement to the placement with more\r\n     * available space.\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @argument {Object} data - The data object generated by update method\r\n     * @argument {Object} options - Modifiers configuration and options\r\n     * @returns {Object} The data object, properly modified\r\n     */\r\n    function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\r\n        var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\r\n\r\n        if (placement.indexOf('auto') === -1) {\r\n            return placement;\r\n        }\r\n\r\n        var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\r\n\r\n        var rects = {\r\n            top: {\r\n                width: boundaries.width,\r\n                height: refRect.top - boundaries.top\r\n            },\r\n            right: {\r\n                width: boundaries.right - refRect.right,\r\n                height: boundaries.height\r\n            },\r\n            bottom: {\r\n                width: boundaries.width,\r\n                height: boundaries.bottom - refRect.bottom\r\n            },\r\n            left: {\r\n                width: refRect.left - boundaries.left,\r\n                height: boundaries.height\r\n            }\r\n        };\r\n\r\n        var sortedAreas = Object.keys(rects).map(function (key) {\r\n            return _extends({\r\n                key: key\r\n            }, rects[key], {\r\n                area: getArea(rects[key])\r\n            });\r\n        }).sort(function (a, b) {\r\n            return b.area - a.area;\r\n        });\r\n\r\n        var filteredAreas = sortedAreas.filter(function (_ref2) {\r\n            var width = _ref2.width,\r\n                height = _ref2.height;\r\n            return width >= popper.clientWidth && height >= popper.clientHeight;\r\n        });\r\n\r\n        var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\r\n\r\n        var variation = placement.split('-')[1];\r\n\r\n        return computedPlacement + (variation ? '-' + variation : '');\r\n    }\r\n\r\n    /**\r\n     * Get offsets to the reference element\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @param {Object} state\r\n     * @param {Element} popper - the popper element\r\n     * @param {Element} reference - the reference element (the popper will be relative to this)\r\n     * @param {Element} fixedPosition - is in fixed position mode\r\n     * @returns {Object} An object containing the offsets which will be applied to the popper\r\n     */\r\n    function getReferenceOffsets(state, popper, reference) {\r\n        var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\r\n\r\n        var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);\r\n        return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\r\n    }\r\n\r\n    /**\r\n     * Get the outer sizes of the given element (offset size + margins)\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @argument {Element} element\r\n     * @returns {Object} object containing width and height properties\r\n     */\r\n    function getOuterSizes(element) {\r\n        var styles = getComputedStyle(element);\r\n        var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\r\n        var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\r\n        var result = {\r\n            width: element.offsetWidth + y,\r\n            height: element.offsetHeight + x\r\n        };\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the opposite placement of the given one\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @argument {String} placement\r\n     * @returns {String} flipped placement\r\n     */\r\n    function getOppositePlacement(placement) {\r\n        var hash = {left: 'right', right: 'left', bottom: 'top', top: 'bottom'};\r\n        return placement.replace(/left|right|bottom|top/g, function (matched) {\r\n            return hash[matched];\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get offsets to the popper\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @param {Object} position - CSS position the Popper will get applied\r\n     * @param {HTMLElement} popper - the popper element\r\n     * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\r\n     * @param {String} placement - one of the valid placement options\r\n     * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\r\n     */\r\n    function getPopperOffsets(popper, referenceOffsets, placement) {\r\n        placement = placement.split('-')[0];\r\n\r\n        // Get popper node sizes\r\n        var popperRect = getOuterSizes(popper);\r\n\r\n        // Add position, width and height to our offsets object\r\n        var popperOffsets = {\r\n            width: popperRect.width,\r\n            height: popperRect.height\r\n        };\r\n\r\n        // depending by the popper placement we have to compute its offsets slightly differently\r\n        var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\r\n        var mainSide = isHoriz ? 'top' : 'left';\r\n        var secondarySide = isHoriz ? 'left' : 'top';\r\n        var measurement = isHoriz ? 'height' : 'width';\r\n        var secondaryMeasurement = !isHoriz ? 'height' : 'width';\r\n\r\n        popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\r\n        if (placement === secondarySide) {\r\n            popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\r\n        } else {\r\n            popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\r\n        }\r\n\r\n        return popperOffsets;\r\n    }\r\n\r\n    /**\r\n     * Mimics the `find` method of Array\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @argument {Array} arr\r\n     * @argument prop\r\n     * @argument value\r\n     * @returns index or -1\r\n     */\r\n    function find(arr, check) {\r\n        // use native find if supported\r\n        if (Array.prototype.find) {\r\n            return arr.find(check);\r\n        }\r\n\r\n        // use `filter` to obtain the same behavior of `find`\r\n        return arr.filter(check)[0];\r\n    }\r\n\r\n    /**\r\n     * Return the index of the matching object\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @argument {Array} arr\r\n     * @argument prop\r\n     * @argument value\r\n     * @returns index or -1\r\n     */\r\n    function findIndex(arr, prop, value) {\r\n        // use native findIndex if supported\r\n        if (Array.prototype.findIndex) {\r\n            return arr.findIndex(function (cur) {\r\n                return cur[prop] === value;\r\n            });\r\n        }\r\n\r\n        // use `find` + `indexOf` if `findIndex` isn't supported\r\n        var match = find(arr, function (obj) {\r\n            return obj[prop] === value;\r\n        });\r\n        return arr.indexOf(match);\r\n    }\r\n\r\n    /**\r\n     * Loop trough the list of modifiers and run them in order,\r\n     * each of them will then edit the data object.\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @param {dataObject} data\r\n     * @param {Array} modifiers\r\n     * @param {String} ends - Optional modifier name used as stopper\r\n     * @returns {dataObject}\r\n     */\r\n    function runModifiers(modifiers, data, ends) {\r\n        var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\r\n\r\n        modifiersToRun.forEach(function (modifier) {\r\n            if (modifier['function']) {\r\n                // eslint-disable-line dot-notation\r\n                console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\r\n            }\r\n            var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation\r\n            if (modifier.enabled && isFunction(fn)) {\r\n                // Add properties to offsets to make them a complete clientRect object\r\n                // we do this before each modifier to make sure the previous one doesn't\r\n                // mess with these values\r\n                data.offsets.popper = getClientRect(data.offsets.popper);\r\n                data.offsets.reference = getClientRect(data.offsets.reference);\r\n\r\n                data = fn(data, modifier);\r\n            }\r\n        });\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Updates the position of the popper, computing the new offsets and applying\r\n     * the new style.<br />\r\n     * Prefer `scheduleUpdate` over `update` because of performance reasons.\r\n     * @method\r\n     * @memberof Popper\r\n     */\r\n    function update() {\r\n        // if popper is destroyed, don't perform any further update\r\n        if (this.state.isDestroyed) {\r\n            return;\r\n        }\r\n\r\n        var data = {\r\n            instance: this,\r\n            styles: {},\r\n            arrowStyles: {},\r\n            attributes: {},\r\n            flipped: false,\r\n            offsets: {}\r\n        };\r\n\r\n        // compute reference element offsets\r\n        data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);\r\n\r\n        // compute auto placement, store placement inside the data object,\r\n        // modifiers will be able to edit `placement` if needed\r\n        // and refer to originalPlacement to know the original value\r\n        data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);\r\n\r\n        // store the computed placement inside `originalPlacement`\r\n        data.originalPlacement = data.placement;\r\n\r\n        data.positionFixed = this.options.positionFixed;\r\n\r\n        // compute the popper offsets\r\n        data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);\r\n\r\n        data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';\r\n\r\n        // run the modifiers\r\n        data = runModifiers(this.modifiers, data);\r\n\r\n        // the first `update` will call `onCreate` callback\r\n        // the other ones will call `onUpdate` callback\r\n        if (!this.state.isCreated) {\r\n            this.state.isCreated = true;\r\n            this.options.onCreate(data);\r\n        } else {\r\n            this.options.onUpdate(data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper used to know if the given modifier is enabled.\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @returns {Boolean}\r\n     */\r\n    function isModifierEnabled(modifiers, modifierName) {\r\n        return modifiers.some(function (_ref) {\r\n            var name = _ref.name,\r\n                enabled = _ref.enabled;\r\n            return enabled && name === modifierName;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the prefixed supported property name\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @argument {String} property (camelCase)\r\n     * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\r\n     */\r\n    function getSupportedPropertyName(property) {\r\n        var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\r\n        var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\r\n\r\n        for (var i = 0; i < prefixes.length; i++) {\r\n            var prefix = prefixes[i];\r\n            var toCheck = prefix ? '' + prefix + upperProp : property;\r\n            if (typeof document.body.style[toCheck] !== 'undefined') {\r\n                return toCheck;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Destroy the popper\r\n     * @method\r\n     * @memberof Popper\r\n     */\r\n    function destroy() {\r\n        this.state.isDestroyed = true;\r\n\r\n        // touch DOM only if `applyStyle` modifier is enabled\r\n        if (isModifierEnabled(this.modifiers, 'applyStyle')) {\r\n            this.popper.removeAttribute('x-placement');\r\n            this.popper.style.position = '';\r\n            this.popper.style.top = '';\r\n            this.popper.style.left = '';\r\n            this.popper.style.right = '';\r\n            this.popper.style.bottom = '';\r\n            this.popper.style.willChange = '';\r\n            this.popper.style[getSupportedPropertyName('transform')] = '';\r\n        }\r\n\r\n        this.disableEventListeners();\r\n\r\n        // remove the popper if user explicity asked for the deletion on destroy\r\n        // do not use `remove` because IE11 doesn't support it\r\n        if (this.options.removeOnDestroy) {\r\n            this.popper.parentNode.removeChild(this.popper);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Get the window associated with the element\r\n     * @argument {Element} element\r\n     * @returns {Window}\r\n     */\r\n    function getWindow(element) {\r\n        var ownerDocument = element.ownerDocument;\r\n        return ownerDocument ? ownerDocument.defaultView : window;\r\n    }\r\n\r\n    function attachToScrollParents(scrollParent, event, callback, scrollParents) {\r\n        var isBody = scrollParent.nodeName === 'BODY';\r\n        var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\r\n        target.addEventListener(event, callback, {passive: true});\r\n\r\n        if (!isBody) {\r\n            attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\r\n        }\r\n        scrollParents.push(target);\r\n    }\r\n\r\n    /**\r\n     * Setup needed event listeners used to update the popper position\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @private\r\n     */\r\n    function setupEventListeners(reference, options, state, updateBound) {\r\n        // Resize event listener on window\r\n        state.updateBound = updateBound;\r\n        getWindow(reference).addEventListener('resize', state.updateBound, {passive: true});\r\n\r\n        // Scroll event listener on scroll parents\r\n        var scrollElement = getScrollParent(reference);\r\n        attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\r\n        state.scrollElement = scrollElement;\r\n        state.eventsEnabled = true;\r\n\r\n        return state;\r\n    }\r\n\r\n    /**\r\n     * It will add resize/scroll events and start recalculating\r\n     * position of the popper element when they are triggered.\r\n     * @method\r\n     * @memberof Popper\r\n     */\r\n    function enableEventListeners() {\r\n        if (!this.state.eventsEnabled) {\r\n            this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove event listeners used to update the popper position\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @private\r\n     */\r\n    function removeEventListeners(reference, state) {\r\n        // Remove resize event listener on window\r\n        getWindow(reference).removeEventListener('resize', state.updateBound);\r\n\r\n        // Remove scroll event listener on scroll parents\r\n        state.scrollParents.forEach(function (target) {\r\n            target.removeEventListener('scroll', state.updateBound);\r\n        });\r\n\r\n        // Reset state\r\n        state.updateBound = null;\r\n        state.scrollParents = [];\r\n        state.scrollElement = null;\r\n        state.eventsEnabled = false;\r\n        return state;\r\n    }\r\n\r\n    /**\r\n     * It will remove resize/scroll events and won't recalculate popper position\r\n     * when they are triggered. It also won't trigger onUpdate callback anymore,\r\n     * unless you call `update` method manually.\r\n     * @method\r\n     * @memberof Popper\r\n     */\r\n    function disableEventListeners() {\r\n        if (this.state.eventsEnabled) {\r\n            cancelAnimationFrame(this.scheduleUpdate);\r\n            this.state = removeEventListeners(this.reference, this.state);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tells if a given input is a number\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @param {*} input to check\r\n     * @return {Boolean}\r\n     */\r\n    function isNumeric(n) {\r\n        return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\r\n    }\r\n\r\n    /**\r\n     * Set the style to the given popper\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @argument {Element} element - Element to apply the style to\r\n     * @argument {Object} styles\r\n     * Object with a list of properties and values which will be applied to the element\r\n     */\r\n    function setStyles(element, styles) {\r\n        Object.keys(styles).forEach(function (prop) {\r\n            var unit = '';\r\n            // add unit if the value is numeric and is one of the following\r\n            if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\r\n                unit = 'px';\r\n            }\r\n            element.style[prop] = styles[prop] + unit;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Set the attributes to the given popper\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @argument {Element} element - Element to apply the attributes to\r\n     * @argument {Object} styles\r\n     * Object with a list of properties and values which will be applied to the element\r\n     */\r\n    function setAttributes(element, attributes) {\r\n        Object.keys(attributes).forEach(function (prop) {\r\n            var value = attributes[prop];\r\n            if (value !== false) {\r\n                element.setAttribute(prop, attributes[prop]);\r\n            } else {\r\n                element.removeAttribute(prop);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @function\r\n     * @memberof Modifiers\r\n     * @argument {Object} data - The data object generated by `update` method\r\n     * @argument {Object} data.styles - List of style properties - values to apply to popper element\r\n     * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\r\n     * @argument {Object} options - Modifiers configuration and options\r\n     * @returns {Object} The same data object\r\n     */\r\n    function applyStyle(data) {\r\n        // any property present in `data.styles` will be applied to the popper,\r\n        // in this way we can make the 3rd party modifiers add custom styles to it\r\n        // Be aware, modifiers could override the properties defined in the previous\r\n        // lines of this modifier!\r\n        setStyles(data.instance.popper, data.styles);\r\n\r\n        // any property present in `data.attributes` will be applied to the popper,\r\n        // they will be set as HTML attributes of the element\r\n        setAttributes(data.instance.popper, data.attributes);\r\n\r\n        // if arrowElement is defined and arrowStyles has some properties\r\n        if (data.arrowElement && Object.keys(data.arrowStyles).length) {\r\n            setStyles(data.arrowElement, data.arrowStyles);\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Set the x-placement attribute before everything else because it could be used\r\n     * to add margins to the popper margins needs to be calculated to get the\r\n     * correct popper offsets.\r\n     * @method\r\n     * @memberof Popper.modifiers\r\n     * @param {HTMLElement} reference - The reference element used to position the popper\r\n     * @param {HTMLElement} popper - The HTML element used as popper\r\n     * @param {Object} options - Popper.js options\r\n     */\r\n    function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\r\n        // compute reference element offsets\r\n        var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\r\n\r\n        // compute auto placement, store placement inside the data object,\r\n        // modifiers will be able to edit `placement` if needed\r\n        // and refer to originalPlacement to know the original value\r\n        var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\r\n\r\n        popper.setAttribute('x-placement', placement);\r\n\r\n        // Apply `position` to popper before anything else because\r\n        // without the position applied we can't guarantee correct computations\r\n        setStyles(popper, {position: options.positionFixed ? 'fixed' : 'absolute'});\r\n\r\n        return options;\r\n    }\r\n\r\n    /**\r\n     * @function\r\n     * @memberof Modifiers\r\n     * @argument {Object} data - The data object generated by `update` method\r\n     * @argument {Object} options - Modifiers configuration and options\r\n     * @returns {Object} The data object, properly modified\r\n     */\r\n    function computeStyle(data, options) {\r\n        var x = options.x,\r\n            y = options.y;\r\n        var popper = data.offsets.popper;\r\n\r\n        // Remove this legacy support in Popper.js v2\r\n\r\n        var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {\r\n            return modifier.name === 'applyStyle';\r\n        }).gpuAcceleration;\r\n        if (legacyGpuAccelerationOption !== undefined) {\r\n            console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\r\n        }\r\n        var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\r\n\r\n        var offsetParent = getOffsetParent(data.instance.popper);\r\n        var offsetParentRect = getBoundingClientRect(offsetParent);\r\n\r\n        // Styles\r\n        var styles = {\r\n            position: popper.position\r\n        };\r\n\r\n        // Avoid blurry text by using full pixel integers.\r\n        // For pixel-perfect positioning, top/bottom prefers rounded\r\n        // values, while left/right prefers floored values.\r\n        var offsets = {\r\n            left: Math.floor(popper.left),\r\n            top: Math.round(popper.top),\r\n            bottom: Math.round(popper.bottom),\r\n            right: Math.floor(popper.right)\r\n        };\r\n\r\n        var sideA = x === 'bottom' ? 'top' : 'bottom';\r\n        var sideB = y === 'right' ? 'left' : 'right';\r\n\r\n        // if gpuAcceleration is set to `true` and transform is supported,\r\n        //  we use `translate3d` to apply the position to the popper we\r\n        // automatically use the supported prefixed version if needed\r\n        var prefixedProperty = getSupportedPropertyName('transform');\r\n\r\n        // now, let's make a step back and look at this code closely (wtf?)\r\n        // If the content of the popper grows once it's been positioned, it\r\n        // may happen that the popper gets misplaced because of the new content\r\n        // overflowing its reference element\r\n        // To avoid this problem, we provide two options (x and y), which allow\r\n        // the consumer to define the offset origin.\r\n        // If we position a popper on top of a reference element, we can set\r\n        // `x` to `top` to make the popper grow towards its top instead of\r\n        // its bottom.\r\n        var left = void 0,\r\n            top = void 0;\r\n        if (sideA === 'bottom') {\r\n            top = -offsetParentRect.height + offsets.bottom;\r\n        } else {\r\n            top = offsets.top;\r\n        }\r\n        if (sideB === 'right') {\r\n            left = -offsetParentRect.width + offsets.right;\r\n        } else {\r\n            left = offsets.left;\r\n        }\r\n        if (gpuAcceleration && prefixedProperty) {\r\n            styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\r\n            styles[sideA] = 0;\r\n            styles[sideB] = 0;\r\n            styles.willChange = 'transform';\r\n        } else {\r\n            // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\r\n            var invertTop = sideA === 'bottom' ? -1 : 1;\r\n            var invertLeft = sideB === 'right' ? -1 : 1;\r\n            styles[sideA] = top * invertTop;\r\n            styles[sideB] = left * invertLeft;\r\n            styles.willChange = sideA + ', ' + sideB;\r\n        }\r\n\r\n        // Attributes\r\n        var attributes = {\r\n            'x-placement': data.placement\r\n        };\r\n\r\n        // Update `data` attributes, styles and arrowStyles\r\n        data.attributes = _extends({}, attributes, data.attributes);\r\n        data.styles = _extends({}, styles, data.styles);\r\n        data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Helper used to know if the given modifier depends from another one.<br />\r\n     * It checks if the needed modifier is listed and enabled.\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @param {Array} modifiers - list of modifiers\r\n     * @param {String} requestingName - name of requesting modifier\r\n     * @param {String} requestedName - name of requested modifier\r\n     * @returns {Boolean}\r\n     */\r\n    function isModifierRequired(modifiers, requestingName, requestedName) {\r\n        var requesting = find(modifiers, function (_ref) {\r\n            var name = _ref.name;\r\n            return name === requestingName;\r\n        });\r\n\r\n        var isRequired = !!requesting && modifiers.some(function (modifier) {\r\n            return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\r\n        });\r\n\r\n        if (!isRequired) {\r\n            var _requesting = '`' + requestingName + '`';\r\n            var requested = '`' + requestedName + '`';\r\n            console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');\r\n        }\r\n        return isRequired;\r\n    }\r\n\r\n    /**\r\n     * @function\r\n     * @memberof Modifiers\r\n     * @argument {Object} data - The data object generated by update method\r\n     * @argument {Object} options - Modifiers configuration and options\r\n     * @returns {Object} The data object, properly modified\r\n     */\r\n    function arrow(data, options) {\r\n        var _data$offsets$arrow;\r\n\r\n        // arrow depends on keepTogether in order to work\r\n        if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\r\n            return data;\r\n        }\r\n\r\n        var arrowElement = options.element;\r\n\r\n        // if arrowElement is a string, suppose it's a CSS selector\r\n        if (typeof arrowElement === 'string') {\r\n            arrowElement = data.instance.popper.querySelector(arrowElement);\r\n\r\n            // if arrowElement is not found, don't run the modifier\r\n            if (!arrowElement) {\r\n                return data;\r\n            }\r\n        } else {\r\n            // if the arrowElement isn't a query selector we must check that the\r\n            // provided DOM node is child of its popper node\r\n            if (!data.instance.popper.contains(arrowElement)) {\r\n                console.warn('WARNING: `arrow.element` must be child of its popper element!');\r\n                return data;\r\n            }\r\n        }\r\n\r\n        var placement = data.placement.split('-')[0];\r\n        var _data$offsets = data.offsets,\r\n            popper = _data$offsets.popper,\r\n            reference = _data$offsets.reference;\r\n\r\n        var isVertical = ['left', 'right'].indexOf(placement) !== -1;\r\n\r\n        var len = isVertical ? 'height' : 'width';\r\n        var sideCapitalized = isVertical ? 'Top' : 'Left';\r\n        var side = sideCapitalized.toLowerCase();\r\n        var altSide = isVertical ? 'left' : 'top';\r\n        var opSide = isVertical ? 'bottom' : 'right';\r\n        var arrowElementSize = getOuterSizes(arrowElement)[len];\r\n\r\n        //\r\n        // extends keepTogether behavior making sure the popper and its\r\n        // reference have enough pixels in conjuction\r\n        //\r\n\r\n        // top/left side\r\n        if (reference[opSide] - arrowElementSize < popper[side]) {\r\n            data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\r\n        }\r\n        // bottom/right side\r\n        if (reference[side] + arrowElementSize > popper[opSide]) {\r\n            data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\r\n        }\r\n        data.offsets.popper = getClientRect(data.offsets.popper);\r\n\r\n        // compute center of the popper\r\n        var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\r\n\r\n        // Compute the sideValue using the updated popper offsets\r\n        // take popper margin in account because we don't have this info available\r\n        var css = getStyleComputedProperty(data.instance.popper);\r\n        var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);\r\n        var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);\r\n        var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\r\n\r\n        // prevent arrowElement from being placed not contiguously to its popper\r\n        sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\r\n\r\n        data.arrowElement = arrowElement;\r\n        data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Get the opposite placement variation of the given one\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @argument {String} placement variation\r\n     * @returns {String} flipped placement variation\r\n     */\r\n    function getOppositeVariation(variation) {\r\n        if (variation === 'end') {\r\n            return 'start';\r\n        } else if (variation === 'start') {\r\n            return 'end';\r\n        }\r\n        return variation;\r\n    }\r\n\r\n    /**\r\n     * List of accepted placements to use as values of the `placement` option.<br />\r\n     * Valid placements are:\r\n     * - `auto`\r\n     * - `top`\r\n     * - `right`\r\n     * - `bottom`\r\n     * - `left`\r\n     *\r\n     * Each placement can have a variation from this list:\r\n     * - `-start`\r\n     * - `-end`\r\n     *\r\n     * Variations are interpreted easily if you think of them as the left to right\r\n     * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\r\n     * is right.<br />\r\n     * Vertically (`left` and `right`), `start` is top and `end` is bottom.\r\n     *\r\n     * Some valid examples are:\r\n     * - `top-end` (on top of reference, right aligned)\r\n     * - `right-start` (on right of reference, top aligned)\r\n     * - `bottom` (on bottom, centered)\r\n     * - `auto-right` (on the side with more space available, alignment depends by placement)\r\n     *\r\n     * @static\r\n     * @type {Array}\r\n     * @enum {String}\r\n     * @readonly\r\n     * @method placements\r\n     * @memberof Popper\r\n     */\r\n    var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\r\n\r\n// Get rid of `auto` `auto-start` and `auto-end`\r\n    var validPlacements = placements.slice(3);\r\n\r\n    /**\r\n     * Given an initial placement, returns all the subsequent placements\r\n     * clockwise (or counter-clockwise).\r\n     *\r\n     * @method\r\n     * @memberof Popper.Utils\r\n     * @argument {String} placement - A valid placement (it accepts variations)\r\n     * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\r\n     * @returns {Array} placements including their variations\r\n     */\r\n    function clockwise(placement) {\r\n        var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\r\n\r\n        var index = validPlacements.indexOf(placement);\r\n        var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\r\n        return counter ? arr.reverse() : arr;\r\n    }\r\n\r\n    var BEHAVIORS = {\r\n        FLIP: 'flip',\r\n        CLOCKWISE: 'clockwise',\r\n        COUNTERCLOCKWISE: 'counterclockwise'\r\n    };\r\n\r\n    /**\r\n     * @function\r\n     * @memberof Modifiers\r\n     * @argument {Object} data - The data object generated by update method\r\n     * @argument {Object} options - Modifiers configuration and options\r\n     * @returns {Object} The data object, properly modified\r\n     */\r\n    function flip(data, options) {\r\n        // if `inner` modifier is enabled, we can't use the `flip` modifier\r\n        if (isModifierEnabled(data.instance.modifiers, 'inner')) {\r\n            return data;\r\n        }\r\n\r\n        if (data.flipped && data.placement === data.originalPlacement) {\r\n            // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\r\n            return data;\r\n        }\r\n\r\n        var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);\r\n\r\n        var placement = data.placement.split('-')[0];\r\n        var placementOpposite = getOppositePlacement(placement);\r\n        var variation = data.placement.split('-')[1] || '';\r\n\r\n        var flipOrder = [];\r\n\r\n        switch (options.behavior) {\r\n            case BEHAVIORS.FLIP:\r\n                flipOrder = [placement, placementOpposite];\r\n                break;\r\n            case BEHAVIORS.CLOCKWISE:\r\n                flipOrder = clockwise(placement);\r\n                break;\r\n            case BEHAVIORS.COUNTERCLOCKWISE:\r\n                flipOrder = clockwise(placement, true);\r\n                break;\r\n            default:\r\n                flipOrder = options.behavior;\r\n        }\r\n\r\n        flipOrder.forEach(function (step, index) {\r\n            if (placement !== step || flipOrder.length === index + 1) {\r\n                return data;\r\n            }\r\n\r\n            placement = data.placement.split('-')[0];\r\n            placementOpposite = getOppositePlacement(placement);\r\n\r\n            var popperOffsets = data.offsets.popper;\r\n            var refOffsets = data.offsets.reference;\r\n\r\n            // using floor because the reference offsets may contain decimals we are not going to consider here\r\n            var floor = Math.floor;\r\n            var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\r\n\r\n            var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\r\n            var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\r\n            var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\r\n            var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\r\n\r\n            var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\r\n\r\n            // flip the variation if required\r\n            var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\r\n            var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\r\n\r\n            if (overlapsRef || overflowsBoundaries || flippedVariation) {\r\n                // this boolean to detect any flip loop\r\n                data.flipped = true;\r\n\r\n                if (overlapsRef || overflowsBoundaries) {\r\n                    placement = flipOrder[index + 1];\r\n                }\r\n\r\n                if (flippedVariation) {\r\n                    variation = getOppositeVariation(variation);\r\n                }\r\n\r\n                data.placement = placement + (variation ? '-' + variation : '');\r\n\r\n                // this object contains `position`, we want to preserve it along with\r\n                // any additional property we may add in the future\r\n                data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\r\n\r\n                data = runModifiers(data.instance.modifiers, data, 'flip');\r\n            }\r\n        });\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * @function\r\n     * @memberof Modifiers\r\n     * @argument {Object} data - The data object generated by update method\r\n     * @argument {Object} options - Modifiers configuration and options\r\n     * @returns {Object} The data object, properly modified\r\n     */\r\n    function keepTogether(data) {\r\n        var _data$offsets = data.offsets,\r\n            popper = _data$offsets.popper,\r\n            reference = _data$offsets.reference;\r\n\r\n        var placement = data.placement.split('-')[0];\r\n        var floor = Math.floor;\r\n        var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\r\n        var side = isVertical ? 'right' : 'bottom';\r\n        var opSide = isVertical ? 'left' : 'top';\r\n        var measurement = isVertical ? 'width' : 'height';\r\n\r\n        if (popper[side] < floor(reference[opSide])) {\r\n            data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\r\n        }\r\n        if (popper[opSide] > floor(reference[side])) {\r\n            data.offsets.popper[opSide] = floor(reference[side]);\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Converts a string containing value + unit into a px value number\r\n     * @function\r\n     * @memberof {modifiers~offset}\r\n     * @private\r\n     * @argument {String} str - Value + unit string\r\n     * @argument {String} measurement - `height` or `width`\r\n     * @argument {Object} popperOffsets\r\n     * @argument {Object} referenceOffsets\r\n     * @returns {Number|String}\r\n     * Value in pixels, or original string if no values were extracted\r\n     */\r\n    function toValue(str, measurement, popperOffsets, referenceOffsets) {\r\n        // separate value from unit\r\n        var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\r\n        var value = +split[1];\r\n        var unit = split[2];\r\n\r\n        // If it's not a number it's an operator, I guess\r\n        if (!value) {\r\n            return str;\r\n        }\r\n\r\n        if (unit.indexOf('%') === 0) {\r\n            var element = void 0;\r\n            switch (unit) {\r\n                case '%p':\r\n                    element = popperOffsets;\r\n                    break;\r\n                case '%':\r\n                case '%r':\r\n                default:\r\n                    element = referenceOffsets;\r\n            }\r\n\r\n            var rect = getClientRect(element);\r\n            return rect[measurement] / 100 * value;\r\n        } else if (unit === 'vh' || unit === 'vw') {\r\n            // if is a vh or vw, we calculate the size based on the viewport\r\n            var size = void 0;\r\n            if (unit === 'vh') {\r\n                size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\r\n            } else {\r\n                size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\r\n            }\r\n            return size / 100 * value;\r\n        } else {\r\n            // if is an explicit pixel unit, we get rid of the unit and keep the value\r\n            // if is an implicit unit, it's px, and we return just the value\r\n            return value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\r\n     * @function\r\n     * @memberof {modifiers~offset}\r\n     * @private\r\n     * @argument {String} offset\r\n     * @argument {Object} popperOffsets\r\n     * @argument {Object} referenceOffsets\r\n     * @argument {String} basePlacement\r\n     * @returns {Array} a two cells array with x and y offsets in numbers\r\n     */\r\n    function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\r\n        var offsets = [0, 0];\r\n\r\n        // Use height if placement is left or right and index is 0 otherwise use width\r\n        // in this way the first offset will use an axis and the second one\r\n        // will use the other one\r\n        var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\r\n\r\n        // Split the offset string to obtain a list of values and operands\r\n        // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\r\n        var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\r\n            return frag.trim();\r\n        });\r\n\r\n        // Detect if the offset string contains a pair of values or a single one\r\n        // they could be separated by comma or space\r\n        var divider = fragments.indexOf(find(fragments, function (frag) {\r\n            return frag.search(/,|\\s/) !== -1;\r\n        }));\r\n\r\n        if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\r\n            console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\r\n        }\r\n\r\n        // If divider is found, we divide the list of values and operands to divide\r\n        // them by ofset X and Y.\r\n        var splitRegex = /\\s*,\\s*|\\s+/;\r\n        var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];\r\n\r\n        // Convert the values with units to absolute pixels to allow our computations\r\n        ops = ops.map(function (op, index) {\r\n            // Most of the units rely on the orientation of the popper\r\n            var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';\r\n            var mergeWithPrevious = false;\r\n            return op\r\n            // This aggregates any `+` or `-` sign that aren't considered operators\r\n            // e.g.: 10 + +5 => [10, +, +5]\r\n                .reduce(function (a, b) {\r\n                    if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\r\n                        a[a.length - 1] = b;\r\n                        mergeWithPrevious = true;\r\n                        return a;\r\n                    } else if (mergeWithPrevious) {\r\n                        a[a.length - 1] += b;\r\n                        mergeWithPrevious = false;\r\n                        return a;\r\n                    } else {\r\n                        return a.concat(b);\r\n                    }\r\n                }, [])\r\n                // Here we convert the string values into number values (in px)\r\n                .map(function (str) {\r\n                    return toValue(str, measurement, popperOffsets, referenceOffsets);\r\n                });\r\n        });\r\n\r\n        // Loop trough the offsets arrays and execute the operations\r\n        ops.forEach(function (op, index) {\r\n            op.forEach(function (frag, index2) {\r\n                if (isNumeric(frag)) {\r\n                    offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\r\n                }\r\n            });\r\n        });\r\n        return offsets;\r\n    }\r\n\r\n    /**\r\n     * @function\r\n     * @memberof Modifiers\r\n     * @argument {Object} data - The data object generated by update method\r\n     * @argument {Object} options - Modifiers configuration and options\r\n     * @argument {Number|String} options.offset=0\r\n     * The offset value as described in the modifier description\r\n     * @returns {Object} The data object, properly modified\r\n     */\r\n    function offset(data, _ref) {\r\n        var offset = _ref.offset;\r\n        var placement = data.placement,\r\n            _data$offsets = data.offsets,\r\n            popper = _data$offsets.popper,\r\n            reference = _data$offsets.reference;\r\n\r\n        var basePlacement = placement.split('-')[0];\r\n\r\n        var offsets = void 0;\r\n        if (isNumeric(+offset)) {\r\n            offsets = [+offset, 0];\r\n        } else {\r\n            offsets = parseOffset(offset, popper, reference, basePlacement);\r\n        }\r\n\r\n        if (basePlacement === 'left') {\r\n            popper.top += offsets[0];\r\n            popper.left -= offsets[1];\r\n        } else if (basePlacement === 'right') {\r\n            popper.top += offsets[0];\r\n            popper.left += offsets[1];\r\n        } else if (basePlacement === 'top') {\r\n            popper.left += offsets[0];\r\n            popper.top -= offsets[1];\r\n        } else if (basePlacement === 'bottom') {\r\n            popper.left += offsets[0];\r\n            popper.top += offsets[1];\r\n        }\r\n\r\n        data.popper = popper;\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * @function\r\n     * @memberof Modifiers\r\n     * @argument {Object} data - The data object generated by `update` method\r\n     * @argument {Object} options - Modifiers configuration and options\r\n     * @returns {Object} The data object, properly modified\r\n     */\r\n    function preventOverflow(data, options) {\r\n        var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\r\n\r\n        // If offsetParent is the reference element, we really want to\r\n        // go one step up and use the next offsetParent as reference to\r\n        // avoid to make this modifier completely useless and look like broken\r\n        if (data.instance.reference === boundariesElement) {\r\n            boundariesElement = getOffsetParent(boundariesElement);\r\n        }\r\n\r\n        // NOTE: DOM access here\r\n        // resets the popper's position so that the document size can be calculated excluding\r\n        // the size of the popper element itself\r\n        var transformProp = getSupportedPropertyName('transform');\r\n        var popperStyles = data.instance.popper.style; // assignment to help minification\r\n        var top = popperStyles.top,\r\n            left = popperStyles.left,\r\n            transform = popperStyles[transformProp];\r\n\r\n        popperStyles.top = '';\r\n        popperStyles.left = '';\r\n        popperStyles[transformProp] = '';\r\n\r\n        var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);\r\n\r\n        // NOTE: DOM access here\r\n        // restores the original style properties after the offsets have been computed\r\n        popperStyles.top = top;\r\n        popperStyles.left = left;\r\n        popperStyles[transformProp] = transform;\r\n\r\n        options.boundaries = boundaries;\r\n\r\n        var order = options.priority;\r\n        var popper = data.offsets.popper;\r\n\r\n        var check = {\r\n            primary: function primary(placement) {\r\n                var value = popper[placement];\r\n                if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\r\n                    value = Math.max(popper[placement], boundaries[placement]);\r\n                }\r\n                return defineProperty({}, placement, value);\r\n            },\r\n            secondary: function secondary(placement) {\r\n                var mainSide = placement === 'right' ? 'left' : 'top';\r\n                var value = popper[mainSide];\r\n                if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\r\n                    value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\r\n                }\r\n                return defineProperty({}, mainSide, value);\r\n            }\r\n        };\r\n\r\n        order.forEach(function (placement) {\r\n            var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\r\n            popper = _extends({}, popper, check[side](placement));\r\n        });\r\n\r\n        data.offsets.popper = popper;\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * @function\r\n     * @memberof Modifiers\r\n     * @argument {Object} data - The data object generated by `update` method\r\n     * @argument {Object} options - Modifiers configuration and options\r\n     * @returns {Object} The data object, properly modified\r\n     */\r\n    function shift(data) {\r\n        var placement = data.placement;\r\n        var basePlacement = placement.split('-')[0];\r\n        var shiftvariation = placement.split('-')[1];\r\n\r\n        // if shift shiftvariation is specified, run the modifier\r\n        if (shiftvariation) {\r\n            var _data$offsets = data.offsets,\r\n                reference = _data$offsets.reference,\r\n                popper = _data$offsets.popper;\r\n\r\n            var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\r\n            var side = isVertical ? 'left' : 'top';\r\n            var measurement = isVertical ? 'width' : 'height';\r\n\r\n            var shiftOffsets = {\r\n                start: defineProperty({}, side, reference[side]),\r\n                end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\r\n            };\r\n\r\n            data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * @function\r\n     * @memberof Modifiers\r\n     * @argument {Object} data - The data object generated by update method\r\n     * @argument {Object} options - Modifiers configuration and options\r\n     * @returns {Object} The data object, properly modified\r\n     */\r\n    function hide(data) {\r\n        if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\r\n            return data;\r\n        }\r\n\r\n        var refRect = data.offsets.reference;\r\n        var bound = find(data.instance.modifiers, function (modifier) {\r\n            return modifier.name === 'preventOverflow';\r\n        }).boundaries;\r\n\r\n        if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\r\n            // Avoid unnecessary DOM access if visibility hasn't changed\r\n            if (data.hide === true) {\r\n                return data;\r\n            }\r\n\r\n            data.hide = true;\r\n            data.attributes['x-out-of-boundaries'] = '';\r\n        } else {\r\n            // Avoid unnecessary DOM access if visibility hasn't changed\r\n            if (data.hide === false) {\r\n                return data;\r\n            }\r\n\r\n            data.hide = false;\r\n            data.attributes['x-out-of-boundaries'] = false;\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * @function\r\n     * @memberof Modifiers\r\n     * @argument {Object} data - The data object generated by `update` method\r\n     * @argument {Object} options - Modifiers configuration and options\r\n     * @returns {Object} The data object, properly modified\r\n     */\r\n    function inner(data) {\r\n        var placement = data.placement;\r\n        var basePlacement = placement.split('-')[0];\r\n        var _data$offsets = data.offsets,\r\n            popper = _data$offsets.popper,\r\n            reference = _data$offsets.reference;\r\n\r\n        var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\r\n\r\n        var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\r\n\r\n        popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\r\n\r\n        data.placement = getOppositePlacement(placement);\r\n        data.offsets.popper = getClientRect(popper);\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Modifier function, each modifier can have a function of this type assigned\r\n     * to its `fn` property.<br />\r\n     * These functions will be called on each update, this means that you must\r\n     * make sure they are performant enough to avoid performance bottlenecks.\r\n     *\r\n     * @function ModifierFn\r\n     * @argument {dataObject} data - The data object generated by `update` method\r\n     * @argument {Object} options - Modifiers configuration and options\r\n     * @returns {dataObject} The data object, properly modified\r\n     */\r\n\r\n    /**\r\n     * Modifiers are plugins used to alter the behavior of your poppers.<br />\r\n     * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\r\n     * needed by the library.\r\n     *\r\n     * Usually you don't want to override the `order`, `fn` and `onLoad` props.\r\n     * All the other properties are configurations that could be tweaked.\r\n     * @namespace modifiers\r\n     */\r\n    var modifiers = {\r\n        /**\r\n         * Modifier used to shift the popper on the start or end of its reference\r\n         * element.<br />\r\n         * It will read the variation of the `placement` property.<br />\r\n         * It can be one either `-end` or `-start`.\r\n         * @memberof modifiers\r\n         * @inner\r\n         */\r\n        shift: {\r\n            /** @prop {number} order=100 - Index used to define the order of execution */\r\n            order: 100,\r\n            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\r\n            enabled: true,\r\n            /** @prop {ModifierFn} */\r\n            fn: shift\r\n        },\r\n\r\n        /**\r\n         * The `offset` modifier can shift your popper on both its axis.\r\n         *\r\n         * It accepts the following units:\r\n         * - `px` or unitless, interpreted as pixels\r\n         * - `%` or `%r`, percentage relative to the length of the reference element\r\n         * - `%p`, percentage relative to the length of the popper element\r\n         * - `vw`, CSS viewport width unit\r\n         * - `vh`, CSS viewport height unit\r\n         *\r\n         * For length is intended the main axis relative to the placement of the popper.<br />\r\n         * This means that if the placement is `top` or `bottom`, the length will be the\r\n         * `width`. In case of `left` or `right`, it will be the height.\r\n         *\r\n         * You can provide a single value (as `Number` or `String`), or a pair of values\r\n         * as `String` divided by a comma or one (or more) white spaces.<br />\r\n         * The latter is a deprecated method because it leads to confusion and will be\r\n         * removed in v2.<br />\r\n         * Additionally, it accepts additions and subtractions between different units.\r\n         * Note that multiplications and divisions aren't supported.\r\n         *\r\n         * Valid examples are:\r\n         * ```\r\n         * 10\r\n         * '10%'\r\n         * '10, 10'\r\n         * '10%, 10'\r\n         * '10 + 10%'\r\n         * '10 - 5vh + 3%'\r\n         * '-10px + 5vh, 5px - 6%'\r\n         * ```\r\n         * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\r\n         * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\r\n         * > More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)\r\n         *\r\n         * @memberof modifiers\r\n         * @inner\r\n         */\r\n        offset: {\r\n            /** @prop {number} order=200 - Index used to define the order of execution */\r\n            order: 200,\r\n            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\r\n            enabled: true,\r\n            /** @prop {ModifierFn} */\r\n            fn: offset,\r\n            /** @prop {Number|String} offset=0\r\n             * The offset value as described in the modifier description\r\n             */\r\n            offset: 0\r\n        },\r\n\r\n        /**\r\n         * Modifier used to prevent the popper from being positioned outside the boundary.\r\n         *\r\n         * An scenario exists where the reference itself is not within the boundaries.<br />\r\n         * We can say it has \"escaped the boundaries\" \u2014 or just \"escaped\".<br />\r\n         * In this case we need to decide whether the popper should either:\r\n         *\r\n         * - detach from the reference and remain \"trapped\" in the boundaries, or\r\n         * - if it should ignore the boundary and \"escape with its reference\"\r\n         *\r\n         * When `escapeWithReference` is set to`true` and reference is completely\r\n         * outside its boundaries, the popper will overflow (or completely leave)\r\n         * the boundaries in order to remain attached to the edge of the reference.\r\n         *\r\n         * @memberof modifiers\r\n         * @inner\r\n         */\r\n        preventOverflow: {\r\n            /** @prop {number} order=300 - Index used to define the order of execution */\r\n            order: 300,\r\n            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\r\n            enabled: true,\r\n            /** @prop {ModifierFn} */\r\n            fn: preventOverflow,\r\n            /**\r\n             * @prop {Array} [priority=['left','right','top','bottom']]\r\n             * Popper will try to prevent overflow following these priorities by default,\r\n             * then, it could overflow on the left and on top of the `boundariesElement`\r\n             */\r\n            priority: ['left', 'right', 'top', 'bottom'],\r\n            /**\r\n             * @prop {number} padding=5\r\n             * Amount of pixel used to define a minimum distance between the boundaries\r\n             * and the popper this makes sure the popper has always a little padding\r\n             * between the edges of its container\r\n             */\r\n            padding: 5,\r\n            /**\r\n             * @prop {String|HTMLElement} boundariesElement='scrollParent'\r\n             * Boundaries used by the modifier, can be `scrollParent`, `window`,\r\n             * `viewport` or any DOM element.\r\n             */\r\n            boundariesElement: 'scrollParent'\r\n        },\r\n\r\n        /**\r\n         * Modifier used to make sure the reference and its popper stay near eachothers\r\n         * without leaving any gap between the two. Expecially useful when the arrow is\r\n         * enabled and you want to assure it to point to its reference element.\r\n         * It cares only about the first axis, you can still have poppers with margin\r\n         * between the popper and its reference element.\r\n         * @memberof modifiers\r\n         * @inner\r\n         */\r\n        keepTogether: {\r\n            /** @prop {number} order=400 - Index used to define the order of execution */\r\n            order: 400,\r\n            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\r\n            enabled: true,\r\n            /** @prop {ModifierFn} */\r\n            fn: keepTogether\r\n        },\r\n\r\n        /**\r\n         * This modifier is used to move the `arrowElement` of the popper to make\r\n         * sure it is positioned between the reference element and its popper element.\r\n         * It will read the outer size of the `arrowElement` node to detect how many\r\n         * pixels of conjuction are needed.\r\n         *\r\n         * It has no effect if no `arrowElement` is provided.\r\n         * @memberof modifiers\r\n         * @inner\r\n         */\r\n        arrow: {\r\n            /** @prop {number} order=500 - Index used to define the order of execution */\r\n            order: 500,\r\n            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\r\n            enabled: true,\r\n            /** @prop {ModifierFn} */\r\n            fn: arrow,\r\n            /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\r\n            element: '[x-arrow]'\r\n        },\r\n\r\n        /**\r\n         * Modifier used to flip the popper's placement when it starts to overlap its\r\n         * reference element.\r\n         *\r\n         * Requires the `preventOverflow` modifier before it in order to work.\r\n         *\r\n         * **NOTE:** this modifier will interrupt the current update cycle and will\r\n         * restart it if it detects the need to flip the placement.\r\n         * @memberof modifiers\r\n         * @inner\r\n         */\r\n        flip: {\r\n            /** @prop {number} order=600 - Index used to define the order of execution */\r\n            order: 600,\r\n            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\r\n            enabled: true,\r\n            /** @prop {ModifierFn} */\r\n            fn: flip,\r\n            /**\r\n             * @prop {String|Array} behavior='flip'\r\n             * The behavior used to change the popper's placement. It can be one of\r\n             * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\r\n             * placements (with optional variations).\r\n             */\r\n            behavior: 'flip',\r\n            /**\r\n             * @prop {number} padding=5\r\n             * The popper will flip if it hits the edges of the `boundariesElement`\r\n             */\r\n            padding: 5,\r\n            /**\r\n             * @prop {String|HTMLElement} boundariesElement='viewport'\r\n             * The element which will define the boundaries of the popper position,\r\n             * the popper will never be placed outside of the defined boundaries\r\n             * (except if keepTogether is enabled)\r\n             */\r\n            boundariesElement: 'viewport'\r\n        },\r\n\r\n        /**\r\n         * Modifier used to make the popper flow toward the inner of the reference element.\r\n         * By default, when this modifier is disabled, the popper will be placed outside\r\n         * the reference element.\r\n         * @memberof modifiers\r\n         * @inner\r\n         */\r\n        inner: {\r\n            /** @prop {number} order=700 - Index used to define the order of execution */\r\n            order: 700,\r\n            /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\r\n            enabled: false,\r\n            /** @prop {ModifierFn} */\r\n            fn: inner\r\n        },\r\n\r\n        /**\r\n         * Modifier used to hide the popper when its reference element is outside of the\r\n         * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\r\n         * be used to hide with a CSS selector the popper when its reference is\r\n         * out of boundaries.\r\n         *\r\n         * Requires the `preventOverflow` modifier before it in order to work.\r\n         * @memberof modifiers\r\n         * @inner\r\n         */\r\n        hide: {\r\n            /** @prop {number} order=800 - Index used to define the order of execution */\r\n            order: 800,\r\n            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\r\n            enabled: true,\r\n            /** @prop {ModifierFn} */\r\n            fn: hide\r\n        },\r\n\r\n        /**\r\n         * Computes the style that will be applied to the popper element to gets\r\n         * properly positioned.\r\n         *\r\n         * Note that this modifier will not touch the DOM, it just prepares the styles\r\n         * so that `applyStyle` modifier can apply it. This separation is useful\r\n         * in case you need to replace `applyStyle` with a custom implementation.\r\n         *\r\n         * This modifier has `850` as `order` value to maintain backward compatibility\r\n         * with previous versions of Popper.js. Expect the modifiers ordering method\r\n         * to change in future major versions of the library.\r\n         *\r\n         * @memberof modifiers\r\n         * @inner\r\n         */\r\n        computeStyle: {\r\n            /** @prop {number} order=850 - Index used to define the order of execution */\r\n            order: 850,\r\n            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\r\n            enabled: true,\r\n            /** @prop {ModifierFn} */\r\n            fn: computeStyle,\r\n            /**\r\n             * @prop {Boolean} gpuAcceleration=true\r\n             * If true, it uses the CSS 3d transformation to position the popper.\r\n             * Otherwise, it will use the `top` and `left` properties.\r\n             */\r\n            gpuAcceleration: true,\r\n            /**\r\n             * @prop {string} [x='bottom']\r\n             * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\r\n             * Change this if your popper should grow in a direction different from `bottom`\r\n             */\r\n            x: 'bottom',\r\n            /**\r\n             * @prop {string} [x='left']\r\n             * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\r\n             * Change this if your popper should grow in a direction different from `right`\r\n             */\r\n            y: 'right'\r\n        },\r\n\r\n        /**\r\n         * Applies the computed styles to the popper element.\r\n         *\r\n         * All the DOM manipulations are limited to this modifier. This is useful in case\r\n         * you want to integrate Popper.js inside a framework or view library and you\r\n         * want to delegate all the DOM manipulations to it.\r\n         *\r\n         * Note that if you disable this modifier, you must make sure the popper element\r\n         * has its position set to `absolute` before Popper.js can do its work!\r\n         *\r\n         * Just disable this modifier and define you own to achieve the desired effect.\r\n         *\r\n         * @memberof modifiers\r\n         * @inner\r\n         */\r\n        applyStyle: {\r\n            /** @prop {number} order=900 - Index used to define the order of execution */\r\n            order: 900,\r\n            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\r\n            enabled: true,\r\n            /** @prop {ModifierFn} */\r\n            fn: applyStyle,\r\n            /** @prop {Function} */\r\n            onLoad: applyStyleOnLoad,\r\n            /**\r\n             * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\r\n             * @prop {Boolean} gpuAcceleration=true\r\n             * If true, it uses the CSS 3d transformation to position the popper.\r\n             * Otherwise, it will use the `top` and `left` properties.\r\n             */\r\n            gpuAcceleration: undefined\r\n        }\r\n    };\r\n\r\n    /**\r\n     * The `dataObject` is an object containing all the informations used by Popper.js\r\n     * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\r\n     * @name dataObject\r\n     * @property {Object} data.instance The Popper.js instance\r\n     * @property {String} data.placement Placement applied to popper\r\n     * @property {String} data.originalPlacement Placement originally defined on init\r\n     * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\r\n     * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.\r\n     * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\r\n     * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)\r\n     * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)\r\n     * @property {Object} data.boundaries Offsets of the popper boundaries\r\n     * @property {Object} data.offsets The measurements of popper, reference and arrow elements.\r\n     * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\r\n     * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\r\n     * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\r\n     */\r\n\r\n    /**\r\n     * Default options provided to Popper.js constructor.<br />\r\n     * These can be overriden using the `options` argument of Popper.js.<br />\r\n     * To override an option, simply pass as 3rd argument an object with the same\r\n     * structure of this object, example:\r\n     * ```\r\n     * new Popper(ref, pop, {\r\n     *   modifiers: {\r\n     *     preventOverflow: { enabled: false }\r\n     *   }\r\n     * })\r\n     * ```\r\n     * @type {Object}\r\n     * @static\r\n     * @memberof Popper\r\n     */\r\n    var Defaults = {\r\n        /**\r\n         * Popper's placement\r\n         * @prop {Popper.placements} placement='bottom'\r\n         */\r\n        placement: 'bottom',\r\n\r\n        /**\r\n         * Set this to true if you want popper to position it self in 'fixed' mode\r\n         * @prop {Boolean} positionFixed=false\r\n         */\r\n        positionFixed: false,\r\n\r\n        /**\r\n         * Whether events (resize, scroll) are initially enabled\r\n         * @prop {Boolean} eventsEnabled=true\r\n         */\r\n        eventsEnabled: true,\r\n\r\n        /**\r\n         * Set to true if you want to automatically remove the popper when\r\n         * you call the `destroy` method.\r\n         * @prop {Boolean} removeOnDestroy=false\r\n         */\r\n        removeOnDestroy: false,\r\n\r\n        /**\r\n         * Callback called when the popper is created.<br />\r\n         * By default, is set to no-op.<br />\r\n         * Access Popper.js instance with `data.instance`.\r\n         * @prop {onCreate}\r\n         */\r\n        onCreate: function onCreate() {\r\n        },\r\n\r\n        /**\r\n         * Callback called when the popper is updated, this callback is not called\r\n         * on the initialization/creation of the popper, but only on subsequent\r\n         * updates.<br />\r\n         * By default, is set to no-op.<br />\r\n         * Access Popper.js instance with `data.instance`.\r\n         * @prop {onUpdate}\r\n         */\r\n        onUpdate: function onUpdate() {\r\n        },\r\n\r\n        /**\r\n         * List of modifiers used to modify the offsets before they are applied to the popper.\r\n         * They provide most of the functionalities of Popper.js\r\n         * @prop {modifiers}\r\n         */\r\n        modifiers: modifiers\r\n    };\r\n\r\n    /**\r\n     * @callback onCreate\r\n     * @param {dataObject} data\r\n     */\r\n\r\n    /**\r\n     * @callback onUpdate\r\n     * @param {dataObject} data\r\n     */\r\n\r\n// Utils\r\n// Methods\r\n    var Popper = function () {\r\n        /**\r\n         * Create a new Popper.js instance\r\n         * @class Popper\r\n         * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper\r\n         * @param {HTMLElement} popper - The HTML element used as popper.\r\n         * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\r\n         * @return {Object} instance - The generated Popper.js instance\r\n         */\r\n        function Popper(reference, popper) {\r\n            var _this = this;\r\n\r\n            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n            classCallCheck(this, Popper);\r\n\r\n            this.scheduleUpdate = function () {\r\n                return requestAnimationFrame(_this.update);\r\n            };\r\n\r\n            // make update() debounced, so that it only runs at most once-per-tick\r\n            this.update = debounce(this.update.bind(this));\r\n\r\n            // with {} we create a new object with the options inside it\r\n            this.options = _extends({}, Popper.Defaults, options);\r\n\r\n            // init state\r\n            this.state = {\r\n                isDestroyed: false,\r\n                isCreated: false,\r\n                scrollParents: []\r\n            };\r\n\r\n            // get reference and popper elements (allow jQuery wrappers)\r\n            this.reference = reference && reference.jquery ? reference[0] : reference;\r\n            this.popper = popper && popper.jquery ? popper[0] : popper;\r\n\r\n            // Deep merge modifiers options\r\n            this.options.modifiers = {};\r\n            Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\r\n                _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\r\n            });\r\n\r\n            // Refactoring modifiers' list (Object => Array)\r\n            this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\r\n                return _extends({\r\n                    name: name\r\n                }, _this.options.modifiers[name]);\r\n            })\r\n            // sort the modifiers by order\r\n                .sort(function (a, b) {\r\n                    return a.order - b.order;\r\n                });\r\n\r\n            // modifiers have the ability to execute arbitrary code when Popper.js get inited\r\n            // such code is executed in the same order of its modifier\r\n            // they could add new properties to their options configuration\r\n            // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\r\n            this.modifiers.forEach(function (modifierOptions) {\r\n                if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\r\n                    modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\r\n                }\r\n            });\r\n\r\n            // fire the first update to position the popper in the right place\r\n            this.update();\r\n\r\n            var eventsEnabled = this.options.eventsEnabled;\r\n            if (eventsEnabled) {\r\n                // setup event listeners, they will take care of update the position in specific situations\r\n                this.enableEventListeners();\r\n            }\r\n\r\n            this.state.eventsEnabled = eventsEnabled;\r\n        }\r\n\r\n        // We can't use class properties because they don't get listed in the\r\n        // class prototype and break stuff like Sinon stubs\r\n\r\n\r\n        createClass(Popper, [{\r\n            key: 'update',\r\n            value: function update$$1() {\r\n                return update.call(this);\r\n            }\r\n        }, {\r\n            key: 'destroy',\r\n            value: function destroy$$1() {\r\n                return destroy.call(this);\r\n            }\r\n        }, {\r\n            key: 'enableEventListeners',\r\n            value: function enableEventListeners$$1() {\r\n                return enableEventListeners.call(this);\r\n            }\r\n        }, {\r\n            key: 'disableEventListeners',\r\n            value: function disableEventListeners$$1() {\r\n                return disableEventListeners.call(this);\r\n            }\r\n\r\n            /**\r\n             * Schedule an update, it will run on the next UI update available\r\n             * @method scheduleUpdate\r\n             * @memberof Popper\r\n             */\r\n\r\n\r\n            /**\r\n             * Collection of utilities useful when writing custom modifiers.\r\n             * Starting from version 1.7, this method is available only if you\r\n             * include `popper-utils.js` before `popper.js`.\r\n             *\r\n             * **DEPRECATION**: This way to access PopperUtils is deprecated\r\n             * and will be removed in v2! Use the PopperUtils module directly instead.\r\n             * Due to the high instability of the methods contained in Utils, we can't\r\n             * guarantee them to follow semver. Use them at your own risk!\r\n             * @static\r\n             * @private\r\n             * @type {Object}\r\n             * @deprecated since version 1.8\r\n             * @member Utils\r\n             * @memberof Popper\r\n             */\r\n\r\n        }]);\r\n        return Popper;\r\n    }();\r\n\r\n    /**\r\n     * The `referenceObject` is an object that provides an interface compatible with Popper.js\r\n     * and lets you use it as replacement of a real DOM node.<br />\r\n     * You can use this method to position a popper relatively to a set of coordinates\r\n     * in case you don't have a DOM node to use as reference.\r\n     *\r\n     * ```\r\n     * new Popper(referenceObject, popperNode);\r\n     * ```\r\n     *\r\n     * NB: This feature isn't supported in Internet Explorer 10\r\n     * @name referenceObject\r\n     * @property {Function} data.getBoundingClientRect\r\n     * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\r\n     * @property {number} data.clientWidth\r\n     * An ES6 getter that will return the width of the virtual reference element.\r\n     * @property {number} data.clientHeight\r\n     * An ES6 getter that will return the height of the virtual reference element.\r\n     */\r\n\r\n\r\n    Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;\r\n    Popper.placements = placements;\r\n    Popper.Defaults = Defaults;\r\n\r\n    return Popper;\r\n\r\n})));\r\n\r\n","js/jquery.fancybox/jquery.fancybox-media.js":"/*!\r\n * Media helper for fancyBox\r\n * version: 1.0.6 (Fri, 14 Jun 2013)\r\n * @requires fancyBox v2.0 or later\r\n *\r\n * Usage:\r\n *     $(\".fancybox\").fancybox({\r\n *         helpers : {\r\n *             media: true\r\n *         }\r\n *     });\r\n *\r\n * Set custom URL parameters:\r\n *     $(\".fancybox\").fancybox({\r\n *         helpers : {\r\n *             media: {\r\n *                 youtube : {\r\n *                     params : {\r\n *                         autoplay : 0\r\n *                     }\r\n *                 }\r\n *             }\r\n *         }\r\n *     });\r\n *\r\n * Or:\r\n *     $(\".fancybox\").fancybox({,\r\n *         helpers : {\r\n *             media: true\r\n *         },\r\n *         youtube : {\r\n *             autoplay: 0\r\n *         }\r\n *     });\r\n *\r\n *  Supports:\r\n *\r\n *      Youtube\r\n *          http://www.youtube.com/watch?v=opj24KnzrWo\r\n *          http://www.youtube.com/embed/opj24KnzrWo\r\n *          http://youtu.be/opj24KnzrWo\r\n *\t\t\thttp://www.youtube-nocookie.com/embed/opj24KnzrWo\r\n *      Vimeo\r\n *          http://vimeo.com/40648169\r\n *          http://vimeo.com/channels/staffpicks/38843628\r\n *          http://vimeo.com/groups/surrealism/videos/36516384\r\n *          http://player.vimeo.com/video/45074303\r\n *      Metacafe\r\n *          http://www.metacafe.com/watch/7635964/dr_seuss_the_lorax_movie_trailer/\r\n *          http://www.metacafe.com/watch/7635964/\r\n *      Dailymotion\r\n *          http://www.dailymotion.com/video/xoytqh_dr-seuss-the-lorax-premiere_people\r\n *      Twitvid\r\n *          http://twitvid.com/QY7MD\r\n *      Twitpic\r\n *          http://twitpic.com/7p93st\r\n *      Instagram\r\n *          http://instagr.am/p/IejkuUGxQn/\r\n *          http://instagram.com/p/IejkuUGxQn/\r\n *      Google maps\r\n *          http://maps.google.com/maps?q=Eiffel+Tower,+Avenue+Gustave+Eiffel,+Paris,+France&t=h&z=17\r\n *          http://maps.google.com/?ll=48.857995,2.294297&spn=0.007666,0.021136&t=m&z=16\r\n *          http://maps.google.com/?ll=48.859463,2.292626&spn=0.000965,0.002642&t=m&z=19&layer=c&cbll=48.859524,2.292532&panoid=YJ0lq28OOy3VT2IqIuVY0g&cbp=12,151.58,,0,-15.56\r\n */\r\ndefine(['jquery', 'fancybox'], function ($) {\r\n    ;(function ($) {\r\n        \"use strict\";\r\n\r\n        //Shortcut for fancyBox object\r\n        var F = $.fancybox,\r\n            format = function (url, rez, params) {\r\n                params = params || '';\r\n\r\n                if ($.type(params) === \"object\") {\r\n                    params = $.param(params, true);\r\n                }\r\n\r\n                $.each(rez, function (key, value) {\r\n                    url = url.replace('$' + key, value || '');\r\n                });\r\n\r\n                if (params.length) {\r\n                    url += (url.indexOf('?') > 0 ? '&' : '?') + params;\r\n                }\r\n\r\n                return url;\r\n            };\r\n\r\n        //Add helper object\r\n        F.helpers.media = {\r\n            defaults: {\r\n                youtube: {\r\n                    matcher: /(youtube\\.com|youtu\\.be|youtube-nocookie\\.com)\\/(watch\\?v=|v\\/|u\\/|embed\\/?)?(videoseries\\?list=(.*)|[\\w-]{11}|\\?listType=(.*)&list=(.*)).*/i,\r\n                    params: {\r\n                        autoplay: 1,\r\n                        autohide: 1,\r\n                        fs: 1,\r\n                        rel: 0,\r\n                        hd: 1,\r\n                        wmode: 'opaque',\r\n                        enablejsapi: 1,\r\n                        ps: 'docs',\r\n                        controls: 1\r\n                    },\r\n                    type: 'iframe',\r\n                    url: '//www.youtube.com/embed/$3'\r\n                },\r\n                vimeo: {\r\n                    matcher: /(?:vimeo(?:pro)?.com)\\/(?:[^\\d]+)?(\\d+)(?:.*)/,\r\n                    params: {\r\n                        autoplay: 1,\r\n                        hd: 1,\r\n                        show_title: 1,\r\n                        show_byline: 1,\r\n                        show_portrait: 0,\r\n                        fullscreen: 1\r\n                    },\r\n                    type: 'iframe',\r\n                    url: '//player.vimeo.com/video/$1'\r\n                },\r\n                metacafe: {\r\n                    matcher: /metacafe.com\\/(?:watch|fplayer)\\/([\\w\\-]{1,10})/,\r\n                    params: {\r\n                        autoPlay: 'yes'\r\n                    },\r\n                    type: 'swf',\r\n                    url: function (rez, params, obj) {\r\n                        obj.swf.flashVars = 'playerVars=' + $.param(params, true);\r\n\r\n                        return '//www.metacafe.com/fplayer/' + rez[1] + '/.swf';\r\n                    }\r\n                },\r\n                dailymotion: {\r\n                    matcher: /dailymotion.com\\/video\\/(.*)\\/?(.*)/,\r\n                    params: {\r\n                        additionalInfos: 0,\r\n                        autoStart: 1\r\n                    },\r\n                    type: 'swf',\r\n                    url: '//www.dailymotion.com/swf/video/$1'\r\n                },\r\n                twitvid: {\r\n                    matcher: /twitvid\\.com\\/([a-zA-Z0-9_\\-\\?\\=]+)/i,\r\n                    params: {\r\n                        autoplay: 0\r\n                    },\r\n                    type: 'iframe',\r\n                    url: '//www.twitvid.com/embed.php?guid=$1'\r\n                },\r\n                twitpic: {\r\n                    matcher: /twitpic\\.com\\/(?!(?:place|photos|events)\\/)([a-zA-Z0-9\\?\\=\\-]+)/i,\r\n                    type: 'image',\r\n                    url: '//twitpic.com/show/full/$1/'\r\n                },\r\n                instagram: {\r\n                    matcher: /(instagr\\.am|instagram\\.com)\\/p\\/([a-zA-Z0-9_\\-]+)\\/?/i,\r\n                    type: 'image',\r\n                    url: '//$1/p/$2/media/?size=l'\r\n                },\r\n                google_maps: {\r\n                    matcher: /maps\\.google\\.([a-z]{2,3}(\\.[a-z]{2})?)\\/(\\?ll=|maps\\?)(.*)/i,\r\n                    type: 'iframe',\r\n                    url: function (rez) {\r\n                        return '//maps.google.' + rez[1] + '/' + rez[3] + '' + rez[4] + '&output=' + (rez[4].indexOf('layer=c') > 0 ? 'svembed' : 'embed');\r\n                    }\r\n                }\r\n            },\r\n\r\n            beforeLoad: function (opts, obj) {\r\n                var url = obj.href || '',\r\n                    type = false,\r\n                    what,\r\n                    item,\r\n                    rez,\r\n                    params;\r\n\r\n                for (what in opts) {\r\n                    if (opts.hasOwnProperty(what)) {\r\n                        item = opts[what];\r\n                        rez = url.match(item.matcher);\r\n\r\n                        if (rez) {\r\n                            type = item.type;\r\n                            params = $.extend(true, {}, item.params, obj[what] || ($.isPlainObject(opts[what]) ? opts[what].params : null));\r\n\r\n                            url = $.type(item.url) === \"function\" ? item.url.call(this, rez, params, obj) : format(item.url, rez, params);\r\n\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (type) {\r\n                    obj.href = url;\r\n                    obj.type = type;\r\n\r\n                    obj.autoHeight = false;\r\n                }\r\n            }\r\n        };\r\n\r\n    }(jQuery));\r\n});","js/jquery.fancybox/jquery.fancybox.pack.js":"/*! fancyBox v2.1.7 fancyapps.com | fancyapps.com/fancybox/#license */\r\ndefine(['jquery'], function ($) {\r\n    (function (t, J, f, x) {\r\n        var L = f(\"html\"), q = f(t), p = f(J), b = f.fancybox = function () {\r\n            b.open.apply(this, arguments)\r\n        }, K = navigator.userAgent.match(/msie/i), D = null, u = J.createTouch !== x, v = function (a) {\r\n            return a && a.hasOwnProperty && a instanceof f\r\n        }, r = function (a) {\r\n            return a && \"string\" === f.type(a)\r\n        }, G = function (a) {\r\n            return r(a) && 0 < a.indexOf(\"%\")\r\n        }, m = function (a, c) {\r\n            var d = parseInt(a, 10) || 0;\r\n            c && G(a) && (d *= b.getViewport()[c] / 100);\r\n            return Math.ceil(d)\r\n        }, y = function (a, b) {\r\n            return m(a, b) + \"px\"\r\n        };\r\n        f.extend(b, {\r\n            version: \"2.1.7\",\r\n            defaults: {\r\n                padding: 15,\r\n                margin: 20,\r\n                width: 800,\r\n                height: 600,\r\n                minWidth: 100,\r\n                minHeight: 100,\r\n                maxWidth: 9999,\r\n                maxHeight: 9999,\r\n                pixelRatio: 1,\r\n                autoSize: !0,\r\n                autoHeight: !1,\r\n                autoWidth: !1,\r\n                autoResize: !0,\r\n                autoCenter: !u,\r\n                fitToView: !0,\r\n                aspectRatio: !1,\r\n                topRatio: .5,\r\n                leftRatio: .5,\r\n                scrolling: \"auto\",\r\n                wrapCSS: \"\",\r\n                arrows: !0,\r\n                closeBtn: !0,\r\n                closeClick: !1,\r\n                nextClick: !1,\r\n                mouseWheel: !0,\r\n                autoPlay: !1,\r\n                playSpeed: 3E3,\r\n                preload: 3,\r\n                modal: !1,\r\n                loop: !0,\r\n                ajax: {dataType: \"html\", headers: {\"X-fancyBox\": !0}},\r\n                iframe: {scrolling: \"auto\", preload: !0},\r\n                swf: {wmode: \"transparent\", allowfullscreen: \"true\", allowscriptaccess: \"always\"},\r\n                keys: {\r\n                    next: {13: \"left\", 34: \"up\", 39: \"left\", 40: \"up\"},\r\n                    prev: {8: \"right\", 33: \"down\", 37: \"right\", 38: \"down\"},\r\n                    close: [27],\r\n                    play: [32],\r\n                    toggle: [70]\r\n                },\r\n                direction: {next: \"left\", prev: \"right\"},\r\n                scrollOutside: !0,\r\n                index: 0,\r\n                type: null,\r\n                href: null,\r\n                content: null,\r\n                title: null,\r\n                tpl: {\r\n                    wrap: '<div class=\"fancybox-wrap\" tabIndex=\"-1\"><div class=\"fancybox-skin\"><div class=\"fancybox-outer\"><div class=\"fancybox-inner\"></div></div></div></div>',\r\n                    image: '<img class=\"fancybox-image\" src=\"{href}\" alt=\"\" />',\r\n                    iframe: '<iframe id=\"fancybox-frame{rnd}\" name=\"fancybox-frame{rnd}\" class=\"fancybox-iframe\" frameborder=\"0\" vspace=\"0\" hspace=\"0\" webkitAllowFullScreen mozallowfullscreen allowFullScreen' +\r\n                        (K ? ' allowtransparency=\"true\"' : \"\") + \"></iframe>\",\r\n                    error: '<p class=\"fancybox-error\">The requested content cannot be loaded.<br/>Please try again later.</p>',\r\n                    closeBtn: '<a title=\"Close\" class=\"fancybox-item fancybox-close\" href=\"javascript:;\"></a>',\r\n                    next: '<a title=\"Next\" class=\"fancybox-nav fancybox-next\" href=\"javascript:;\"><span></span></a>',\r\n                    prev: '<a title=\"Previous\" class=\"fancybox-nav fancybox-prev\" href=\"javascript:;\"><span></span></a>',\r\n                    loading: '<div id=\"fancybox-loading\"><div></div></div>'\r\n                },\r\n                openEffect: \"fade\",\r\n                openSpeed: 250,\r\n                openEasing: \"swing\",\r\n                openOpacity: !0,\r\n                openMethod: \"zoomIn\",\r\n                closeEffect: \"fade\",\r\n                closeSpeed: 250,\r\n                closeEasing: \"swing\",\r\n                closeOpacity: !0,\r\n                closeMethod: \"zoomOut\",\r\n                nextEffect: \"elastic\",\r\n                nextSpeed: 250,\r\n                nextEasing: \"swing\",\r\n                nextMethod: \"changeIn\",\r\n                prevEffect: \"elastic\",\r\n                prevSpeed: 250,\r\n                prevEasing: \"swing\",\r\n                prevMethod: \"changeOut\",\r\n                helpers: {overlay: !0, title: !0},\r\n                onCancel: f.noop,\r\n                beforeLoad: f.noop,\r\n                afterLoad: f.noop,\r\n                beforeShow: f.noop,\r\n                afterShow: f.noop,\r\n                beforeChange: f.noop,\r\n                beforeClose: f.noop,\r\n                afterClose: f.noop\r\n            },\r\n            group: {},\r\n            opts: {},\r\n            previous: null,\r\n            coming: null,\r\n            current: null,\r\n            isActive: !1,\r\n            isOpen: !1,\r\n            isOpened: !1,\r\n            wrap: null,\r\n            skin: null,\r\n            outer: null,\r\n            inner: null,\r\n            player: {timer: null, isActive: !1},\r\n            ajaxLoad: null,\r\n            imgPreload: null,\r\n            transitions: {},\r\n            helpers: {},\r\n            open: function (a, c) {\r\n                if (a && (f.isPlainObject(c) || (c = {}), !1 !== b.close(!0))) return f.isArray(a) || (a = v(a) ? f(a).get() : [a]), f.each(a, function (d, e) {\r\n                    var k = {}, g, l, h, n, m;\r\n                    \"object\" === f.type(e) && (e.nodeType && (e = f(e)), v(e) ? (k = {\r\n                        href: e.data(\"fancybox-href\") || e.attr(\"href\"),\r\n                        title: f(\"<div/>\").text(e.data(\"fancybox-title\") ||\r\n                            e.attr(\"title\") || \"\").html(),\r\n                        isDom: !0,\r\n                        element: e\r\n                    }, f.metadata && f.extend(!0, k, e.metadata())) : k = e);\r\n                    g = c.href || k.href || (r(e) ? e : null);\r\n                    l = c.title !== x ? c.title : k.title || \"\";\r\n                    n = (h = c.content || k.content) ? \"html\" : c.type || k.type;\r\n                    !n && k.isDom && (n = e.data(\"fancybox-type\"), n || (n = (n = e.prop(\"class\").match(/fancybox\\.(\\w+)/)) ? n[1] : null));\r\n                    r(g) && (n || (b.isImage(g) ? n = \"image\" : b.isSWF(g) ? n = \"swf\" : \"#\" === g.charAt(0) ? n = \"inline\" : r(e) && (n = \"html\", h = e)), \"ajax\" === n && (m = g.split(/\\s+/, 2), g = m.shift(), m = m.shift()));\r\n                    h || (\"inline\" === n ? g ? h = f(r(g) ?\r\n                        g.replace(/.*(?=#[^\\s]+$)/, \"\") : g) : k.isDom && (h = e) : \"html\" === n ? h = g : n || g || !k.isDom || (n = \"inline\", h = e));\r\n                    f.extend(k, {href: g, type: n, content: h, title: l, selector: m});\r\n                    a[d] = k\r\n                }), b.opts = f.extend(!0, {}, b.defaults, c), c.keys !== x && (b.opts.keys = c.keys ? f.extend({}, b.defaults.keys, c.keys) : !1), b.group = a, b._start(b.opts.index)\r\n            },\r\n            cancel: function () {\r\n                var a = b.coming;\r\n                a && !1 === b.trigger(\"onCancel\") || (b.hideLoading(), a && (b.ajaxLoad && b.ajaxLoad.abort(), b.ajaxLoad = null, b.imgPreload && (b.imgPreload.onload = b.imgPreload.onerror = null), a.wrap &&\r\n                a.wrap.stop(!0, !0).trigger(\"onReset\").remove(), b.coming = null, b.current || b._afterZoomOut(a)))\r\n            },\r\n            close: function (a) {\r\n                b.cancel();\r\n                !1 !== b.trigger(\"beforeClose\") && (b.unbindEvents(), b.isActive && (b.isOpen && !0 !== a ? (b.isOpen = b.isOpened = !1, b.isClosing = !0, f(\".fancybox-item, .fancybox-nav\").remove(), b.wrap.stop(!0, !0).removeClass(\"fancybox-opened\"), b.transitions[b.current.closeMethod]()) : (f(\".fancybox-wrap\").stop(!0).trigger(\"onReset\").remove(), b._afterZoomOut())))\r\n            },\r\n            play: function (a) {\r\n                var c = function () {\r\n                        clearTimeout(b.player.timer)\r\n                    },\r\n                    d = function () {\r\n                        c();\r\n                        b.current && b.player.isActive && (b.player.timer = setTimeout(b.next, b.current.playSpeed))\r\n                    }, e = function () {\r\n                        c();\r\n                        p.unbind(\".player\");\r\n                        b.player.isActive = !1;\r\n                        b.trigger(\"onPlayEnd\")\r\n                    };\r\n                !0 === a || !b.player.isActive && !1 !== a ? b.current && (b.current.loop || b.current.index < b.group.length - 1) && (b.player.isActive = !0, p.bind({\r\n                    \"onCancel.player beforeClose.player\": e,\r\n                    \"onUpdate.player\": d,\r\n                    \"beforeLoad.player\": c\r\n                }), d(), b.trigger(\"onPlayStart\")) : e()\r\n            },\r\n            next: function (a) {\r\n                var c = b.current;\r\n                c && (r(a) || (a = c.direction.next), b.jumpto(c.index +\r\n                    1, a, \"next\"))\r\n            },\r\n            prev: function (a) {\r\n                var c = b.current;\r\n                c && (r(a) || (a = c.direction.prev), b.jumpto(c.index - 1, a, \"prev\"))\r\n            },\r\n            jumpto: function (a, c, d) {\r\n                var e = b.current;\r\n                e && (a = m(a), b.direction = c || e.direction[a >= e.index ? \"next\" : \"prev\"], b.router = d || \"jumpto\", e.loop && (0 > a && (a = e.group.length + a % e.group.length), a %= e.group.length), e.group[a] !== x && (b.cancel(), b._start(a)))\r\n            },\r\n            reposition: function (a, c) {\r\n                var d = b.current, e = d ? d.wrap : null, k;\r\n                e && (k = b._getPosition(c), a && \"scroll\" === a.type ? (delete k.position, e.stop(!0, !0).animate(k, 200)) : (e.css(k),\r\n                    d.pos = f.extend({}, d.dim, k)))\r\n            },\r\n            update: function (a) {\r\n                var c = a && a.originalEvent && a.originalEvent.type, d = !c || \"orientationchange\" === c;\r\n                d && (clearTimeout(D), D = null);\r\n                b.isOpen && !D && (D = setTimeout(function () {\r\n                    var e = b.current;\r\n                    e && !b.isClosing && (b.wrap.removeClass(\"fancybox-tmp\"), (d || \"load\" === c || \"resize\" === c && e.autoResize) && b._setDimension(), \"scroll\" === c && e.canShrink || b.reposition(a), b.trigger(\"onUpdate\"), D = null)\r\n                }, d && !u ? 0 : 300))\r\n            },\r\n            toggle: function (a) {\r\n                b.isOpen && (b.current.fitToView = \"boolean\" === f.type(a) ? a : !b.current.fitToView,\r\n                u && (b.wrap.removeAttr(\"style\").addClass(\"fancybox-tmp\"), b.trigger(\"onUpdate\")), b.update())\r\n            },\r\n            hideLoading: function () {\r\n                p.unbind(\".loading\");\r\n                f(\"#fancybox-loading\").remove()\r\n            },\r\n            showLoading: function () {\r\n                var a, c;\r\n                b.hideLoading();\r\n                a = f(b.opts.tpl.loading).click(b.cancel).appendTo(\"body\");\r\n                p.bind(\"keydown.loading\", function (a) {\r\n                    27 === (a.which || a.keyCode) && (a.preventDefault(), b.cancel())\r\n                });\r\n                b.defaults.fixed || (c = b.getViewport(), a.css({\r\n                    position: \"absolute\",\r\n                    top: .5 * c.h + c.y,\r\n                    left: .5 * c.w + c.x\r\n                }));\r\n                b.trigger(\"onLoading\")\r\n            },\r\n            getViewport: function () {\r\n                var a =\r\n                    b.current && b.current.locked || !1, c = {x: q.scrollLeft(), y: q.scrollTop()};\r\n                a && a.length ? (c.w = a[0].clientWidth, c.h = a[0].clientHeight) : (c.w = u && t.innerWidth ? t.innerWidth : q.width(), c.h = u && t.innerHeight ? t.innerHeight : q.height());\r\n                return c\r\n            },\r\n            unbindEvents: function () {\r\n                b.wrap && v(b.wrap) && b.wrap.unbind(\".fb\");\r\n                p.unbind(\".fb\");\r\n                q.unbind(\".fb\")\r\n            },\r\n            bindEvents: function () {\r\n                var a = b.current, c;\r\n                a && (q.bind(\"orientationchange.fb\" + (u ? \"\" : \" resize.fb\") + (a.autoCenter && !a.locked ? \" scroll.fb\" : \"\"), b.update), (c = a.keys) && p.bind(\"keydown.fb\",\r\n                    function (d) {\r\n                        var e = d.which || d.keyCode, k = d.target || d.srcElement;\r\n                        if (27 === e && b.coming) return !1;\r\n                        d.ctrlKey || d.altKey || d.shiftKey || d.metaKey || k && (k.type || f(k).is(\"[contenteditable]\")) || f.each(c, function (c, k) {\r\n                            if (1 < a.group.length && k[e] !== x) return b[c](k[e]), d.preventDefault(), !1;\r\n                            if (-1 < f.inArray(e, k)) return b[c](), d.preventDefault(), !1\r\n                        })\r\n                    }), f.fn.mousewheel && a.mouseWheel && b.wrap.bind(\"mousewheel.fb\", function (c, e, k, g) {\r\n                    for (var d = f(c.target || null), h = !1; d.length && !(h || d.is(\".fancybox-skin\") || d.is(\".fancybox-wrap\"));) h =\r\n                        (h = d[0]) && !(h.style.overflow && \"hidden\" === h.style.overflow) && (h.clientWidth && h.scrollWidth > h.clientWidth || h.clientHeight && h.scrollHeight > h.clientHeight), d = f(d).parent();\r\n                    0 !== e && !h && 1 < b.group.length && !a.canShrink && (0 < g || 0 < k ? b.prev(0 < g ? \"down\" : \"left\") : (0 > g || 0 > k) && b.next(0 > g ? \"up\" : \"right\"), c.preventDefault())\r\n                }))\r\n            },\r\n            trigger: function (a, c) {\r\n                var d, e = c || b.coming || b.current;\r\n                if (e) {\r\n                    f.isFunction(e[a]) && (d = e[a].apply(e, Array.prototype.slice.call(arguments, 1)));\r\n                    if (!1 === d) return !1;\r\n                    e.helpers && f.each(e.helpers, function (c,\r\n                                                             d) {\r\n                        if (d && b.helpers[c] && f.isFunction(b.helpers[c][a])) b.helpers[c][a](f.extend(!0, {}, b.helpers[c].defaults, d), e)\r\n                    })\r\n                }\r\n                p.trigger(a)\r\n            },\r\n            isImage: function (a) {\r\n                return r(a) && a.match(/(^data:image\\/.*,)|(\\.(jp(e|g|eg)|gif|png|bmp|webp|svg)((\\?|#).*)?$)/i)\r\n            },\r\n            isSWF: function (a) {\r\n                return r(a) && a.match(/\\.(swf)((\\?|#).*)?$/i)\r\n            },\r\n            _start: function (a) {\r\n                var c = {}, d, e;\r\n                a = m(a);\r\n                d = b.group[a] || null;\r\n                if (!d) return !1;\r\n                c = f.extend(!0, {}, b.opts, d);\r\n                d = c.margin;\r\n                e = c.padding;\r\n                \"number\" === f.type(d) && (c.margin = [d, d, d, d]);\r\n                \"number\" === f.type(e) && (c.padding =\r\n                    [e, e, e, e]);\r\n                c.modal && f.extend(!0, c, {\r\n                    closeBtn: !1,\r\n                    closeClick: !1,\r\n                    nextClick: !1,\r\n                    arrows: !1,\r\n                    mouseWheel: !1,\r\n                    keys: null,\r\n                    helpers: {overlay: {closeClick: !1}}\r\n                });\r\n                c.autoSize && (c.autoWidth = c.autoHeight = !0);\r\n                \"auto\" === c.width && (c.autoWidth = !0);\r\n                \"auto\" === c.height && (c.autoHeight = !0);\r\n                c.group = b.group;\r\n                c.index = a;\r\n                b.coming = c;\r\n                if (!1 === b.trigger(\"beforeLoad\")) b.coming = null; else {\r\n                    e = c.type;\r\n                    d = c.href;\r\n                    if (!e) return b.coming = null, b.current && b.router && \"jumpto\" !== b.router ? (b.current.index = a, b[b.router](b.direction)) : !1;\r\n                    b.isActive = !0;\r\n                    if (\"image\" ===\r\n                        e || \"swf\" === e) c.autoHeight = c.autoWidth = !1, c.scrolling = \"visible\";\r\n                    \"image\" === e && (c.aspectRatio = !0);\r\n                    \"iframe\" === e && u && (c.scrolling = \"scroll\");\r\n                    c.wrap = f(c.tpl.wrap).addClass(\"fancybox-\" + (u ? \"mobile\" : \"desktop\") + \" fancybox-type-\" + e + \" fancybox-tmp \" + c.wrapCSS).appendTo(c.parent || \"body\");\r\n                    f.extend(c, {\r\n                        skin: f(\".fancybox-skin\", c.wrap),\r\n                        outer: f(\".fancybox-outer\", c.wrap),\r\n                        inner: f(\".fancybox-inner\", c.wrap)\r\n                    });\r\n                    f.each([\"Top\", \"Right\", \"Bottom\", \"Left\"], function (a, b) {\r\n                        c.skin.css(\"padding\" + b, y(c.padding[a]))\r\n                    });\r\n                    b.trigger(\"onReady\");\r\n                    if (\"inline\" === e || \"html\" === e) {\r\n                        if (!c.content || !c.content.length) return b._error(\"content\")\r\n                    } else if (!d) return b._error(\"href\");\r\n                    \"image\" === e ? b._loadImage() : \"ajax\" === e ? b._loadAjax() : \"iframe\" === e ? b._loadIframe() : b._afterLoad()\r\n                }\r\n            },\r\n            _error: function (a) {\r\n                f.extend(b.coming, {\r\n                    type: \"html\",\r\n                    autoWidth: !0,\r\n                    autoHeight: !0,\r\n                    minWidth: 0,\r\n                    minHeight: 0,\r\n                    scrolling: \"no\",\r\n                    hasError: a,\r\n                    content: b.coming.tpl.error\r\n                });\r\n                b._afterLoad()\r\n            },\r\n            _loadImage: function () {\r\n                var a = b.imgPreload = new Image;\r\n                a.onload = function () {\r\n                    this.onload = this.onerror = null;\r\n                    b.coming.width =\r\n                        this.width / b.opts.pixelRatio;\r\n                    b.coming.height = this.height / b.opts.pixelRatio;\r\n                    b._afterLoad()\r\n                };\r\n                a.onerror = function () {\r\n                    this.onload = this.onerror = null;\r\n                    b._error(\"image\")\r\n                };\r\n                a.src = b.coming.href;\r\n                !0 !== a.complete && b.showLoading()\r\n            },\r\n            _loadAjax: function () {\r\n                var a = b.coming;\r\n                b.showLoading();\r\n                b.ajaxLoad = f.ajax(f.extend({}, a.ajax, {\r\n                    url: a.href, error: function (a, d) {\r\n                        b.coming && \"abort\" !== d ? b._error(\"ajax\", a) : b.hideLoading()\r\n                    }, success: function (c, d) {\r\n                        \"success\" === d && (a.content = c, b._afterLoad())\r\n                    }\r\n                }))\r\n            },\r\n            _loadIframe: function () {\r\n                var a = b.coming,\r\n                    c = f(a.tpl.iframe.replace(/\\{rnd\\}/g, (new Date).getTime())).attr(\"scrolling\", u ? \"auto\" : a.iframe.scrolling).attr(\"src\", a.href);\r\n                f(a.wrap).bind(\"onReset\", function () {\r\n                    try {\r\n                        f(this).find(\"iframe\").hide().attr(\"src\", \"//about:blank\").end().empty()\r\n                    } catch (d) {\r\n                    }\r\n                });\r\n                a.iframe.preload && (b.showLoading(), c.one(\"load\", function () {\r\n                    f(this).data(\"ready\", 1);\r\n                    u || f(this).bind(\"load.fb\", b.update);\r\n                    f(this).parents(\".fancybox-wrap\").width(\"100%\").removeClass(\"fancybox-tmp\").show();\r\n                    b._afterLoad()\r\n                }));\r\n                a.content = c.appendTo(a.inner);\r\n                a.iframe.preload ||\r\n                b._afterLoad()\r\n            },\r\n            _preloadImages: function () {\r\n                var a = b.group, c = b.current, d = a.length, e = c.preload ? Math.min(c.preload, d - 1) : 0, f, g;\r\n                for (g = 1; g <= e; g += 1) f = a[(c.index + g) % d], \"image\" === f.type && f.href && ((new Image).src = f.href)\r\n            },\r\n            _afterLoad: function () {\r\n                var a = b.coming, c = b.current, d, e, k, g, l;\r\n                b.hideLoading();\r\n                if (a && !1 !== b.isActive) if (!1 === b.trigger(\"afterLoad\", a, c)) a.wrap.stop(!0).trigger(\"onReset\").remove(), b.coming = null; else {\r\n                    c && (b.trigger(\"beforeChange\", c), c.wrap.stop(!0).removeClass(\"fancybox-opened\").find(\".fancybox-item, .fancybox-nav\").remove());\r\n                    b.unbindEvents();\r\n                    d = a.content;\r\n                    e = a.type;\r\n                    k = a.scrolling;\r\n                    f.extend(b, {wrap: a.wrap, skin: a.skin, outer: a.outer, inner: a.inner, current: a, previous: c});\r\n                    g = a.href;\r\n                    switch (e) {\r\n                        case \"inline\":\r\n                        case \"ajax\":\r\n                        case \"html\":\r\n                            a.selector ? d = f(\"<div>\").html(d).find(a.selector) : v(d) && (d.data(\"fancybox-placeholder\") || d.data(\"fancybox-placeholder\", f('<div class=\"fancybox-placeholder\"></div>').insertAfter(d).hide()), d = d.show().detach(), a.wrap.bind(\"onReset\", function () {\r\n                                f(this).find(d).length && d.hide().replaceAll(d.data(\"fancybox-placeholder\")).data(\"fancybox-placeholder\",\r\n                                    !1)\r\n                            }));\r\n                            break;\r\n                        case \"image\":\r\n                            d = a.tpl.image.replace(/\\{href\\}/g, g);\r\n                            break;\r\n                        case \"swf\":\r\n                            d = '<object id=\"fancybox-swf\" classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\" width=\"100%\" height=\"100%\"><param name=\"movie\" value=\"' + g + '\"></param>', l = \"\", f.each(a.swf, function (a, b) {\r\n                                d += '<param name=\"' + a + '\" value=\"' + b + '\"></param>';\r\n                                l += \" \" + a + '=\"' + b + '\"'\r\n                            }), d += '<embed src=\"' + g + '\" type=\"application/x-shockwave-flash\" width=\"100%\" height=\"100%\"' + l + \"></embed></object>\"\r\n                    }\r\n                    v(d) && d.parent().is(a.inner) || a.inner.append(d);\r\n                    b.trigger(\"beforeShow\");\r\n                    a.inner.css(\"overflow\", \"yes\" === k ? \"scroll\" : \"no\" === k ? \"hidden\" : k);\r\n                    b._setDimension();\r\n                    b.reposition();\r\n                    b.isOpen = !1;\r\n                    b.coming = null;\r\n                    b.bindEvents();\r\n                    if (!b.isOpened) f(\".fancybox-wrap\").not(a.wrap).stop(!0).trigger(\"onReset\").remove(); else if (c.prevMethod) b.transitions[c.prevMethod]();\r\n                    b.transitions[b.isOpened ? a.nextMethod : a.openMethod]();\r\n                    b._preloadImages()\r\n                }\r\n            },\r\n            _setDimension: function () {\r\n                var a = b.getViewport(), c = 0, d, e = b.wrap, k = b.skin, g = b.inner, l = b.current;\r\n                d = l.width;\r\n                var h = l.height, n = l.minWidth, w = l.minHeight, p = l.maxWidth,\r\n                    q = l.maxHeight, u = l.scrolling, r = l.scrollOutside ? l.scrollbarWidth : 0, z = l.margin,\r\n                    A = m(z[1] + z[3]), t = m(z[0] + z[2]), x, B, v, E, C, H, D, F, I;\r\n                e.add(k).add(g).width(\"auto\").height(\"auto\").removeClass(\"fancybox-tmp\");\r\n                z = m(k.outerWidth(!0) - k.width());\r\n                x = m(k.outerHeight(!0) - k.height());\r\n                B = A + z;\r\n                v = t + x;\r\n                E = G(d) ? (a.w - B) * m(d) / 100 : d;\r\n                C = G(h) ? (a.h - v) * m(h) / 100 : h;\r\n                if (\"iframe\" === l.type) {\r\n                    if (I = l.content, l.autoHeight && I && 1 === I.data(\"ready\")) try {\r\n                        I[0].contentWindow.document.location && (g.width(E).height(9999), H = I.contents().find(\"body\"), r && H.css(\"overflow-x\",\r\n                            \"hidden\"), C = H.outerHeight(!0))\r\n                    } catch (M) {\r\n                    }\r\n                } else if (l.autoWidth || l.autoHeight) g.addClass(\"fancybox-tmp\"), l.autoWidth || g.width(E), l.autoHeight || g.height(C), l.autoWidth && (E = g.width()), l.autoHeight && (C = g.height()), g.removeClass(\"fancybox-tmp\");\r\n                d = m(E);\r\n                h = m(C);\r\n                F = E / C;\r\n                n = m(G(n) ? m(n, \"w\") - B : n);\r\n                p = m(G(p) ? m(p, \"w\") - B : p);\r\n                w = m(G(w) ? m(w, \"h\") - v : w);\r\n                q = m(G(q) ? m(q, \"h\") - v : q);\r\n                H = p;\r\n                D = q;\r\n                l.fitToView && (p = Math.min(a.w - B, p), q = Math.min(a.h - v, q));\r\n                B = a.w - A;\r\n                t = a.h - t;\r\n                l.aspectRatio ? (d > p && (d = p, h = m(d / F)), h > q && (h = q, d = m(h * F)), d < n && (d = n, h = m(d /\r\n                    F)), h < w && (h = w, d = m(h * F))) : (d = Math.max(n, Math.min(d, p)), l.autoHeight && \"iframe\" !== l.type && (g.width(d), h = g.height()), h = Math.max(w, Math.min(h, q)));\r\n                if (l.fitToView) if (g.width(d).height(h), e.width(d + z), a = e.width(), A = e.height(), l.aspectRatio) for (; (a > B || A > t) && d > n && h > w && !(19 < c++);) h = Math.max(w, Math.min(q, h - 10)), d = m(h * F), d < n && (d = n, h = m(d / F)), d > p && (d = p, h = m(d / F)), g.width(d).height(h), e.width(d + z), a = e.width(), A = e.height(); else d = Math.max(n, Math.min(d, d - (a - B))), h = Math.max(w, Math.min(h, h - (A - t)));\r\n                r && \"auto\" === u && h < C &&\r\n                d + z + r < B && (d += r);\r\n                g.width(d).height(h);\r\n                e.width(d + z);\r\n                a = e.width();\r\n                A = e.height();\r\n                c = (a > B || A > t) && d > n && h > w;\r\n                d = l.aspectRatio ? d < H && h < D && d < E && h < C : (d < H || h < D) && (d < E || h < C);\r\n                f.extend(l, {\r\n                    dim: {width: y(a), height: y(A)},\r\n                    origWidth: E,\r\n                    origHeight: C,\r\n                    canShrink: c,\r\n                    canExpand: d,\r\n                    wPadding: z,\r\n                    hPadding: x,\r\n                    wrapSpace: A - k.outerHeight(!0),\r\n                    skinSpace: k.height() - h\r\n                });\r\n                !I && l.autoHeight && h > w && h < q && !d && g.height(\"auto\")\r\n            },\r\n            _getPosition: function (a) {\r\n                var c = b.current, d = b.getViewport(), e = c.margin, f = b.wrap.width() + e[1] + e[3],\r\n                    g = b.wrap.height() + e[0] + e[2], e = {\r\n                        position: \"absolute\",\r\n                        top: e[0], left: e[3]\r\n                    };\r\n                c.autoCenter && c.fixed && !a && g <= d.h && f <= d.w ? e.position = \"fixed\" : c.locked || (e.top += d.y, e.left += d.x);\r\n                e.top = y(Math.max(e.top, e.top + (d.h - g) * c.topRatio));\r\n                e.left = y(Math.max(e.left, e.left + (d.w - f) * c.leftRatio));\r\n                return e\r\n            },\r\n            _afterZoomIn: function () {\r\n                var a = b.current;\r\n                a && ((b.isOpen = b.isOpened = !0, b.wrap.css(\"overflow\", \"visible\").addClass(\"fancybox-opened\").hide().show(0), b.update(), (a.closeClick || a.nextClick && 1 < b.group.length) && b.inner.css(\"cursor\", \"pointer\").bind(\"click.fb\", function (c) {\r\n                    f(c.target).is(\"a\") ||\r\n                    f(c.target).parent().is(\"a\") || (c.preventDefault(), b[a.closeClick ? \"close\" : \"next\"]())\r\n                }), a.closeBtn && f(a.tpl.closeBtn).appendTo(b.skin).bind(\"click.fb\", function (a) {\r\n                    a.preventDefault();\r\n                    b.close()\r\n                }), a.arrows && 1 < b.group.length && ((a.loop || 0 < a.index) && f(a.tpl.prev).appendTo(b.outer).bind(\"click.fb\", b.prev), (a.loop || a.index < b.group.length - 1) && f(a.tpl.next).appendTo(b.outer).bind(\"click.fb\", b.next)), b.trigger(\"afterShow\"), a.loop || a.index !== a.group.length - 1) ? b.opts.autoPlay && !b.player.isActive && (b.opts.autoPlay = !1, b.play(!0)) : b.play(!1))\r\n            },\r\n            _afterZoomOut: function (a) {\r\n                a = a || b.current;\r\n                f(\".fancybox-wrap\").trigger(\"onReset\").remove();\r\n                f.extend(b, {\r\n                    group: {},\r\n                    opts: {},\r\n                    router: !1,\r\n                    current: null,\r\n                    isActive: !1,\r\n                    isOpened: !1,\r\n                    isOpen: !1,\r\n                    isClosing: !1,\r\n                    wrap: null,\r\n                    skin: null,\r\n                    outer: null,\r\n                    inner: null\r\n                });\r\n                b.trigger(\"afterClose\", a)\r\n            }\r\n        });\r\n        b.transitions = {\r\n            getOrigPosition: function () {\r\n                var a = b.current, c = a.element, d = a.orig, e = {}, f = 50, g = 50, l = a.hPadding, h = a.wPadding,\r\n                    n = b.getViewport();\r\n                !d && a.isDom && c.is(\":visible\") && (d = c.find(\"img:first\"), d.length || (d = c));\r\n                v(d) ?\r\n                    (e = d.offset(), d.is(\"img\") && (f = d.outerWidth(), g = d.outerHeight())) : (e.top = n.y + (n.h - g) * a.topRatio, e.left = n.x + (n.w - f) * a.leftRatio);\r\n                if (\"fixed\" === b.wrap.css(\"position\") || a.locked) e.top -= n.y, e.left -= n.x;\r\n                return e = {\r\n                    top: y(e.top - l * a.topRatio),\r\n                    left: y(e.left - h * a.leftRatio),\r\n                    width: y(f + h),\r\n                    height: y(g + l)\r\n                }\r\n            }, step: function (a, c) {\r\n                var d, e, f = c.prop;\r\n                e = b.current;\r\n                var g = e.wrapSpace, l = e.skinSpace;\r\n                if (\"width\" === f || \"height\" === f) d = c.end === c.start ? 1 : (a - c.start) / (c.end - c.start), b.isClosing && (d = 1 - d), e = \"width\" === f ? e.wPadding : e.hPadding,\r\n                    e = a - e, b.skin[f](m(\"width\" === f ? e : e - g * d)), b.inner[f](m(\"width\" === f ? e : e - g * d - l * d))\r\n            }, zoomIn: function () {\r\n                var a = b.current, c = a.pos, d = a.openEffect, e = \"elastic\" === d, k = f.extend({opacity: 1}, c);\r\n                delete k.position;\r\n                e ? (c = this.getOrigPosition(), a.openOpacity && (c.opacity = .1)) : \"fade\" === d && (c.opacity = .1);\r\n                b.wrap.css(c).animate(k, {\r\n                    duration: \"none\" === d ? 0 : a.openSpeed,\r\n                    easing: a.openEasing,\r\n                    step: e ? this.step : null,\r\n                    complete: b._afterZoomIn\r\n                })\r\n            }, zoomOut: function () {\r\n                var a = b.current, c = a.closeEffect, d = \"elastic\" === c, e = {opacity: .1};\r\n                d && (e = this.getOrigPosition(),\r\n                a.closeOpacity && (e.opacity = .1));\r\n                b.wrap.animate(e, {\r\n                    duration: \"none\" === c ? 0 : a.closeSpeed,\r\n                    easing: a.closeEasing,\r\n                    step: d ? this.step : null,\r\n                    complete: b._afterZoomOut\r\n                })\r\n            }, changeIn: function () {\r\n                var a = b.current, c = a.nextEffect, d = a.pos, e = {opacity: 1}, f = b.direction, g;\r\n                d.opacity = .1;\r\n                \"elastic\" === c && (g = \"down\" === f || \"up\" === f ? \"top\" : \"left\", \"down\" === f || \"right\" === f ? (d[g] = y(m(d[g]) - 200), e[g] = \"+=200px\") : (d[g] = y(m(d[g]) + 200), e[g] = \"-=200px\"));\r\n                \"none\" === c ? b._afterZoomIn() : b.wrap.css(d).animate(e, {\r\n                    duration: a.nextSpeed, easing: a.nextEasing,\r\n                    complete: b._afterZoomIn\r\n                })\r\n            }, changeOut: function () {\r\n                var a = b.previous, c = a.prevEffect, d = {opacity: .1}, e = b.direction;\r\n                \"elastic\" === c && (d[\"down\" === e || \"up\" === e ? \"top\" : \"left\"] = (\"up\" === e || \"left\" === e ? \"-\" : \"+\") + \"=200px\");\r\n                a.wrap.animate(d, {\r\n                    duration: \"none\" === c ? 0 : a.prevSpeed,\r\n                    easing: a.prevEasing,\r\n                    complete: function () {\r\n                        f(this).trigger(\"onReset\").remove()\r\n                    }\r\n                })\r\n            }\r\n        };\r\n        b.helpers.overlay = {\r\n            defaults: {closeClick: !0, speedOut: 200, showEarly: !0, css: {}, locked: !u, fixed: !0},\r\n            overlay: null,\r\n            fixed: !1,\r\n            el: f(\"html\"),\r\n            create: function (a) {\r\n                var c;\r\n                a = f.extend({},\r\n                    this.defaults, a);\r\n                this.overlay && this.close();\r\n                c = b.coming ? b.coming.parent : a.parent;\r\n                this.overlay = f('<div class=\"fancybox-overlay\"></div>').appendTo(c && c.length ? c : \"body\");\r\n                this.fixed = !1;\r\n                a.fixed && b.defaults.fixed && (this.overlay.addClass(\"fancybox-overlay-fixed\"), this.fixed = !0)\r\n            },\r\n            open: function (a) {\r\n                var c = this;\r\n                a = f.extend({}, this.defaults, a);\r\n                this.overlay ? this.overlay.unbind(\".overlay\").width(\"auto\").height(\"auto\") : this.create(a);\r\n                this.fixed || (q.bind(\"resize.overlay\", f.proxy(this.update, this)), this.update());\r\n                a.closeClick &&\r\n                this.overlay.bind(\"click.overlay\", function (a) {\r\n                    if (f(a.target).hasClass(\"fancybox-overlay\")) return b.isActive ? b.close() : c.close(), !1\r\n                });\r\n                this.overlay.css(a.css).show()\r\n            },\r\n            close: function () {\r\n                q.unbind(\"resize.overlay\");\r\n                this.el.hasClass(\"fancybox-lock\") && (f(\".fancybox-margin\").removeClass(\"fancybox-margin\"), this.el.removeClass(\"fancybox-lock\"), q.scrollTop(this.scrollV).scrollLeft(this.scrollH));\r\n                f(\".fancybox-overlay\").remove().hide();\r\n                f.extend(this, {overlay: null, fixed: !1})\r\n            },\r\n            update: function () {\r\n                var a = \"100%\", b;\r\n                this.overlay.width(a).height(\"100%\");\r\n                K ? (b = Math.max(J.documentElement.offsetWidth, J.body.offsetWidth), p.width() > b && (a = p.width())) : p.width() > q.width() && (a = p.width());\r\n                this.overlay.width(a).height(p.height())\r\n            },\r\n            onReady: function (a, b) {\r\n                var d = this.overlay;\r\n                f(\".fancybox-overlay\").stop(!0, !0);\r\n                d || this.create(a);\r\n                a.locked && this.fixed && b.fixed && (b.locked = this.overlay.append(b.wrap), b.fixed = !1);\r\n                !0 === a.showEarly && this.beforeShow.apply(this, arguments)\r\n            },\r\n            beforeShow: function (a, b) {\r\n                b.locked && !this.el.hasClass(\"fancybox-lock\") && (!1 !== this.fixPosition && f(\"*:not(object)\").filter(function () {\r\n                    return \"fixed\" ===\r\n                        f(this).css(\"position\") && !f(this).hasClass(\"fancybox-overlay\") && !f(this).hasClass(\"fancybox-wrap\")\r\n                }).addClass(\"fancybox-margin\"), this.el.addClass(\"fancybox-margin\"), this.scrollV = q.scrollTop(), this.scrollH = q.scrollLeft(), this.el.addClass(\"fancybox-lock\"), q.scrollTop(this.scrollV).scrollLeft(this.scrollH));\r\n                this.open(a)\r\n            },\r\n            onUpdate: function () {\r\n                this.fixed || this.update()\r\n            },\r\n            afterClose: function (a) {\r\n                this.overlay && !b.coming && this.overlay.fadeOut(a.speedOut, f.proxy(this.close, this))\r\n            }\r\n        };\r\n        b.helpers.title = {\r\n            defaults: {\r\n                type: \"float\",\r\n                position: \"bottom\"\r\n            }, beforeShow: function (a) {\r\n                var c = b.current, d = c.title, e = a.type;\r\n                f.isFunction(d) && (d = d.call(c.element, c));\r\n                if (r(d) && \"\" !== f.trim(d)) {\r\n                    c = f('<div class=\"fancybox-title fancybox-title-' + e + '-wrap\">' + d + \"</div>\");\r\n                    switch (e) {\r\n                        case \"inside\":\r\n                            e = b.skin;\r\n                            break;\r\n                        case \"outside\":\r\n                            e = b.wrap;\r\n                            break;\r\n                        case \"over\":\r\n                            e = b.inner;\r\n                            break;\r\n                        default:\r\n                            e = b.skin, c.appendTo(\"body\"), K && c.width(c.width()), c.wrapInner('<span class=\"child\"></span>'), b.current.margin[2] += Math.abs(m(c.css(\"margin-bottom\")))\r\n                    }\r\n                    c[\"top\" === a.position ? \"prependTo\" :\r\n                        \"appendTo\"](e)\r\n                }\r\n            }\r\n        };\r\n        f.fn.fancybox = function (a) {\r\n            var c, d = f(this), e = this.selector || \"\", k = function (g) {\r\n                var l = f(this).blur(), h = c, k, m;\r\n                g.ctrlKey || g.altKey || g.shiftKey || g.metaKey || l.is(\".fancybox-wrap\") || (k = a.groupAttr || \"data-fancybox-group\", m = l.attr(k), m || (k = \"rel\", m = l.get(0)[k]), m && \"\" !== m && \"nofollow\" !== m && (l = e.length ? f(e) : d, l = l.filter(\"[\" + k + '=\"' + m + '\"]'), h = l.index(this)), a.index = h, !1 !== b.open(l, a) && g.preventDefault())\r\n            };\r\n            a = a || {};\r\n            c = a.index || 0;\r\n            e && !1 !== a.live ? p.undelegate(e, \"click.fb-start\").delegate(e + \":not('.fancybox-item, .fancybox-nav')\",\r\n                \"click.fb-start\", k) : d.unbind(\"click.fb-start\").bind(\"click.fb-start\", k);\r\n            this.filter(\"[data-fancybox-start=1]\").trigger(\"click\");\r\n            return this\r\n        };\r\n        p.ready(function () {\r\n            var a, c;\r\n            f.scrollbarWidth === x && (f.scrollbarWidth = function () {\r\n                var a = f('<div style=\"width:50px;height:50px;overflow:auto\"><div/></div>').appendTo(\"body\"),\r\n                    b = a.children(), b = b.innerWidth() - b.height(99).innerWidth();\r\n                a.remove();\r\n                return b\r\n            });\r\n            f.support.fixedPosition === x && (f.support.fixedPosition = function () {\r\n                var a = f('<div style=\"position:fixed;top:20px;\"></div>').appendTo(\"body\"),\r\n                    b = 20 === a[0].offsetTop || 15 === a[0].offsetTop;\r\n                a.remove();\r\n                return b\r\n            }());\r\n            f.extend(b.defaults, {\r\n                scrollbarWidth: f.scrollbarWidth(),\r\n                fixed: f.support.fixedPosition,\r\n                parent: f(\"body\")\r\n            });\r\n            a = f(t).width();\r\n            L.addClass(\"fancybox-lock-test\");\r\n            c = f(t).width();\r\n            L.removeClass(\"fancybox-lock-test\");\r\n            f(\"<style type='text/css'>.fancybox-margin{margin-right:\" + (c - a) + \"px;}</style>\").appendTo(\"head\")\r\n        })\r\n    })(window, document, jQuery);\r\n});\r\n","Klarna_Kp/js/action/override.js":"/**\n * This file is part of the Klarna KP module\n *\n * (c) Klarna Bank AB (publ)\n *\n * For the full copyright and license information, please view the NOTICE\n * and LICENSE files that were distributed with this source code.\n */\n/*jshint browser:true jquery:true*/\n/*global alert*/\ndefine([\n  'mage/utils/wrapper',\n  'Klarna_Kp/js/model/config',\n  'Magento_Checkout/js/model/full-screen-loader'\n], function (wrapper, config, loader) {\n  'use strict';\n\n  /**\n   * This is needed to prevent the customer from a race condition between 'Place Order' and adding/removing a coupon,\n   * giftcard, rewards points, etc.. as it affects order totals\n   */\n  return function (overriddenFunction) {\n    return wrapper.wrap(overriddenFunction, function (originalAction) {\n      if (!config.enabled) {\n        return originalAction();\n      }\n      if (config.hasErrors()) {\n        return originalAction();\n      }\n      loader.startLoader();\n      return originalAction().then(function () {\n        loader.stopLoader();\n      });\n    });\n  };\n});\n","Klarna_Kp/js/action/set-payment-method-action.js":"define(\n    [\n        'jquery',\n        'Klarna_Kp/js/model/config'\n    ],\n    function ($, config) {\n        'use strict';\n        return function (messageContainer) {\n          $.mage.redirect(config.redirect_url);\n        };\n    }\n);\n","Klarna_Kp/js/model/config.js":"/**\n * This file is part of the Klarna KP module\n *\n * (c) Klarna Bank AB (publ)\n *\n * For the full copyright and license information, please view the NOTICE\n * and LICENSE files that were distributed with this source code.\n */\ndefine(\n  [\n    'ko'\n  ],\n  function (ko) {\n    'use strict';\n    var client_token = window.checkoutConfig.payment.klarna_kp.client_token,\n      message = window.checkoutConfig.payment.klarna_kp.message,\n      authorization_token = ko.observable(window.checkoutConfig.payment.klarna_kp.authorization_token),\n      debug = window.checkoutConfig.payment.klarna_kp.debug,\n      enabled = window.checkoutConfig.payment.klarna_kp.enabled,\n      b2b_enabled = window.checkoutConfig.payment.klarna_kp.b2b_enabled,\n      data_sharing_onload = window.checkoutConfig.payment.klarna_kp.data_sharing_onload,\n      success = window.checkoutConfig.payment.klarna_kp.success,\n      hasErrors = ko.observable(false),\n      available_methods = window.checkoutConfig.payment.klarna_kp.available_methods,\n      redirect_url = window.checkoutConfig.payment.klarna_kp.redirect_url;\n\n    return {\n      hasErrors: hasErrors,\n      debug: debug,\n      enabled: enabled,\n      b2b_enabled: b2b_enabled,\n      data_sharing_onload: data_sharing_onload,\n      client_token: client_token,\n      message: message,\n      success: success,\n      authorization_token: authorization_token,\n      available_methods: available_methods,\n      redirect_url: redirect_url,\n      getTitle: function (code) {\n        if (window.checkoutConfig.payment.klarna_kp[code]) {\n          return window.checkoutConfig.payment.klarna_kp[code].title;\n        }\n        return 'Klarna Payments';\n      },\n      getLogo: function (code) {\n        if (window.checkoutConfig.payment.klarna_kp[code]) {\n          return window.checkoutConfig.payment.klarna_kp[code].logo;\n        }\n        return '';\n      }\n    };\n  }\n);\n","Klarna_Kp/js/model/debug.js":"/**\n * This file is part of the Klarna KP module\n *\n * (c) Klarna Bank AB (publ)\n *\n * For the full copyright and license information, please view the NOTICE\n * and LICENSE files that were distributed with this source code.\n */\ndefine(\n  [\n    'Klarna_Kp/js/model/config'\n  ],\n  function (config) {\n    'use strict';\n    return {\n      log: function (message) {\n        if (config.debug) {\n          console.trace();\n          console.log(message);\n        }\n      },\n      group: function (groupid) {\n        if (config.debug) {\n          console.group(groupid);\n        }\n      },\n      groupEnd: function () {\n        if (config.debug) {\n          console.groupEnd();\n        }\n      },\n      table: function (tabularData, properties) {\n        if (config.debug) {\n          console.trace();\n          console.table(tabularData, properties);\n        }\n      }\n    };\n  }\n);\n","Klarna_Kp/js/model/klarna.js":"/* global Klarna */\n/**\n * This file is part of the Klarna KP module\n *\n * (c) Klarna Bank AB (publ)\n *\n * For the full copyright and license information, please view the NOTICE\n * and LICENSE files that were distributed with this source code.\n */\ndefine(\n  [\n    'jquery',\n    'Magento_Checkout/js/model/quote',\n    'Magento_Customer/js/model/customer',\n    'Klarna_Kp/js/model/config',\n    'Klarna_Kp/js/model/debug',\n    'klarnapi'\n  ],\n  function ($, quote, customer, config, debug) {\n    'use strict';\n    return {\n      b2b_enabled: config.b2b_enabled,\n      buildAddress: function (address, email, isShipping = false) {\n        var addr = {\n          'organization_name': '',\n          'given_name': '',\n          'family_name': '',\n          'street_address': '',\n          'city': '',\n          'postal_code': '',\n          'country': '',\n          'phone': '',\n          'email': email\n        };\n\n        if (!address) { // Somehow we got a null passed in\n          return addr;\n        }\n        if (address.prefix) {\n          addr['title'] = address.prefix;\n        }\n        if (address.firstname) {\n          addr['given_name'] = address.firstname;\n        }\n        if (address.lastname) {\n          addr['family_name'] = address.lastname;\n        }\n        if (address.street) {\n          if (address.street.length > 0) {\n            addr['street_address'] = address.street[0];\n          }\n          if (address.street.length > 1) {\n            addr['street_address2'] = address.street[1];\n          }\n        }\n        if (address.city) {\n          addr['city'] = address.city;\n        }\n        if (address.regionCode) {\n          addr['region'] = address.regionCode;\n        }\n        if (address.postcode) {\n          addr['postal_code'] = address.postcode;\n        }\n        if (address.countryId) {\n          addr['country'] = address.countryId;\n        }\n        if (address.telephone) {\n          addr['phone'] = address.telephone;\n        }\n        // Having organization_name in the billing address causes KP/PLSI to return B2B methods\n        // no matter the customer type. So we only want to set this if the merchant has enabled B2B.\n        if (address.company && (this.b2b_enabled || isShipping)) {\n          addr['organization_name'] = address.company;\n        }\n        debug.log(addr);\n        return addr;\n      },\n      buildCustomer: function (billingAddress) {\n        var type = 'person';\n\n        if (this.b2b_enabled && billingAddress.company) {\n          type = 'organization';\n        }\n\n        return {\n          'type': type\n        };\n      },\n      getUpdateData: function () {\n        var email = '',\n          shippingAddress = quote.shippingAddress(),\n          data = {\n            'billing_address': {},\n            'shipping_address': {},\n            'customer': {}\n          };\n\n        if (customer.isLoggedIn()) {\n          email = customer.customerData.email;\n        } else {\n          email = quote.guestEmail;\n        }\n        if (quote.isVirtual()) {\n          shippingAddress = quote.billingAddress();\n        }\n        data.billing_address = this.buildAddress(quote.billingAddress(), email);\n        data.shipping_address = this.buildAddress(shippingAddress, email, true);\n        data.customer = this.buildCustomer(quote.billingAddress());\n        debug.log(data);\n        return data;\n      },\n      load: function (payment_method, container_id, callback) {\n        var data = null;\n\n        debug.log('Loading container ' + container_id);\n        if ($('#' + container_id).length) {\n          debug.log('Loading method ' + payment_method);\n          if (config.data_sharing_onload) {\n            data = this.getUpdateData();\n          }\n          Klarna.Payments.load(\n            {\n              payment_method_category: payment_method,\n              container: \"#\" + container_id\n            },\n            data,\n            function (res) {\n              var errors = false;\n\n              debug.log(res);\n              if (res.errors) {\n                errors = true;\n              }\n              config.hasErrors(errors);\n              if (callback) {\n                callback(res);\n              }\n            }\n          );\n        }\n      },\n      init: function () {\n        Klarna.Payments.init({\n          client_token: config.client_token\n        });\n      },\n      authorize: function (payment_method, data, callback) {\n        Klarna.Payments.authorize(\n          {\n            payment_method_category: payment_method\n          },\n          data,\n          function (res) {\n            var errors = false;\n\n            debug.log(res);\n            if (true === res.approved) {\n              config.authorization_token(res.authorization_token);\n            }\n            if (res.errors) {\n              errors = true;\n            }\n            config.hasErrors(errors);\n            callback(res);\n          }\n        );\n      },\n      finalize: function (payment_method, data, callback) {\n        Klarna.Payments.finalize(\n          {\n            payment_method_category: payment_method\n          },\n          data,\n          function (res) {\n            var errors = false;\n\n            debug.log(res);\n            if (true === res.approved) {\n              config.authorization_token(res.authorization_token);\n            }\n            if (res.errors) {\n              errors = true;\n            }\n            config.hasErrors(errors);\n            callback(res);\n          }\n        );\n      }\n    };\n  }\n);\n","Klarna_Kp/js/view/payments.js":"/**\n * This file is part of the Klarna KP module\n *\n * (c) Klarna Bank AB (publ)\n *\n * For the full copyright and license information, please view the NOTICE\n * and LICENSE files that were distributed with this source code.\n */\ndefine(\n  [\n    'underscore',\n    'uiComponent',\n    'Magento_Checkout/js/model/payment/renderer-list',\n    'Klarna_Kp/js/model/config'\n  ],\n  function (_,\n            Component,\n            rendererList,\n            config) {\n    'use strict';\n    if (config.available_methods && _.isArray(config.available_methods)) {\n      config.available_methods.forEach(function (value) {\n        rendererList.push(value);\n      });\n    }\n    // Add view logic here if needed\n    return Component.extend({});\n  }\n);\n","Klarna_Kp/js/view/payments/kp.js":"/**\n * This file is part of the Klarna KP module\n *\n * (c) Klarna Bank AB (publ)\n *\n * For the full copyright and license information, please view the NOTICE\n * and LICENSE files that were distributed with this source code.\n */\ndefine(\n  [\n    'ko',\n    'jquery',\n    'mage/translate',\n    'Magento_Checkout/js/view/payment/default',\n    'Magento_Checkout/js/view/billing-address',\n    'Magento_Checkout/js/model/full-screen-loader',\n    'Magento_Checkout/js/action/set-payment-information',\n    'Klarna_Kp/js/model/config',\n    'Klarna_Kp/js/model/klarna',\n    'Magento_Checkout/js/model/quote',\n    'Magento_Checkout/js/model/payment/additional-validators',\n    'Klarna_Kp/js/view/payments',\n    'Klarna_Kp/js/model/debug',\n    'Klarna_Kp/js/action/set-payment-method-action'\n  ],\n  function (ko,\n            $,\n            $t,\n            Component,\n            billingAddress,\n            fullScreenLoader,\n            setPaymentInformationAction,\n            config,\n            klarna,\n            quote,\n            additionalValidators,\n            kp,\n            debug,\n            setPaymentMethodAction) {\n    'use strict';\n\n    return Component.extend({\n      defaults: {\n        template: 'Klarna_Kp/payments/kp',\n        timeoutMessage: 'Sorry, but something went wrong. Please contact the seller.',\n        redirectAfterPlaceOrder: false\n      },\n      placeOrderHandler: null,\n      validateHandler: null,\n\n      isVisible: ko.observable(true),\n      isLoading: false,\n      isBillingSameAsShipping: true,\n      showButton: ko.observable(false),\n\n      checkPreSelect: function() {\n        if (this.getCode() === this.isChecked()) {\n          this.isLoading = false;\n          this.debounceKlarnaLoad();\n        }\n      },\n\n      getLogoUrl: function() {\n        return config.getLogo(this.getCategoryId());\n      },\n\n      /**\n       * @param {Object} handler\n       */\n      setPlaceOrderHandler: function (handler) {\n        this.placeOrderHandler = handler;\n      },\n\n      /**\n       * @param {Object} handler\n       */\n      setValidateHandler: function (handler) {\n        this.validateHandler = handler;\n      },\n\n      /**\n       * @returns {Object}\n       */\n      context: function () {\n        return this;\n      },\n\n      /**\n       * @returns {Boolean}\n       */\n      isShowLegend: function () {\n        return true;\n      },\n\n      getTitle: function () {\n        return config.getTitle(this.getCategoryId());\n      },\n\n      /**\n       * Get data\n       * @returns {Object}\n       */\n      getData: function () {\n        return {\n          'method': this.item.method,\n          'additional_data': {\n            'method_title': this.getTitle(),\n            'logo': this.getLogoUrl(),\n            'authorization_token': config.authorization_token()\n          }\n        };\n      },\n\n      getCategoryId: function () {\n        // Strip off \"klarna_\"\n        return this.getCode().substr(7);\n      },\n\n      hasMessage: function () {\n        return config.message !== null || config.client_token === null || config.client_token === '';\n      },\n\n      getMessage: function () {\n        if (config.message !== null) {\n          return config.message;\n        }\n        return $t('An unknown error occurred. Please try another payment method');\n      },\n\n      getClientToken: function () {\n        return config.client_token;\n      },\n\n      getAuthorizationToken: function () {\n        return config.authorization_token();\n      },\n      initialize: function () {\n        var self = this;\n\n        this._super();\n\n        this.showButton(false);\n        if (this.hasMessage()) {\n          // Don't try to initialize Klarna\n          return;\n        }\n        klarna.init();\n        quote.paymentMethod.subscribe(function (value) {\n          self.isLoading = false;\n          if (value && value.method === self.getCode()) {\n            self.debounceKlarnaLoad();\n          }\n        });\n        config.hasErrors.subscribe(function (value) {\n          self.showButton(value);\n        });\n\n        billingAddress().isAddressSameAsShipping.subscribe(function (isSame) {\n          self.isBillingSameAsShipping = isSame;\n        });\n        quote.shippingAddress.subscribe(function () {\n          // MAGE-803: When billing and shipping are the same, both the shipping and billing listeners will be\n          // called with the shipping one called first. If we allow this to update KP in that case then the\n          // billing address will not match between Magento and Klarna as by the time it reaches here the address\n          // change will not have propagated to the billing address in the Magento quote and the billing listener\n          // will be blocked from updating KP as an update will already be in progress.\n          if (self.getCode() === self.isChecked() && !self.isBillingSameAsShipping) {\n            self.debounceKlarnaLoad();\n          }\n        });\n        quote.billingAddress.subscribe(function () {\n          if (self.getCode() === self.isChecked()) {\n            self.debounceKlarnaLoad();\n          }\n        });\n        quote.totals.subscribe(function (newTotals) {\n            if (self.getCode() === self.isChecked()) {\n                self.debounceKlarnaLoad();\n            }\n        });\n      },\n      getContainerId: function () {\n        return this.getCode().replace(new RegExp('_', 'g'), '-') + '-container';\n      },\n      selectPaymentMethod: function () {\n        this.isLoading = false;\n        this.debounceKlarnaLoad();\n        return this._super();\n      },\n      loadTimeout: null,\n      debounceKlarnaLoad: function () {\n        var self = this;\n        if (self.loadTimeout) {\n          clearTimeout(self.loadTimeout);\n        }\n        self.loadTimeout = setTimeout(function(){\n          self.loadKlarna();\n        }, 200);\n      },\n\n      loadKlarna: function () {\n        var self = this;\n\n        if (self.isLoading) {\n          return false;\n        }\n        self.isLoading = true;\n        try {\n          klarna.load(self.getCategoryId(), self.getContainerId(), function (res) {\n            debug.log(res);\n            self.showButton(res.show_form);\n            self.isLoading = false;\n          });\n          return true;\n        } catch (e) {\n          debug.log(e);\n          self.isLoading = false;\n          return false;\n        }\n      },\n      authorize: function () {\n        var self = this;\n\n        if (additionalValidators.validate()) {\n          self.showButton(false);\n          if (this.hasMessage()) {\n            return;\n          }\n          klarna.authorize(self.getCategoryId(), klarna.getUpdateData(), function (res) {\n            debug.log(res);\n            if (res.approved) {\n              if (res.finalize_required) {\n                self.finalize();\n                return;\n              }\n              self.placeOrder();\n            }\n\n            if (res.show_form === false) {\n              self.showButton(false);\n            } else {\n              self.showButton(true);\n            }\n\n          });\n        }\n      },\n      finalize: function () {\n        var self = this;\n\n        if (this.hasMessage()) {\n          self.showButton(false);\n          return;\n        }\n        klarna.finalize(self.getCategoryId(), klarna.getUpdateData(), function (res) {\n          debug.log(res);\n          if (res.approved) {\n            self.placeOrder();\n          }\n          self.showButton(true);\n        });\n      },\n      afterPlaceOrder: function () {\n        setPaymentMethodAction(this.messageContainer);\n        return;\n      }\n    });\n  }\n);\n","Klarna_Onsitemessaging/js/cart-update.js":"/**\n * This file is part of the Klarna Onsitemessaging module\n *\n * (c) Klarna Bank AB (publ)\n *\n * For the full copyright and license information, please view the NOTICE\n * and LICENSE files that were distributed with this source code.\n */\ndefine([\n    'Magento_Checkout/js/model/totals'\n], function (totalsService) {\n    'use strict';\n\n    // Monitor the cart totals so we can update messaging with any price changes\n    totalsService.totals.subscribe(function () {\n        if (document.querySelector('klarna-placement')) {\n            const grand_total = totalsService.getSegment('grand_total').value;\n            const price = Math.round(grand_total * 100);\n\n            document.querySelector('klarna-placement').dataset.purchaseAmount = price;\n            window.KlarnaOnsiteService = window.KlarnaOnsiteService || [];\n            window.KlarnaOnsiteService.push({eventName: 'refresh-placements'});\n        }\n    });\n});\n","Klarna_Onsitemessaging/js/pricebox-widget-mixin.js":"/**\n * This file is part of the Klarna Onsitemessaging module\n *\n * (c) Klarna Bank AB (publ)\n *\n * For the full copyright and license information, please view the NOTICE\n * and LICENSE files that were distributed with this source code.\n */\ndefine(['jquery'], function ($) {\n    'use strict';\n\n    var priceBoxWidget = {\n        updatePrice: function (newPrices) {\n            let ret = this._super(newPrices);\n\n            if (document.querySelector('klarna-placement')) {\n                const price = Math.round(this.cache.displayPrices.finalPrice.amount * 100);\n                document.querySelector('klarna-placement').dataset.purchaseAmount = price;\n                window.KlarnaOnsiteService = window.KlarnaOnsiteService || [];\n                window.KlarnaOnsiteService.push({eventName: 'refresh-placements'});\n            }\n            return ret;\n        }\n    };\n    return function (targetWidget) {\n        $.widget('mage.priceBox', targetWidget, priceBoxWidget);\n\n        return $.mage.priceBox;\n    };\n});\n","knockoutjs/knockout-es5.js":"/*!\n * Knockout ES5 plugin - https://github.com/SteveSanderson/knockout-es5\n * Copyright (c) Steve Sanderson\n * MIT license\n */\n\n(function(global, undefined) {\n  'use strict';\n\n  var ko;\n\n  // Model tracking\n  // --------------\n  //\n  // This is the central feature of Knockout-ES5. We augment model objects by converting properties\n  // into ES5 getter/setter pairs that read/write an underlying Knockout observable. This means you can\n  // use plain JavaScript syntax to read/write the property while still getting the full benefits of\n  // Knockout's automatic dependency detection and notification triggering.\n  //\n  // For comparison, here's Knockout ES3-compatible syntax:\n  //\n  //     var firstNameLength = myModel.user().firstName().length; // Read\n  //     myModel.user().firstName('Bert'); // Write\n  //\n  // ... versus Knockout-ES5 syntax:\n  //\n  //     var firstNameLength = myModel.user.firstName.length; // Read\n  //     myModel.user.firstName = 'Bert'; // Write\n\n  // `ko.track(model)` converts each property on the given model object into a getter/setter pair that\n  // wraps a Knockout observable. Optionally specify an array of property names to wrap; otherwise we\n  // wrap all properties. If any of the properties are already observables, we replace them with\n  // ES5 getter/setter pairs that wrap your original observable instances. In the case of readonly\n  // ko.computed properties, we simply do not define a setter (so attempted writes will be ignored,\n  // which is how ES5 readonly properties normally behave).\n  //\n  // By design, this does *not* recursively walk child object properties, because making literally\n  // everything everywhere independently observable is usually unhelpful. When you do want to track\n  // child object properties independently, define your own class for those child objects and put\n  // a separate ko.track call into its constructor --- this gives you far more control.\n  /**\n   * @param {object} obj\n   * @param {object|array.<string>} propertyNamesOrSettings\n   * @param {boolean} propertyNamesOrSettings.deep Use deep track.\n   * @param {array.<string>} propertyNamesOrSettings.fields Array of property names to wrap.\n   * todo: @param {array.<string>} propertyNamesOrSettings.exclude Array of exclude property names to wrap.\n   * todo: @param {function(string, *):boolean} propertyNamesOrSettings.filter Function to filter property \n   *   names to wrap. A function that takes ... params\n   * @return {object}\n   */\n  function track(obj, propertyNamesOrSettings) {\n    if (!obj || typeof obj !== 'object') {\n      throw new Error('When calling ko.track, you must pass an object as the first parameter.');\n    }\n\n    var propertyNames;\n\n    if ( isPlainObject(propertyNamesOrSettings) ) {\n      // defaults\n      propertyNamesOrSettings.deep = propertyNamesOrSettings.deep || false;\n      propertyNamesOrSettings.fields = propertyNamesOrSettings.fields || Object.getOwnPropertyNames(obj);\n      propertyNamesOrSettings.lazy = propertyNamesOrSettings.lazy || false;\n\n      wrap(obj, propertyNamesOrSettings.fields, propertyNamesOrSettings);\n    } else {\n      propertyNames = propertyNamesOrSettings || Object.getOwnPropertyNames(obj);\n      wrap(obj, propertyNames, {});\n    }\n\n    return obj;\n  }\n\n  // fix for ie\n  var rFunctionName = /^function\\s*([^\\s(]+)/;\n  function getFunctionName( ctor ){\n    if (ctor.name) {\n      return ctor.name;\n    }\n    return (ctor.toString().trim().match( rFunctionName ) || [])[1];\n  }\n\n  function canTrack(obj) {\n    return obj && typeof obj === 'object' && getFunctionName(obj.constructor) === 'Object';\n  }\n\n  function createPropertyDescriptor(originalValue, prop, map) {\n    var isObservable = ko.isObservable(originalValue);\n    var isArray = !isObservable && Array.isArray(originalValue);\n    var observable = isObservable ? originalValue\n        : isArray ? ko.observableArray(originalValue)\n        : ko.observable(originalValue);\n\n    map[prop] = function () { return observable; };\n\n    // add check in case the object is already an observable array\n    if (isArray || (isObservable && 'push' in observable)) {\n      notifyWhenPresentOrFutureArrayValuesMutate(ko, observable);\n    }\n\n    return {\n      configurable: true,\n      enumerable: true,\n      get: observable,\n      set: ko.isWriteableObservable(observable) ? observable : undefined\n    };\n  }\n\n  function createLazyPropertyDescriptor(originalValue, prop, map) {\n    if (ko.isObservable(originalValue)) {\n      // no need to be lazy if we already have an observable\n      return createPropertyDescriptor(originalValue, prop, map);\n    }\n\n    var observable;\n\n    function getOrCreateObservable(value, writing) {\n      if (observable) {\n        return writing ? observable(value) : observable;\n      }\n\n      if (Array.isArray(value)) {\n        observable = ko.observableArray(value);\n        notifyWhenPresentOrFutureArrayValuesMutate(ko, observable);\n        return observable;\n      }\n\n      return (observable = ko.observable(value));\n    }\n\n    map[prop] = function () { return getOrCreateObservable(originalValue); };\n    return {\n      configurable: true,\n      enumerable: true,\n      get: function () { return getOrCreateObservable(originalValue)(); },\n      set: function (value) { getOrCreateObservable(value, true); }\n    };\n  }\n\n  function wrap(obj, props, options) {\n    if (!props.length) {\n      return;\n    }\n\n    var allObservablesForObject = getAllObservablesForObject(obj, true);\n    var descriptors = {};\n\n    props.forEach(function (prop) {\n      // Skip properties that are already tracked\n      if (prop in allObservablesForObject) {\n        return;\n      }\n\n      // Skip properties where descriptor can't be redefined\n      if (Object.getOwnPropertyDescriptor(obj, prop).configurable === false){\n        return;\n      }\n\n      var originalValue = obj[prop];\n      descriptors[prop] = (options.lazy ? createLazyPropertyDescriptor : createPropertyDescriptor)\n        (originalValue, prop, allObservablesForObject);\n\n      if (options.deep && canTrack(originalValue)) {\n        wrap(originalValue, Object.keys(originalValue), options);\n      }\n    });\n\n    Object.defineProperties(obj, descriptors);\n  }\n\n  function isPlainObject( obj ){\n    return !!obj && typeof obj === 'object' && obj.constructor === Object;\n  }\n\n  // Lazily created by `getAllObservablesForObject` below. Has to be created lazily because the\n  // WeakMap factory isn't available until the module has finished loading (may be async).\n  var objectToObservableMap;\n\n  // Gets or creates the hidden internal key-value collection of observables corresponding to\n  // properties on the model object.\n  function getAllObservablesForObject(obj, createIfNotDefined) {\n    if (!objectToObservableMap) {\n      objectToObservableMap = weakMapFactory();\n    }\n\n    var result = objectToObservableMap.get(obj);\n    if (!result && createIfNotDefined) {\n      result = {};\n      objectToObservableMap.set(obj, result);\n    }\n    return result;\n  }\n\n  // Removes the internal references to observables mapped to the specified properties\n  // or the entire object reference if no properties are passed in. This allows the\n  // observables to be replaced and tracked again.\n  function untrack(obj, propertyNames) {\n    if (!objectToObservableMap) {\n      return;\n    }\n\n    if (arguments.length === 1) {\n      objectToObservableMap['delete'](obj);\n    } else {\n      var allObservablesForObject = getAllObservablesForObject(obj, false);\n      if (allObservablesForObject) {\n        propertyNames.forEach(function(propertyName) {\n          delete allObservablesForObject[propertyName];\n        });\n      }\n    }\n  }\n\n  // Computed properties\n  // -------------------\n  //\n  // The preceding code is already sufficient to upgrade ko.computed model properties to ES5\n  // getter/setter pairs (or in the case of readonly ko.computed properties, just a getter).\n  // These then behave like a regular property with a getter function, except they are smarter:\n  // your evaluator is only invoked when one of its dependencies changes. The result is cached\n  // and used for all evaluations until the next time a dependency changes).\n  //\n  // However, instead of forcing developers to declare a ko.computed property explicitly, it's\n  // nice to offer a utility function that declares a computed getter directly.\n\n  // Implements `ko.defineProperty`\n  function defineComputedProperty(obj, propertyName, evaluatorOrOptions) {\n    var ko = this,\n      computedOptions = { owner: obj, deferEvaluation: true };\n\n    if (typeof evaluatorOrOptions === 'function') {\n      computedOptions.read = evaluatorOrOptions;\n    } else {\n      if ('value' in evaluatorOrOptions) {\n        throw new Error('For ko.defineProperty, you must not specify a \"value\" for the property. ' +\n                        'You must provide a \"get\" function.');\n      }\n\n      if (typeof evaluatorOrOptions.get !== 'function') {\n        throw new Error('For ko.defineProperty, the third parameter must be either an evaluator function, ' +\n                        'or an options object containing a function called \"get\".');\n      }\n\n      computedOptions.read = evaluatorOrOptions.get;\n      computedOptions.write = evaluatorOrOptions.set;\n    }\n\n    obj[propertyName] = ko.computed(computedOptions);\n    track.call(ko, obj, [propertyName]);\n    return obj;\n  }\n\n  // Array handling\n  // --------------\n  //\n  // Arrays are special, because unlike other property types, they have standard mutator functions\n  // (`push`/`pop`/`splice`/etc.) and it's desirable to trigger a change notification whenever one of\n  // those mutator functions is invoked.\n  //\n  // Traditionally, Knockout handles this by putting special versions of `push`/`pop`/etc. on observable\n  // arrays that mutate the underlying array and then trigger a notification. That approach doesn't\n  // work for Knockout-ES5 because properties now return the underlying arrays, so the mutator runs\n  // in the context of the underlying array, not any particular observable:\n  //\n  //     // Operates on the underlying array value\n  //     myModel.someCollection.push('New value');\n  //\n  // To solve this, Knockout-ES5 detects array values, and modifies them as follows:\n  //  1. Associates a hidden subscribable with each array instance that it encounters\n  //  2. Intercepts standard mutators (`push`/`pop`/etc.) and makes them trigger the subscribable\n  // Then, for model properties whose values are arrays, the property's underlying observable\n  // subscribes to the array subscribable, so it can trigger a change notification after mutation.\n\n  // Given an observable that underlies a model property, watch for any array value that might\n  // be assigned as the property value, and hook into its change events\n  function notifyWhenPresentOrFutureArrayValuesMutate(ko, observable) {\n    var watchingArraySubscription = null;\n    ko.computed(function () {\n      // Unsubscribe to any earlier array instance\n      if (watchingArraySubscription) {\n        watchingArraySubscription.dispose();\n        watchingArraySubscription = null;\n      }\n\n      // Subscribe to the new array instance\n      var newArrayInstance = observable();\n      if (newArrayInstance instanceof Array) {\n        watchingArraySubscription = startWatchingArrayInstance(ko, observable, newArrayInstance);\n      }\n    });\n  }\n\n  // Listens for array mutations, and when they happen, cause the observable to fire notifications.\n  // This is used to make model properties of type array fire notifications when the array changes.\n  // Returns a subscribable that can later be disposed.\n  function startWatchingArrayInstance(ko, observable, arrayInstance) {\n    var subscribable = getSubscribableForArray(ko, arrayInstance);\n    return subscribable.subscribe(observable);\n  }\n\n  // Lazily created by `getSubscribableForArray` below. Has to be created lazily because the\n  // WeakMap factory isn't available until the module has finished loading (may be async).\n  var arraySubscribablesMap;\n\n  // Gets or creates a subscribable that fires after each array mutation\n  function getSubscribableForArray(ko, arrayInstance) {\n    if (!arraySubscribablesMap) {\n      arraySubscribablesMap = weakMapFactory();\n    }\n\n    var subscribable = arraySubscribablesMap.get(arrayInstance);\n    if (!subscribable) {\n      subscribable = new ko.subscribable();\n      arraySubscribablesMap.set(arrayInstance, subscribable);\n\n      var notificationPauseSignal = {};\n      wrapStandardArrayMutators(arrayInstance, subscribable, notificationPauseSignal);\n      addKnockoutArrayMutators(ko, arrayInstance, subscribable, notificationPauseSignal);\n    }\n\n    return subscribable;\n  }\n\n  // After each array mutation, fires a notification on the given subscribable\n  function wrapStandardArrayMutators(arrayInstance, subscribable, notificationPauseSignal) {\n    ['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'].forEach(function(fnName) {\n      var origMutator = arrayInstance[fnName];\n      arrayInstance[fnName] = function() {\n        var result = origMutator.apply(this, arguments);\n        if (notificationPauseSignal.pause !== true) {\n          subscribable.notifySubscribers(this);\n        }\n        return result;\n      };\n    });\n  }\n\n  // Adds Knockout's additional array mutation functions to the array\n  function addKnockoutArrayMutators(ko, arrayInstance, subscribable, notificationPauseSignal) {\n    ['remove', 'removeAll', 'destroy', 'destroyAll', 'replace'].forEach(function(fnName) {\n      // Make it a non-enumerable property for consistency with standard Array functions\n      Object.defineProperty(arrayInstance, fnName, {\n        enumerable: false,\n        value: function() {\n          var result;\n\n          // These additional array mutators are built using the underlying push/pop/etc.\n          // mutators, which are wrapped to trigger notifications. But we don't want to\n          // trigger multiple notifications, so pause the push/pop/etc. wrappers and\n          // delivery only one notification at the end of the process.\n          notificationPauseSignal.pause = true;\n          try {\n            // Creates a temporary observableArray that can perform the operation.\n            result = ko.observableArray.fn[fnName].apply(ko.observableArray(arrayInstance), arguments);\n          }\n          finally {\n            notificationPauseSignal.pause = false;\n          }\n          subscribable.notifySubscribers(arrayInstance);\n          return result;\n        }\n      });\n    });\n  }\n\n  // Static utility functions\n  // ------------------------\n  //\n  // Since Knockout-ES5 sets up properties that return values, not observables, you can't\n  // trivially subscribe to the underlying observables (e.g., `someProperty.subscribe(...)`),\n  // or tell them that object values have mutated, etc. To handle this, we set up some\n  // extra utility functions that can return or work with the underlying observables.\n\n  // Returns the underlying observable associated with a model property (or `null` if the\n  // model or property doesn't exist, or isn't associated with an observable). This means\n  // you can subscribe to the property, e.g.:\n  //\n  //     ko.getObservable(model, 'propertyName')\n  //       .subscribe(function(newValue) { ... });\n  function getObservable(obj, propertyName) {\n    if (!obj || typeof obj !== 'object') {\n      return null;\n    }\n\n    var allObservablesForObject = getAllObservablesForObject(obj, false);\n    if (allObservablesForObject && propertyName in allObservablesForObject) {\n      return allObservablesForObject[propertyName]();\n    }\n\n    return null;\n  }\n  \n  // Returns a boolean indicating whether the property on the object has an underlying\n  // observables. This does the check in a way not to create an observable if the\n  // object was created with lazily created observables\n  function isTracked(obj, propertyName) {\n    if (!obj || typeof obj !== 'object') {\n      return false;\n    }\n    \n    var allObservablesForObject = getAllObservablesForObject(obj, false);\n    return !!allObservablesForObject && propertyName in allObservablesForObject;\n  }\n\n  // Causes a property's associated observable to fire a change notification. Useful when\n  // the property value is a complex object and you've modified a child property.\n  function valueHasMutated(obj, propertyName) {\n    var observable = getObservable(obj, propertyName);\n\n    if (observable) {\n      observable.valueHasMutated();\n    }\n  }\n\n  // Module initialisation\n  // ---------------------\n  //\n  // When this script is first evaluated, it works out what kind of module loading scenario\n  // it is in (Node.js or a browser `<script>` tag), stashes a reference to its dependencies\n  // (currently that's just the WeakMap shim), and then finally attaches itself to whichever\n  // instance of Knockout.js it can find.\n\n  // A function that returns a new ES6-compatible WeakMap instance (using ES5 shim if needed).\n  // Instantiated by prepareExports, accounting for which module loader is being used.\n  var weakMapFactory;\n\n  // Extends a Knockout instance with Knockout-ES5 functionality\n  function attachToKo(ko) {\n    ko.track = track;\n    ko.untrack = untrack;\n    ko.getObservable = getObservable;\n    ko.valueHasMutated = valueHasMutated;\n    ko.defineProperty = defineComputedProperty;\n\n    // todo: test it, maybe added it to ko. directly\n    ko.es5 = {\n      getAllObservablesForObject: getAllObservablesForObject,\n      notifyWhenPresentOrFutureArrayValuesMutate: notifyWhenPresentOrFutureArrayValuesMutate,\n      isTracked: isTracked\n    };\n  }\n\n  // Determines which module loading scenario we're in, grabs dependencies, and attaches to KO\n  function prepareExports() {\n    if (typeof exports === 'object' && typeof module === 'object') {\n      // Node.js case - load KO and WeakMap modules synchronously\n      ko = require('knockout');\n      var WM = require('../lib/weakmap');\n      attachToKo(ko);\n      weakMapFactory = function() { return new WM(); };\n      module.exports = ko;\n    } else if (typeof define === 'function' && define.amd) {\n      define(['knockout'], function(koModule) {\n        ko = koModule;\n        attachToKo(koModule);\n        weakMapFactory = function() { return new global.WeakMap(); };\n        return koModule;\n      });\n    } else if ('ko' in global) {\n      // Non-module case - attach to the global instance, and assume a global WeakMap constructor\n      ko = global.ko;\n      attachToKo(global.ko);\n      weakMapFactory = function() { return new global.WeakMap(); };\n    }\n  }\n\n  prepareExports();\n\n})(this);","knockoutjs/knockout-fast-foreach.js":"/*!\n  Knockout Fast Foreach v0.4.1 (2015-07-17T14:06:15.974Z)\n  By: Brian M Hunt (C) 2015\n  License: MIT\n\n  Adds `fastForEach` to `ko.bindingHandlers`.\n*/\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['knockout'], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require('knockout'));\n  } else {\n    root.KnockoutFastForeach = factory(root.ko);\n  }\n}(this, function (ko) {\n  \"use strict\";\n// index.js\n// --------\n// Fast For Each\n//\n// Employing sound techniques to make a faster Knockout foreach binding.\n// --------\n\n//      Utilities\n\n// from https://github.com/jonschlinkert/is-plain-object\nfunction isPlainObject(o) {\n  return !!o && typeof o === 'object' && o.constructor === Object;\n}\n\n// From knockout/src/virtualElements.js\nvar commentNodesHaveTextProperty = document && document.createComment(\"test\").text === \"<!--test-->\";\nvar startCommentRegex = commentNodesHaveTextProperty ? /^<!--\\s*ko(?:\\s+([\\s\\S]+))?\\s*-->$/ : /^\\s*ko(?:\\s+([\\s\\S]+))?\\s*$/;\nvar supportsDocumentFragment = document && typeof document.createDocumentFragment === \"function\";\nfunction isVirtualNode(node) {\n  return (node.nodeType === 8) && startCommentRegex.test(commentNodesHaveTextProperty ? node.text : node.nodeValue);\n}\n\n\n// Get a copy of the (possibly virtual) child nodes of the given element,\n// put them into a container, then empty the given node.\nfunction makeTemplateNode(sourceNode) {\n  var container = document.createElement(\"div\");\n  var parentNode;\n  if (sourceNode.content) {\n    // For e.g. <template> tags\n    parentNode = sourceNode.content;\n  } else if (sourceNode.tagName === 'SCRIPT') {\n    parentNode = document.createElement(\"div\");\n    parentNode.innerHTML = sourceNode.text;\n  } else {\n    // Anything else e.g. <div>\n    parentNode = sourceNode;\n  }\n  ko.utils.arrayForEach(ko.virtualElements.childNodes(parentNode), function (child) {\n    // FIXME - This cloneNode could be expensive; we may prefer to iterate over the\n    // parentNode children in reverse (so as not to foul the indexes as childNodes are\n    // removed from parentNode when inserted into the container)\n    if (child) {\n      container.insertBefore(child.cloneNode(true), null);\n    }\n  });\n  return container;\n}\n\nfunction insertAllAfter(containerNode, nodeOrNodeArrayToInsert, insertAfterNode) {\n  var frag, len, i;\n  // poor man's node and array check, should be enough for this\n  if (typeof nodeOrNodeArrayToInsert.nodeType !== \"undefined\" && typeof nodeOrNodeArrayToInsert.length === \"undefined\") {\n    throw new Error(\"Expected a single node or a node array\");\n  }\n\n  if (typeof nodeOrNodeArrayToInsert.nodeType !== \"undefined\") {\n    ko.virtualElements.insertAfter(containerNode, nodeOrNodeArrayToInsert, insertAfterNode);\n    return;\n  }\n\n  if (nodeOrNodeArrayToInsert.length === 1) {\n    ko.virtualElements.insertAfter(containerNode, nodeOrNodeArrayToInsert[0], insertAfterNode);\n    return;\n  }\n\n  if (supportsDocumentFragment) {\n    frag = document.createDocumentFragment();\n\n    for (i = 0, len = nodeOrNodeArrayToInsert.length; i !== len; ++i) {\n      frag.appendChild(nodeOrNodeArrayToInsert[i]);\n    }\n    ko.virtualElements.insertAfter(containerNode, frag, insertAfterNode);\n  } else {\n    // Nodes are inserted in reverse order - pushed down immediately after\n    // the last node for the previous item or as the first node of element.\n    for (i = nodeOrNodeArrayToInsert.length - 1; i >= 0; --i) {\n      var child = nodeOrNodeArrayToInsert[i];\n      if (!child) {\n        return;\n      }\n      ko.virtualElements.insertAfter(containerNode, child, insertAfterNode);\n    }\n  }\n}\n\n// Mimic a KO change item 'add'\nfunction valueToChangeAddItem(value, index) {\n  return {\n    status: 'added',\n    value: value,\n    index: index\n  };\n}\n\nfunction isAdditionAdjacentToLast(changeIndex, arrayChanges) {\n  return changeIndex > 0 &&\n    changeIndex < arrayChanges.length &&\n    arrayChanges[changeIndex].status === \"added\" &&\n    arrayChanges[changeIndex - 1].status === \"added\" &&\n    arrayChanges[changeIndex - 1].index === arrayChanges[changeIndex].index - 1;\n}\n\nfunction FastForEach(spec) {\n  this.element = spec.element;\n  this.container = isVirtualNode(this.element) ?\n                   this.element.parentNode : this.element;\n  this.$context = spec.$context;\n  this.data = spec.data;\n  this.as = spec.as;\n  this.noContext = spec.noContext;\n  this.templateNode = makeTemplateNode(\n    spec.name ? document.getElementById(spec.name).cloneNode(true) : spec.element\n  );\n  this.afterQueueFlush = spec.afterQueueFlush;\n  this.beforeQueueFlush = spec.beforeQueueFlush;\n  this.changeQueue = [];\n  this.lastNodesList = [];\n  this.indexesToDelete = [];\n  this.rendering_queued = false;\n\n  // Remove existing content.\n  ko.virtualElements.emptyNode(this.element);\n\n  // Prime content\n  var primeData = ko.unwrap(this.data);\n  if (primeData.map) {\n    this.onArrayChange(primeData.map(valueToChangeAddItem));\n  }\n\n  // Watch for changes\n  if (ko.isObservable(this.data)) {\n    if (!this.data.indexOf) {\n      // Make sure the observable is trackable.\n      this.data = this.data.extend({trackArrayChanges: true});\n    }\n    this.changeSubs = this.data.subscribe(this.onArrayChange, this, 'arrayChange');\n  }\n}\n\n\nFastForEach.animateFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame ||\n  window.mozRequestAnimationFrame || window.msRequestAnimationFrame ||\n  function(cb) { return window.setTimeout(cb, 1000 / 60); };\n\n\nFastForEach.prototype.dispose = function () {\n  if (this.changeSubs) {\n    this.changeSubs.dispose();\n  }\n};\n\n\n// If the array changes we register the change.\nFastForEach.prototype.onArrayChange = function (changeSet) {\n  var self = this;\n  var changeMap = {\n    added: [],\n    deleted: []\n  };\n  for (var i = 0, len = changeSet.length; i < len; i++) {\n    // the change is appended to a last change info object when both are 'added' and have indexes next to each other\n    // here I presume that ko is sending changes in monotonic order (in index variable) which happens to be true, tested with push and splice with multiple pushed values\n    if (isAdditionAdjacentToLast(i, changeSet)) {\n      var batchValues = changeMap.added[changeMap.added.length - 1].values;\n      if (!batchValues) {\n        // transform the last addition into a batch addition object\n        var lastAddition = changeMap.added.pop();\n        var batchAddition = {\n          isBatch: true,\n          status: 'added',\n          index: lastAddition.index,\n          values: [lastAddition.value]\n        };\n        batchValues = batchAddition.values;\n        changeMap.added.push(batchAddition);\n      }\n      batchValues.push(changeSet[i].value);\n    } else {\n      changeMap[changeSet[i].status].push(changeSet[i]);\n    }\n  }\n  if (changeMap.deleted.length > 0) {\n    this.changeQueue.push.apply(this.changeQueue, changeMap.deleted);\n    this.changeQueue.push({status: 'clearDeletedIndexes'});\n  }\n  this.changeQueue.push.apply(this.changeQueue, changeMap.added);\n  // Once a change is registered, the ticking count-down starts for the processQueue.\n  if (this.changeQueue.length > 0 && !this.rendering_queued) {\n    this.rendering_queued = true;\n    FastForEach.animateFrame.call(window, function () { self.processQueue(); });\n  }\n};\n\n\n// Reflect all the changes in the queue in the DOM, then wipe the queue.\nFastForEach.prototype.processQueue = function () {\n  var self = this;\n\n  // Callback so folks can do things before the queue flush.\n  if (typeof this.beforeQueueFlush === 'function') {\n    this.beforeQueueFlush(this.changeQueue);\n  }\n\n  ko.utils.arrayForEach(this.changeQueue, function (changeItem) {\n    // console.log(self.data(), \"CI\", JSON.stringify(changeItem, null, 2), JSON.stringify($(self.element).text()))\n    self[changeItem.status](changeItem);\n    // console.log(\"  ==> \", JSON.stringify($(self.element).text()))\n  });\n  this.rendering_queued = false;\n  // Callback so folks can do things.\n  if (typeof this.afterQueueFlush === 'function') {\n    this.afterQueueFlush(this.changeQueue);\n  }\n  this.changeQueue = [];\n};\n\n\n// Process a changeItem with {status: 'added', ...}\nFastForEach.prototype.added = function (changeItem) {\n  var index = changeItem.index;\n  var valuesToAdd = changeItem.isBatch ? changeItem.values : [changeItem.value];\n  var referenceElement = this.lastNodesList[index - 1] || null;\n  // gather all childnodes for a possible batch insertion\n  var allChildNodes = [];\n\n  for (var i = 0, len = valuesToAdd.length; i < len; ++i) {\n    var templateClone = this.templateNode.cloneNode(true);\n    var childContext;\n\n    if (this.noContext) {\n      childContext = this.$context.extend({\n        '$item': valuesToAdd[i]\n      });\n    } else {\n      childContext = this.$context.createChildContext(valuesToAdd[i], this.as || null);\n    }\n\n    // apply bindings first, and then process child nodes, because bindings can add childnodes\n    ko.applyBindingsToDescendants(childContext, templateClone);\n\n    var childNodes = ko.virtualElements.childNodes(templateClone);\n    // Note discussion at https://github.com/angular/angular.js/issues/7851\n    allChildNodes.push.apply(allChildNodes, Array.prototype.slice.call(childNodes));\n    this.lastNodesList.splice(index + i, 0, childNodes[childNodes.length - 1]);\n  }\n\n  insertAllAfter(this.element, allChildNodes, referenceElement);\n};\n\n\n// Process a changeItem with {status: 'deleted', ...}\nFastForEach.prototype.deleted = function (changeItem) {\n  var index = changeItem.index;\n  var ptr = this.lastNodesList[index],\n      // We use this.element because that will be the last previous node\n      // for virtual element lists.\n      lastNode = this.lastNodesList[index - 1] || this.element;\n  do {\n    ptr = ptr.previousSibling;\n    ko.removeNode((ptr && ptr.nextSibling) || ko.virtualElements.firstChild(this.element));\n  } while (ptr && ptr !== lastNode);\n  // The \"last node\" in the DOM from which we begin our delets of the next adjacent node is\n  // now the sibling that preceded the first node of this item.\n  this.lastNodesList[index] = this.lastNodesList[index - 1];\n  this.indexesToDelete.push(index);\n};\n\n\n// We batch our deletion of item indexes in our parallel array.\n// See brianmhunt/knockout-fast-foreach#6/#8\nFastForEach.prototype.clearDeletedIndexes = function () {\n  // We iterate in reverse on the presumption (following the unit tests) that KO's diff engine\n  // processes diffs (esp. deletes) monotonically ascending i.e. from index 0 -> N.\n  for (var i = this.indexesToDelete.length - 1; i >= 0; --i) {\n    this.lastNodesList.splice(this.indexesToDelete[i], 1);\n  }\n  this.indexesToDelete = [];\n};\n\n\nko.bindingHandlers.fastForEach = {\n  // Valid valueAccessors:\n  //    []\n  //    ko.observable([])\n  //    ko.observableArray([])\n  //    ko.computed\n  //    {data: array, name: string, as: string}\n  init: function init(element, valueAccessor, bindings, vm, context) {\n    var value = valueAccessor(),\n        ffe;\n    if (isPlainObject(value)) {\n      value.element = value.element || element;\n      value.$context = context;\n      ffe = new FastForEach(value);\n    } else {\n      ffe = new FastForEach({\n        element: element,\n        data: ko.unwrap(context.$rawData) === value ? context.$rawData : value,\n        $context: context\n      });\n    }\n    ko.utils.domNodeDisposal.addDisposeCallback(element, function () {\n      ffe.dispose();\n    });\n    return {controlsDescendantBindings: true};\n  },\n\n  // Export for testing, debugging, and overloading.\n  FastForEach: FastForEach\n};\n\nko.virtualElements.allowedBindings.fastForEach = true;\n}));","knockoutjs/knockout-repeat.js":"// REPEAT binding for Knockout http://knockoutjs.com/\n// (c) Michael Best\n// License: MIT (http://www.opensource.org/licenses/mit-license.php)\n// Version 2.1.0\n\n(function(factory) {\n    if (typeof define === 'function' && define.amd) {\n        // [1] AMD anonymous module\n        define(['knockout'], factory);\n    } else if (typeof exports === 'object') {\n        // [2] commonJS\n        factory(require('knockout'));\n    } else {\n        // [3] No module loader (plain <script> tag) - put directly in global namespace\n        factory(window.ko);\n    }\n})(function(ko) {\n\nif (!ko.virtualElements)\n    throw Error('Repeat requires at least Knockout 2.1');\n\nvar ko_bindingFlags = ko.bindingFlags || {};\nvar ko_unwrap = ko.utils.unwrapObservable;\n\nvar koProtoName = '__ko_proto__';\n\nif (ko.version >= \"3.0.0\") {\n    // In Knockout 3.0.0, use the node preprocessor to replace a node with a repeat binding with a virtual element\n    var provider = ko.bindingProvider.instance, previousPreprocessFn = provider.preprocessNode;\n    provider.preprocessNode = function(node) {\n        var newNodes, nodeBinding;\n        if (!previousPreprocessFn || !(newNodes = previousPreprocessFn.call(this, node))) {\n            if (node.nodeType === 1 && (nodeBinding = node.getAttribute('data-bind'))) {\n                if (/^\\s*repeat\\s*:/.test(nodeBinding)) {\n                    var leadingComment = node.ownerDocument.createComment('ko ' + nodeBinding),\n                        trailingComment = node.ownerDocument.createComment('/ko');\n                    node.parentNode.insertBefore(leadingComment, node);\n                    node.parentNode.insertBefore(trailingComment, node.nextSibling);\n                    node.removeAttribute('data-bind');\n                    newNodes = [leadingComment, node, trailingComment];\n                }\n            }\n        }\n        return newNodes;\n    };\n}\n\nko.virtualElements.allowedBindings.repeat = true;\nko.bindingHandlers.repeat = {\n    flags: ko_bindingFlags.contentBind | ko_bindingFlags.canUseVirtual,\n    init: function(element, valueAccessor, allBindingsAccessor, xxx, bindingContext) {\n\n        // Read and set fixed options--these options cannot be changed\n        var repeatParam = ko_unwrap(valueAccessor());\n        if (repeatParam && typeof repeatParam == 'object' && !('length' in repeatParam)) {\n            var repeatIndex = repeatParam.index,\n                repeatData = repeatParam.item,\n                repeatStep = repeatParam.step,\n                repeatReversed = repeatParam.reverse,\n                repeatBind = repeatParam.bind,\n                repeatInit = repeatParam.init,\n                repeatUpdate = repeatParam.update;\n        }\n        // Set default values for options that need it\n        repeatIndex = repeatIndex || '$index';\n        repeatData = repeatData || ko.bindingHandlers.repeat.itemName || '$item';\n        repeatStep = repeatStep || 1;\n        repeatReversed = repeatReversed || false;\n\n        var parent = element.parentNode, placeholder;\n        if (element.nodeType == 8) {    // virtual element\n            // Extract the \"children\" and find the single element node\n            var childNodes = ko.utils.arrayFilter(ko.virtualElements.childNodes(element), function(node) { return node.nodeType == 1;});\n            if (childNodes.length !== 1) {\n                throw Error(\"Repeat binding requires a single element to repeat\");\n            }\n            ko.virtualElements.emptyNode(element);\n\n            // The placeholder is the closing comment normally, or the opening comment if reversed\n            placeholder = repeatReversed ? element : element.nextSibling;\n            // The element to repeat is the contained element\n            element = childNodes[0];\n        } else {    // regular element\n            // First clean the element node and remove node's binding\n            var origBindString = element.getAttribute('data-bind');\n            ko.cleanNode(element);\n            element.removeAttribute('data-bind');\n\n            // Original element is no longer needed: delete it and create a placeholder comment\n            placeholder = element.ownerDocument.createComment('ko_repeatplaceholder ' + origBindString);\n            parent.replaceChild(placeholder, element);\n        }\n\n        // extract and remove a data-repeat-bind attribute, if present\n        if (!repeatBind) {\n            repeatBind = element.getAttribute('data-repeat-bind');\n            if (repeatBind) {\n                element.removeAttribute('data-repeat-bind');\n            }\n        }\n\n        // Make a copy of the element node to be copied for each repetition\n        var cleanNode = element.cloneNode(true);\n        if (typeof repeatBind == \"string\") {\n            cleanNode.setAttribute('data-bind', repeatBind);\n            repeatBind = null;\n        }\n\n        // Set up persistent data\n        var lastRepeatCount = 0,\n            notificationObservable = ko.observable(),\n            repeatArray, arrayObservable;\n\n        if (repeatInit) {\n            repeatInit(parent);\n        }\n\n        var subscribable = ko.computed(function() {\n            function makeArrayItemAccessor(index) {\n                var f = function(newValue) {\n                    var item = repeatArray[index];\n                    // Reading the value of the item\n                    if (!arguments.length) {\n                        notificationObservable();   // for dependency tracking\n                        return ko_unwrap(item);\n                    }\n                    // Writing a value to the item\n                    if (ko.isObservable(item)) {\n                        item(newValue);\n                    } else if (arrayObservable && arrayObservable.splice) {\n                        arrayObservable.splice(index, 1, newValue);\n                    } else {\n                        repeatArray[index] = newValue;\n                    }\n                    return this;\n                };\n                // Pretend that our accessor function is an observable\n                f[koProtoName] = ko.observable;\n                return f;\n            }\n\n            function makeBinding(item, index, context) {\n                return repeatArray\n                    ? function() { return repeatBind.call(bindingContext.$data, item, index, context); }\n                    : function() { return repeatBind.call(bindingContext.$data, index, context); }\n            }\n\n            // Read and set up variable options--these options can change and will update the binding\n            var paramObservable = valueAccessor(), repeatParam = ko_unwrap(paramObservable), repeatCount = 0;\n            if (repeatParam && typeof repeatParam == 'object') {\n                if ('length' in repeatParam) {\n                    repeatArray = repeatParam;\n                    repeatCount = repeatArray.length;\n                } else {\n                    if ('foreach' in repeatParam) {\n                        repeatArray = ko_unwrap(paramObservable = repeatParam.foreach);\n                        if (repeatArray && typeof repeatArray == 'object' && 'length' in repeatArray) {\n                            repeatCount = repeatArray.length || 0;\n                        } else {\n                            repeatCount = repeatArray || 0;\n                            repeatArray = null;\n                        }\n                    }\n                    // If a count value is provided (>0), always output that number of items\n                    if ('count' in repeatParam)\n                        repeatCount = ko_unwrap(repeatParam.count) || repeatCount;\n                    // If a limit is provided, don't output more than the limit\n                    if ('limit' in repeatParam)\n                        repeatCount = Math.min(repeatCount, ko_unwrap(repeatParam.limit)) || repeatCount;\n                }\n                arrayObservable = repeatArray && ko.isObservable(paramObservable) ? paramObservable : null;\n            } else {\n                repeatCount = repeatParam || 0;\n            }\n\n            // Remove nodes from end if array is shorter\n            for (; lastRepeatCount > repeatCount; lastRepeatCount-=repeatStep) {\n                ko.removeNode(repeatReversed ? placeholder.nextSibling : placeholder.previousSibling);\n            }\n\n            // Notify existing nodes of change\n            notificationObservable.notifySubscribers();\n\n            // Add nodes to end if array is longer (also initially populates nodes)\n            for (; lastRepeatCount < repeatCount; lastRepeatCount+=repeatStep) {\n                // Clone node and add to document\n                var newNode = cleanNode.cloneNode(true);\n                parent.insertBefore(newNode, repeatReversed ? placeholder.nextSibling : placeholder);\n                newNode.setAttribute('data-repeat-index', lastRepeatCount);\n\n                // Apply bindings to inserted node\n                if (repeatArray && repeatData == '$data') {\n                    var newContext = bindingContext.createChildContext(makeArrayItemAccessor(lastRepeatCount));\n                } else {\n                    var newContext = bindingContext.extend();\n                    if (repeatArray)\n                        newContext[repeatData] = makeArrayItemAccessor(lastRepeatCount);\n                }\n                newContext[repeatIndex] = lastRepeatCount;\n                if (repeatBind) {\n                    var result = ko.applyBindingsToNode(newNode, makeBinding(newContext[repeatData], lastRepeatCount, newContext), newContext, true),\n                        shouldBindDescendants = result && result.shouldBindDescendants;\n                }\n                if (!repeatBind || (result && shouldBindDescendants !== false)) {\n                    ko.applyBindings(newContext, newNode);\n                }\n            }\n            if (repeatUpdate) {\n                repeatUpdate(parent);\n            }\n        }, null, {disposeWhenNodeIsRemoved: placeholder});\n\n        return { controlsDescendantBindings: true, subscribable: subscribable };\n    }\n};\n});","knockoutjs/knockout.js":"/*!\n * Knockout JavaScript library v3.4.2\n * (c) The Knockout.js team - http://knockoutjs.com/\n * License: MIT (http://www.opensource.org/licenses/mit-license.php)\n */\n\n(function(){\nvar DEBUG=true;\n(function(undefined){\n    // (0, eval)('this') is a robust way of getting a reference to the global object\n    // For details, see http://stackoverflow.com/questions/14119988/return-this-0-evalthis/14120023#14120023\n    var window = this || (0, eval)('this'),\n        document = window['document'],\n        navigator = window['navigator'],\n        jQueryInstance = window[\"jQuery\"],\n        JSON = window[\"JSON\"];\n(function(factory) {\n    // Support three module loading scenarios\n    if (typeof define === 'function' && define['amd']) {\n        // [1] AMD anonymous module\n        define(['exports', 'require'], factory);\n    } else if (typeof exports === 'object' && typeof module === 'object') {\n        // [2] CommonJS/Node.js\n        factory(module['exports'] || exports);  // module.exports is for Node.js\n    } else {\n        // [3] No module loader (plain <script> tag) - put directly in global namespace\n        factory(window['ko'] = {});\n    }\n}(function(koExports, amdRequire){\n// Internally, all KO objects are attached to koExports (even the non-exported ones whose names will be minified by the closure compiler).\n// In the future, the following \"ko\" variable may be made distinct from \"koExports\" so that private objects are not externally reachable.\nvar ko = typeof koExports !== 'undefined' ? koExports : {};\n// Google Closure Compiler helpers (used only to make the minified file smaller)\nko.exportSymbol = function(koPath, object) {\n    var tokens = koPath.split(\".\");\n\n    // In the future, \"ko\" may become distinct from \"koExports\" (so that non-exported objects are not reachable)\n    // At that point, \"target\" would be set to: (typeof koExports !== \"undefined\" ? koExports : ko)\n    var target = ko;\n\n    for (var i = 0; i < tokens.length - 1; i++)\n        target = target[tokens[i]];\n    target[tokens[tokens.length - 1]] = object;\n};\nko.exportProperty = function(owner, publicName, object) {\n    owner[publicName] = object;\n};\nko.version = \"3.4.2\";\n\nko.exportSymbol('version', ko.version);\n// For any options that may affect various areas of Knockout and aren't directly associated with data binding.\nko.options = {\n    'deferUpdates': false,\n    'useOnlyNativeEvents': false\n};\n\n//ko.exportSymbol('options', ko.options);   // 'options' isn't minified\nko.utils = (function () {\n    function objectForEach(obj, action) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                action(prop, obj[prop]);\n            }\n        }\n    }\n\n    function extend(target, source) {\n        if (source) {\n            for(var prop in source) {\n                if(source.hasOwnProperty(prop)) {\n                    target[prop] = source[prop];\n                }\n            }\n        }\n        return target;\n    }\n\n    function setPrototypeOf(obj, proto) {\n        obj.__proto__ = proto;\n        return obj;\n    }\n\n    var canSetPrototype = ({ __proto__: [] } instanceof Array);\n    var canUseSymbols = !DEBUG && typeof Symbol === 'function';\n\n    // Represent the known event types in a compact way, then at runtime transform it into a hash with event name as key (for fast lookup)\n    var knownEvents = {}, knownEventTypesByEventName = {};\n    var keyEventTypeName = (navigator && /Firefox\\/2/i.test(navigator.userAgent)) ? 'KeyboardEvent' : 'UIEvents';\n    knownEvents[keyEventTypeName] = ['keyup', 'keydown', 'keypress'];\n    knownEvents['MouseEvents'] = ['click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'mouseover', 'mouseout', 'mouseenter', 'mouseleave'];\n    objectForEach(knownEvents, function(eventType, knownEventsForType) {\n        if (knownEventsForType.length) {\n            for (var i = 0, j = knownEventsForType.length; i < j; i++)\n                knownEventTypesByEventName[knownEventsForType[i]] = eventType;\n        }\n    });\n    var eventsThatMustBeRegisteredUsingAttachEvent = { 'propertychange': true }; // Workaround for an IE9 issue - https://github.com/SteveSanderson/knockout/issues/406\n\n    // Detect IE versions for bug workarounds (uses IE conditionals, not UA string, for robustness)\n    // Note that, since IE 10 does not support conditional comments, the following logic only detects IE < 10.\n    // Currently this is by design, since IE 10+ behaves correctly when treated as a standard browser.\n    // If there is a future need to detect specific versions of IE10+, we will amend this.\n    var ieVersion = document && (function() {\n        var version = 3, div = document.createElement('div'), iElems = div.getElementsByTagName('i');\n\n        // Keep constructing conditional HTML blocks until we hit one that resolves to an empty fragment\n        while (\n            div.innerHTML = '<!--[if gt IE ' + (++version) + ']><i></i><![endif]-->',\n            iElems[0]\n        ) {}\n        return version > 4 ? version : undefined;\n    }());\n    var isIe6 = ieVersion === 6,\n        isIe7 = ieVersion === 7;\n\n    function isClickOnCheckableElement(element, eventType) {\n        if ((ko.utils.tagNameLower(element) !== \"input\") || !element.type) return false;\n        if (eventType.toLowerCase() != \"click\") return false;\n        var inputType = element.type;\n        return (inputType == \"checkbox\") || (inputType == \"radio\");\n    }\n\n    // For details on the pattern for changing node classes\n    // see: https://github.com/knockout/knockout/issues/1597\n    var cssClassNameRegex = /\\S+/g;\n\n    function toggleDomNodeCssClass(node, classNames, shouldHaveClass) {\n        var addOrRemoveFn;\n        if (classNames) {\n            if (typeof node.classList === 'object') {\n                addOrRemoveFn = node.classList[shouldHaveClass ? 'add' : 'remove'];\n                ko.utils.arrayForEach(classNames.match(cssClassNameRegex), function(className) {\n                    addOrRemoveFn.call(node.classList, className);\n                });\n            } else if (typeof node.className['baseVal'] === 'string') {\n                // SVG tag .classNames is an SVGAnimatedString instance\n                toggleObjectClassPropertyString(node.className, 'baseVal', classNames, shouldHaveClass);\n            } else {\n                // node.className ought to be a string.\n                toggleObjectClassPropertyString(node, 'className', classNames, shouldHaveClass);\n            }\n        }\n    }\n\n    function toggleObjectClassPropertyString(obj, prop, classNames, shouldHaveClass) {\n        // obj/prop is either a node/'className' or a SVGAnimatedString/'baseVal'.\n        var currentClassNames = obj[prop].match(cssClassNameRegex) || [];\n        ko.utils.arrayForEach(classNames.match(cssClassNameRegex), function(className) {\n            ko.utils.addOrRemoveItem(currentClassNames, className, shouldHaveClass);\n        });\n        obj[prop] = currentClassNames.join(\" \");\n    }\n\n    return {\n        fieldsIncludedWithJsonPost: ['authenticity_token', /^__RequestVerificationToken(_.*)?$/],\n\n        arrayForEach: function (array, action) {\n            for (var i = 0, j = array.length; i < j; i++)\n                action(array[i], i);\n        },\n\n        arrayIndexOf: function (array, item) {\n            if (typeof Array.prototype.indexOf == \"function\")\n                return Array.prototype.indexOf.call(array, item);\n            for (var i = 0, j = array.length; i < j; i++)\n                if (array[i] === item)\n                    return i;\n            return -1;\n        },\n\n        arrayFirst: function (array, predicate, predicateOwner) {\n            for (var i = 0, j = array.length; i < j; i++)\n                if (predicate.call(predicateOwner, array[i], i))\n                    return array[i];\n            return null;\n        },\n\n        arrayRemoveItem: function (array, itemToRemove) {\n            var index = ko.utils.arrayIndexOf(array, itemToRemove);\n            if (index > 0) {\n                array.splice(index, 1);\n            }\n            else if (index === 0) {\n                array.shift();\n            }\n        },\n\n        arrayGetDistinctValues: function (array) {\n            array = array || [];\n            var result = [];\n            for (var i = 0, j = array.length; i < j; i++) {\n                if (ko.utils.arrayIndexOf(result, array[i]) < 0)\n                    result.push(array[i]);\n            }\n            return result;\n        },\n\n        arrayMap: function (array, mapping) {\n            array = array || [];\n            var result = [];\n            for (var i = 0, j = array.length; i < j; i++)\n                result.push(mapping(array[i], i));\n            return result;\n        },\n\n        arrayFilter: function (array, predicate) {\n            array = array || [];\n            var result = [];\n            for (var i = 0, j = array.length; i < j; i++)\n                if (predicate(array[i], i))\n                    result.push(array[i]);\n            return result;\n        },\n\n        arrayPushAll: function (array, valuesToPush) {\n            if (valuesToPush instanceof Array)\n                array.push.apply(array, valuesToPush);\n            else\n                for (var i = 0, j = valuesToPush.length; i < j; i++)\n                    array.push(valuesToPush[i]);\n            return array;\n        },\n\n        addOrRemoveItem: function(array, value, included) {\n            var existingEntryIndex = ko.utils.arrayIndexOf(ko.utils.peekObservable(array), value);\n            if (existingEntryIndex < 0) {\n                if (included)\n                    array.push(value);\n            } else {\n                if (!included)\n                    array.splice(existingEntryIndex, 1);\n            }\n        },\n\n        canSetPrototype: canSetPrototype,\n\n        extend: extend,\n\n        setPrototypeOf: setPrototypeOf,\n\n        setPrototypeOfOrExtend: canSetPrototype ? setPrototypeOf : extend,\n\n        objectForEach: objectForEach,\n\n        objectMap: function(source, mapping) {\n            if (!source)\n                return source;\n            var target = {};\n            for (var prop in source) {\n                if (source.hasOwnProperty(prop)) {\n                    target[prop] = mapping(source[prop], prop, source);\n                }\n            }\n            return target;\n        },\n\n        emptyDomNode: function (domNode) {\n            while (domNode.firstChild) {\n                ko.removeNode(domNode.firstChild);\n            }\n        },\n\n        moveCleanedNodesToContainerElement: function(nodes) {\n            // Ensure it's a real array, as we're about to reparent the nodes and\n            // we don't want the underlying collection to change while we're doing that.\n            var nodesArray = ko.utils.makeArray(nodes);\n            var templateDocument = (nodesArray[0] && nodesArray[0].ownerDocument) || document;\n\n            var container = templateDocument.createElement('div');\n            for (var i = 0, j = nodesArray.length; i < j; i++) {\n                container.appendChild(ko.cleanNode(nodesArray[i]));\n            }\n            return container;\n        },\n\n        cloneNodes: function (nodesArray, shouldCleanNodes) {\n            for (var i = 0, j = nodesArray.length, newNodesArray = []; i < j; i++) {\n                var clonedNode = nodesArray[i].cloneNode(true);\n                newNodesArray.push(shouldCleanNodes ? ko.cleanNode(clonedNode) : clonedNode);\n            }\n            return newNodesArray;\n        },\n\n        setDomNodeChildren: function (domNode, childNodes) {\n            ko.utils.emptyDomNode(domNode);\n            if (childNodes) {\n                for (var i = 0, j = childNodes.length; i < j; i++)\n                    domNode.appendChild(childNodes[i]);\n            }\n        },\n\n        replaceDomNodes: function (nodeToReplaceOrNodeArray, newNodesArray) {\n            var nodesToReplaceArray = nodeToReplaceOrNodeArray.nodeType ? [nodeToReplaceOrNodeArray] : nodeToReplaceOrNodeArray;\n            if (nodesToReplaceArray.length > 0) {\n                var insertionPoint = nodesToReplaceArray[0];\n                var parent = insertionPoint.parentNode;\n                for (var i = 0, j = newNodesArray.length; i < j; i++)\n                    parent.insertBefore(newNodesArray[i], insertionPoint);\n                for (var i = 0, j = nodesToReplaceArray.length; i < j; i++) {\n                    ko.removeNode(nodesToReplaceArray[i]);\n                }\n            }\n        },\n\n        fixUpContinuousNodeArray: function(continuousNodeArray, parentNode) {\n            // Before acting on a set of nodes that were previously outputted by a template function, we have to reconcile\n            // them against what is in the DOM right now. It may be that some of the nodes have already been removed, or that\n            // new nodes might have been inserted in the middle, for example by a binding. Also, there may previously have been\n            // leading comment nodes (created by rewritten string-based templates) that have since been removed during binding.\n            // So, this function translates the old \"map\" output array into its best guess of the set of current DOM nodes.\n            //\n            // Rules:\n            //   [A] Any leading nodes that have been removed should be ignored\n            //       These most likely correspond to memoization nodes that were already removed during binding\n            //       See https://github.com/knockout/knockout/pull/440\n            //   [B] Any trailing nodes that have been remove should be ignored\n            //       This prevents the code here from adding unrelated nodes to the array while processing rule [C]\n            //       See https://github.com/knockout/knockout/pull/1903\n            //   [C] We want to output a continuous series of nodes. So, ignore any nodes that have already been removed,\n            //       and include any nodes that have been inserted among the previous collection\n\n            if (continuousNodeArray.length) {\n                // The parent node can be a virtual element; so get the real parent node\n                parentNode = (parentNode.nodeType === 8 && parentNode.parentNode) || parentNode;\n\n                // Rule [A]\n                while (continuousNodeArray.length && continuousNodeArray[0].parentNode !== parentNode)\n                    continuousNodeArray.splice(0, 1);\n\n                // Rule [B]\n                while (continuousNodeArray.length > 1 && continuousNodeArray[continuousNodeArray.length - 1].parentNode !== parentNode)\n                    continuousNodeArray.length--;\n\n                // Rule [C]\n                if (continuousNodeArray.length > 1) {\n                    var current = continuousNodeArray[0], last = continuousNodeArray[continuousNodeArray.length - 1];\n                    // Replace with the actual new continuous node set\n                    continuousNodeArray.length = 0;\n                    while (current !== last) {\n                        continuousNodeArray.push(current);\n                        current = current.nextSibling;\n                    }\n                    continuousNodeArray.push(last);\n                }\n            }\n            return continuousNodeArray;\n        },\n\n        setOptionNodeSelectionState: function (optionNode, isSelected) {\n            // IE6 sometimes throws \"unknown error\" if you try to write to .selected directly, whereas Firefox struggles with setAttribute. Pick one based on browser.\n            if (ieVersion < 7)\n                optionNode.setAttribute(\"selected\", isSelected);\n            else\n                optionNode.selected = isSelected;\n        },\n\n        stringTrim: function (string) {\n            return string === null || string === undefined ? '' :\n                string.trim ?\n                    string.trim() :\n                    string.toString().replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g, '');\n        },\n\n        stringStartsWith: function (string, startsWith) {\n            string = string || \"\";\n            if (startsWith.length > string.length)\n                return false;\n            return string.substring(0, startsWith.length) === startsWith;\n        },\n\n        domNodeIsContainedBy: function (node, containedByNode) {\n            if (node === containedByNode)\n                return true;\n            if (node.nodeType === 11)\n                return false; // Fixes issue #1162 - can't use node.contains for document fragments on IE8\n            if (containedByNode.contains)\n                return containedByNode.contains(node.nodeType === 3 ? node.parentNode : node);\n            if (containedByNode.compareDocumentPosition)\n                return (containedByNode.compareDocumentPosition(node) & 16) == 16;\n            while (node && node != containedByNode) {\n                node = node.parentNode;\n            }\n            return !!node;\n        },\n\n        domNodeIsAttachedToDocument: function (node) {\n            return ko.utils.domNodeIsContainedBy(node, node.ownerDocument.documentElement);\n        },\n\n        anyDomNodeIsAttachedToDocument: function(nodes) {\n            return !!ko.utils.arrayFirst(nodes, ko.utils.domNodeIsAttachedToDocument);\n        },\n\n        tagNameLower: function(element) {\n            // For HTML elements, tagName will always be upper case; for XHTML elements, it'll be lower case.\n            // Possible future optimization: If we know it's an element from an XHTML document (not HTML),\n            // we don't need to do the .toLowerCase() as it will always be lower case anyway.\n            return element && element.tagName && element.tagName.toLowerCase();\n        },\n\n        catchFunctionErrors: function (delegate) {\n            return ko['onError'] ? function () {\n                try {\n                    return delegate.apply(this, arguments);\n                } catch (e) {\n                    ko['onError'] && ko['onError'](e);\n                    throw e;\n                }\n            } : delegate;\n        },\n\n        setTimeout: function (handler, timeout) {\n            return setTimeout(ko.utils.catchFunctionErrors(handler), timeout);\n        },\n\n        deferError: function (error) {\n            setTimeout(function () {\n                ko['onError'] && ko['onError'](error);\n                throw error;\n            }, 0);\n        },\n\n        registerEventHandler: function (element, eventType, handler) {\n            var wrappedHandler = ko.utils.catchFunctionErrors(handler);\n\n            var mustUseAttachEvent = ieVersion && eventsThatMustBeRegisteredUsingAttachEvent[eventType];\n            if (!ko.options['useOnlyNativeEvents'] && !mustUseAttachEvent && jQueryInstance) {\n                jQueryInstance(element)['bind'](eventType, wrappedHandler);\n            } else if (!mustUseAttachEvent && typeof element.addEventListener == \"function\")\n                element.addEventListener(eventType, wrappedHandler, false);\n            else if (typeof element.attachEvent != \"undefined\") {\n                var attachEventHandler = function (event) { wrappedHandler.call(element, event); },\n                    attachEventName = \"on\" + eventType;\n                element.attachEvent(attachEventName, attachEventHandler);\n\n                // IE does not dispose attachEvent handlers automatically (unlike with addEventListener)\n                // so to avoid leaks, we have to remove them manually. See bug #856\n                ko.utils.domNodeDisposal.addDisposeCallback(element, function() {\n                    element.detachEvent(attachEventName, attachEventHandler);\n                });\n            } else\n                throw new Error(\"Browser doesn't support addEventListener or attachEvent\");\n        },\n\n        triggerEvent: function (element, eventType) {\n            if (!(element && element.nodeType))\n                throw new Error(\"element must be a DOM node when calling triggerEvent\");\n\n            // For click events on checkboxes and radio buttons, jQuery toggles the element checked state *after* the\n            // event handler runs instead of *before*. (This was fixed in 1.9 for checkboxes but not for radio buttons.)\n            // IE doesn't change the checked state when you trigger the click event using \"fireEvent\".\n            // In both cases, we'll use the click method instead.\n            var useClickWorkaround = isClickOnCheckableElement(element, eventType);\n\n            if (!ko.options['useOnlyNativeEvents'] && jQueryInstance && !useClickWorkaround) {\n                jQueryInstance(element)['trigger'](eventType);\n            } else if (typeof document.createEvent == \"function\") {\n                if (typeof element.dispatchEvent == \"function\") {\n                    var eventCategory = knownEventTypesByEventName[eventType] || \"HTMLEvents\";\n                    var event = document.createEvent(eventCategory);\n                    event.initEvent(eventType, true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, element);\n                    element.dispatchEvent(event);\n                }\n                else\n                    throw new Error(\"The supplied element doesn't support dispatchEvent\");\n            } else if (useClickWorkaround && element.click) {\n                element.click();\n            } else if (typeof element.fireEvent != \"undefined\") {\n                element.fireEvent(\"on\" + eventType);\n            } else {\n                throw new Error(\"Browser doesn't support triggering events\");\n            }\n        },\n\n        unwrapObservable: function (value) {\n            return ko.isObservable(value) ? value() : value;\n        },\n\n        peekObservable: function (value) {\n            return ko.isObservable(value) ? value.peek() : value;\n        },\n\n        toggleDomNodeCssClass: toggleDomNodeCssClass,\n\n        setTextContent: function(element, textContent) {\n            var value = ko.utils.unwrapObservable(textContent);\n            if ((value === null) || (value === undefined))\n                value = \"\";\n\n            // We need there to be exactly one child: a text node.\n            // If there are no children, more than one, or if it's not a text node,\n            // we'll clear everything and create a single text node.\n            var innerTextNode = ko.virtualElements.firstChild(element);\n            if (!innerTextNode || innerTextNode.nodeType != 3 || ko.virtualElements.nextSibling(innerTextNode)) {\n                ko.virtualElements.setDomNodeChildren(element, [element.ownerDocument.createTextNode(value)]);\n            } else {\n                innerTextNode.data = value;\n            }\n\n            ko.utils.forceRefresh(element);\n        },\n\n        setElementName: function(element, name) {\n            element.name = name;\n        },\n\n        forceRefresh: function(node) {\n            // Workaround for an IE9 rendering bug - https://github.com/SteveSanderson/knockout/issues/209\n            if (ieVersion >= 9) {\n                // For text nodes and comment nodes (most likely virtual elements), we will have to refresh the container\n                var elem = node.nodeType == 1 ? node : node.parentNode;\n                if (elem.style)\n                    elem.style.zoom = elem.style.zoom;\n            }\n        },\n\n        ensureSelectElementIsRenderedCorrectly: function(selectElement) {\n            // Workaround for IE9 rendering bug - it doesn't reliably display all the text in dynamically-added select boxes unless you force it to re-render by updating the width.\n            // (See https://github.com/SteveSanderson/knockout/issues/312, http://stackoverflow.com/questions/5908494/select-only-shows-first-char-of-selected-option)\n            // Also fixes IE7 and IE8 bug that causes selects to be zero width if enclosed by 'if' or 'with'. (See issue #839)\n            if (ieVersion) {\n                var originalWidth = selectElement.style.width;\n                selectElement.style.width = 0;\n                selectElement.style.width = originalWidth;\n            }\n        },\n\n        range: function (min, max) {\n            min = ko.utils.unwrapObservable(min);\n            max = ko.utils.unwrapObservable(max);\n            var result = [];\n            for (var i = min; i <= max; i++)\n                result.push(i);\n            return result;\n        },\n\n        makeArray: function(arrayLikeObject) {\n            var result = [];\n            for (var i = 0, j = arrayLikeObject.length; i < j; i++) {\n                result.push(arrayLikeObject[i]);\n            };\n            return result;\n        },\n\n        createSymbolOrString: function(identifier) {\n            return canUseSymbols ? Symbol(identifier) : identifier;\n        },\n\n        isIe6 : isIe6,\n        isIe7 : isIe7,\n        ieVersion : ieVersion,\n\n        getFormFields: function(form, fieldName) {\n            var fields = ko.utils.makeArray(form.getElementsByTagName(\"input\")).concat(ko.utils.makeArray(form.getElementsByTagName(\"textarea\")));\n            var isMatchingField = (typeof fieldName == 'string')\n                ? function(field) { return field.name === fieldName }\n                : function(field) { return fieldName.test(field.name) }; // Treat fieldName as regex or object containing predicate\n            var matches = [];\n            for (var i = fields.length - 1; i >= 0; i--) {\n                if (isMatchingField(fields[i]))\n                    matches.push(fields[i]);\n            };\n            return matches;\n        },\n\n        parseJson: function (jsonString) {\n            if (typeof jsonString == \"string\") {\n                jsonString = ko.utils.stringTrim(jsonString);\n                if (jsonString) {\n                    if (JSON && JSON.parse) // Use native parsing where available\n                        return JSON.parse(jsonString);\n                    return (new Function(\"return \" + jsonString))(); // Fallback on less safe parsing for older browsers\n                }\n            }\n            return null;\n        },\n\n        stringifyJson: function (data, replacer, space) {   // replacer and space are optional\n            if (!JSON || !JSON.stringify)\n                throw new Error(\"Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js\");\n            return JSON.stringify(ko.utils.unwrapObservable(data), replacer, space);\n        },\n\n        postJson: function (urlOrForm, data, options) {\n            options = options || {};\n            var params = options['params'] || {};\n            var includeFields = options['includeFields'] || this.fieldsIncludedWithJsonPost;\n            var url = urlOrForm;\n\n            // If we were given a form, use its 'action' URL and pick out any requested field values\n            if((typeof urlOrForm == 'object') && (ko.utils.tagNameLower(urlOrForm) === \"form\")) {\n                var originalForm = urlOrForm;\n                url = originalForm.action;\n                for (var i = includeFields.length - 1; i >= 0; i--) {\n                    var fields = ko.utils.getFormFields(originalForm, includeFields[i]);\n                    for (var j = fields.length - 1; j >= 0; j--)\n                        params[fields[j].name] = fields[j].value;\n                }\n            }\n\n            data = ko.utils.unwrapObservable(data);\n            var form = document.createElement(\"form\");\n            form.style.display = \"none\";\n            form.action = url;\n            form.method = \"post\";\n            for (var key in data) {\n                // Since 'data' this is a model object, we include all properties including those inherited from its prototype\n                var input = document.createElement(\"input\");\n                input.type = \"hidden\";\n                input.name = key;\n                input.value = ko.utils.stringifyJson(ko.utils.unwrapObservable(data[key]));\n                form.appendChild(input);\n            }\n            objectForEach(params, function(key, value) {\n                var input = document.createElement(\"input\");\n                input.type = \"hidden\";\n                input.name = key;\n                input.value = value;\n                form.appendChild(input);\n            });\n            document.body.appendChild(form);\n            options['submitter'] ? options['submitter'](form) : form.submit();\n            setTimeout(function () { form.parentNode.removeChild(form); }, 0);\n        }\n    }\n}());\n\nko.exportSymbol('utils', ko.utils);\nko.exportSymbol('utils.arrayForEach', ko.utils.arrayForEach);\nko.exportSymbol('utils.arrayFirst', ko.utils.arrayFirst);\nko.exportSymbol('utils.arrayFilter', ko.utils.arrayFilter);\nko.exportSymbol('utils.arrayGetDistinctValues', ko.utils.arrayGetDistinctValues);\nko.exportSymbol('utils.arrayIndexOf', ko.utils.arrayIndexOf);\nko.exportSymbol('utils.arrayMap', ko.utils.arrayMap);\nko.exportSymbol('utils.arrayPushAll', ko.utils.arrayPushAll);\nko.exportSymbol('utils.arrayRemoveItem', ko.utils.arrayRemoveItem);\nko.exportSymbol('utils.extend', ko.utils.extend);\nko.exportSymbol('utils.fieldsIncludedWithJsonPost', ko.utils.fieldsIncludedWithJsonPost);\nko.exportSymbol('utils.getFormFields', ko.utils.getFormFields);\nko.exportSymbol('utils.peekObservable', ko.utils.peekObservable);\nko.exportSymbol('utils.postJson', ko.utils.postJson);\nko.exportSymbol('utils.parseJson', ko.utils.parseJson);\nko.exportSymbol('utils.registerEventHandler', ko.utils.registerEventHandler);\nko.exportSymbol('utils.stringifyJson', ko.utils.stringifyJson);\nko.exportSymbol('utils.range', ko.utils.range);\nko.exportSymbol('utils.toggleDomNodeCssClass', ko.utils.toggleDomNodeCssClass);\nko.exportSymbol('utils.triggerEvent', ko.utils.triggerEvent);\nko.exportSymbol('utils.unwrapObservable', ko.utils.unwrapObservable);\nko.exportSymbol('utils.objectForEach', ko.utils.objectForEach);\nko.exportSymbol('utils.addOrRemoveItem', ko.utils.addOrRemoveItem);\nko.exportSymbol('utils.setTextContent', ko.utils.setTextContent);\nko.exportSymbol('unwrap', ko.utils.unwrapObservable); // Convenient shorthand, because this is used so commonly\n\nif (!Function.prototype['bind']) {\n    // Function.prototype.bind is a standard part of ECMAScript 5th Edition (December 2009, http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf)\n    // In case the browser doesn't implement it natively, provide a JavaScript implementation. This implementation is based on the one in prototype.js\n    Function.prototype['bind'] = function (object) {\n        var originalFunction = this;\n        if (arguments.length === 1) {\n            return function () {\n                return originalFunction.apply(object, arguments);\n            };\n        } else {\n            var partialArgs = Array.prototype.slice.call(arguments, 1);\n            return function () {\n                var args = partialArgs.slice(0);\n                args.push.apply(args, arguments);\n                return originalFunction.apply(object, args);\n            };\n        }\n    };\n}\n\nko.utils.domData = new (function () {\n    var uniqueId = 0;\n    var dataStoreKeyExpandoPropertyName = \"__ko__\" + (new Date).getTime();\n    var dataStore = {};\n\n    function getAll(node, createIfNotFound) {\n        var dataStoreKey = node[dataStoreKeyExpandoPropertyName];\n        var hasExistingDataStore = dataStoreKey && (dataStoreKey !== \"null\") && dataStore[dataStoreKey];\n        if (!hasExistingDataStore) {\n            if (!createIfNotFound)\n                return undefined;\n            dataStoreKey = node[dataStoreKeyExpandoPropertyName] = \"ko\" + uniqueId++;\n            dataStore[dataStoreKey] = {};\n        }\n        return dataStore[dataStoreKey];\n    }\n\n    return {\n        get: function (node, key) {\n            var allDataForNode = getAll(node, false);\n            return allDataForNode === undefined ? undefined : allDataForNode[key];\n        },\n        set: function (node, key, value) {\n            if (value === undefined) {\n                // Make sure we don't actually create a new domData key if we are actually deleting a value\n                if (getAll(node, false) === undefined)\n                    return;\n            }\n            var allDataForNode = getAll(node, true);\n            allDataForNode[key] = value;\n        },\n        clear: function (node) {\n            var dataStoreKey = node[dataStoreKeyExpandoPropertyName];\n            if (dataStoreKey) {\n                delete dataStore[dataStoreKey];\n                node[dataStoreKeyExpandoPropertyName] = null;\n                return true; // Exposing \"did clean\" flag purely so specs can infer whether things have been cleaned up as intended\n            }\n            return false;\n        },\n\n        nextKey: function () {\n            return (uniqueId++) + dataStoreKeyExpandoPropertyName;\n        }\n    };\n})();\n\nko.exportSymbol('utils.domData', ko.utils.domData);\nko.exportSymbol('utils.domData.clear', ko.utils.domData.clear); // Exporting only so specs can clear up after themselves fully\n\nko.utils.domNodeDisposal = new (function () {\n    var domDataKey = ko.utils.domData.nextKey();\n    var cleanableNodeTypes = { 1: true, 8: true, 9: true };       // Element, Comment, Document\n    var cleanableNodeTypesWithDescendants = { 1: true, 9: true }; // Element, Document\n\n    function getDisposeCallbacksCollection(node, createIfNotFound) {\n        var allDisposeCallbacks = ko.utils.domData.get(node, domDataKey);\n        if ((allDisposeCallbacks === undefined) && createIfNotFound) {\n            allDisposeCallbacks = [];\n            ko.utils.domData.set(node, domDataKey, allDisposeCallbacks);\n        }\n        return allDisposeCallbacks;\n    }\n    function destroyCallbacksCollection(node) {\n        ko.utils.domData.set(node, domDataKey, undefined);\n    }\n\n    function cleanSingleNode(node) {\n        // Run all the dispose callbacks\n        var callbacks = getDisposeCallbacksCollection(node, false);\n        if (callbacks) {\n            callbacks = callbacks.slice(0); // Clone, as the array may be modified during iteration (typically, callbacks will remove themselves)\n            for (var i = 0; i < callbacks.length; i++)\n                callbacks[i](node);\n        }\n\n        // Erase the DOM data\n        ko.utils.domData.clear(node);\n\n        // Perform cleanup needed by external libraries (currently only jQuery, but can be extended)\n        ko.utils.domNodeDisposal[\"cleanExternalData\"](node);\n\n        // Clear any immediate-child comment nodes, as these wouldn't have been found by\n        // node.getElementsByTagName(\"*\") in cleanNode() (comment nodes aren't elements)\n        if (cleanableNodeTypesWithDescendants[node.nodeType])\n            cleanImmediateCommentTypeChildren(node);\n    }\n\n    function cleanImmediateCommentTypeChildren(nodeWithChildren) {\n        var child, nextChild = nodeWithChildren.firstChild;\n        while (child = nextChild) {\n            nextChild = child.nextSibling;\n            if (child.nodeType === 8)\n                cleanSingleNode(child);\n        }\n    }\n\n    return {\n        addDisposeCallback : function(node, callback) {\n            if (typeof callback != \"function\")\n                throw new Error(\"Callback must be a function\");\n            getDisposeCallbacksCollection(node, true).push(callback);\n        },\n\n        removeDisposeCallback : function(node, callback) {\n            var callbacksCollection = getDisposeCallbacksCollection(node, false);\n            if (callbacksCollection) {\n                ko.utils.arrayRemoveItem(callbacksCollection, callback);\n                if (callbacksCollection.length == 0)\n                    destroyCallbacksCollection(node);\n            }\n        },\n\n        cleanNode : function(node) {\n            // First clean this node, where applicable\n            if (cleanableNodeTypes[node.nodeType]) {\n                cleanSingleNode(node);\n\n                // ... then its descendants, where applicable\n                if (cleanableNodeTypesWithDescendants[node.nodeType]) {\n                    // Clone the descendants list in case it changes during iteration\n                    var descendants = [];\n                    ko.utils.arrayPushAll(descendants, node.getElementsByTagName(\"*\"));\n                    for (var i = 0, j = descendants.length; i < j; i++)\n                        cleanSingleNode(descendants[i]);\n                }\n            }\n            return node;\n        },\n\n        removeNode : function(node) {\n            ko.cleanNode(node);\n            if (node.parentNode)\n                node.parentNode.removeChild(node);\n        },\n\n        \"cleanExternalData\" : function (node) {\n            // Special support for jQuery here because it's so commonly used.\n            // Many jQuery plugins (including jquery.tmpl) store data using jQuery's equivalent of domData\n            // so notify it to tear down any resources associated with the node & descendants here.\n            if (jQueryInstance && (typeof jQueryInstance['cleanData'] == \"function\"))\n                jQueryInstance['cleanData']([node]);\n        }\n    };\n})();\nko.cleanNode = ko.utils.domNodeDisposal.cleanNode; // Shorthand name for convenience\nko.removeNode = ko.utils.domNodeDisposal.removeNode; // Shorthand name for convenience\nko.exportSymbol('cleanNode', ko.cleanNode);\nko.exportSymbol('removeNode', ko.removeNode);\nko.exportSymbol('utils.domNodeDisposal', ko.utils.domNodeDisposal);\nko.exportSymbol('utils.domNodeDisposal.addDisposeCallback', ko.utils.domNodeDisposal.addDisposeCallback);\nko.exportSymbol('utils.domNodeDisposal.removeDisposeCallback', ko.utils.domNodeDisposal.removeDisposeCallback);\n(function () {\n    var none = [0, \"\", \"\"],\n        table = [1, \"<table>\", \"</table>\"],\n        tbody = [2, \"<table><tbody>\", \"</tbody></table>\"],\n        tr = [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n        select = [1, \"<select multiple='multiple'>\", \"</select>\"],\n        lookup = {\n            'thead': table,\n            'tbody': table,\n            'tfoot': table,\n            'tr': tbody,\n            'td': tr,\n            'th': tr,\n            'option': select,\n            'optgroup': select\n        },\n\n        // This is needed for old IE if you're *not* using either jQuery or innerShiv. Doesn't affect other cases.\n        mayRequireCreateElementHack = ko.utils.ieVersion <= 8;\n\n    function getWrap(tags) {\n        var m = tags.match(/^<([a-z]+)[ >]/);\n        return (m && lookup[m[1]]) || none;\n    }\n\n    function simpleHtmlParse(html, documentContext) {\n        documentContext || (documentContext = document);\n        var windowContext = documentContext['parentWindow'] || documentContext['defaultView'] || window;\n\n        // Based on jQuery's \"clean\" function, but only accounting for table-related elements.\n        // If you have referenced jQuery, this won't be used anyway - KO will use jQuery's \"clean\" function directly\n\n        // Note that there's still an issue in IE < 9 whereby it will discard comment nodes that are the first child of\n        // a descendant node. For example: \"<div><!-- mycomment -->abc</div>\" will get parsed as \"<div>abc</div>\"\n        // This won't affect anyone who has referenced jQuery, and there's always the workaround of inserting a dummy node\n        // (possibly a text node) in front of the comment. So, KO does not attempt to workaround this IE issue automatically at present.\n\n        // Trim whitespace, otherwise indexOf won't work as expected\n        var tags = ko.utils.stringTrim(html).toLowerCase(), div = documentContext.createElement(\"div\"),\n            wrap = getWrap(tags),\n            depth = wrap[0];\n\n        // Go to html and back, then peel off extra wrappers\n        // Note that we always prefix with some dummy text, because otherwise, IE<9 will strip out leading comment nodes in descendants. Total madness.\n        var markup = \"ignored<div>\" + wrap[1] + html + wrap[2] + \"</div>\";\n        if (typeof windowContext['innerShiv'] == \"function\") {\n            // Note that innerShiv is deprecated in favour of html5shiv. We should consider adding\n            // support for html5shiv (except if no explicit support is needed, e.g., if html5shiv\n            // somehow shims the native APIs so it just works anyway)\n            div.appendChild(windowContext['innerShiv'](markup));\n        } else {\n            if (mayRequireCreateElementHack) {\n                // The document.createElement('my-element') trick to enable custom elements in IE6-8\n                // only works if we assign innerHTML on an element associated with that document.\n                documentContext.appendChild(div);\n            }\n\n            div.innerHTML = markup;\n\n            if (mayRequireCreateElementHack) {\n                div.parentNode.removeChild(div);\n            }\n        }\n\n        // Move to the right depth\n        while (depth--)\n            div = div.lastChild;\n\n        return ko.utils.makeArray(div.lastChild.childNodes);\n    }\n\n    function jQueryHtmlParse(html, documentContext) {\n        // jQuery's \"parseHTML\" function was introduced in jQuery 1.8.0 and is a documented public API.\n        if (jQueryInstance['parseHTML']) {\n            return jQueryInstance['parseHTML'](html, documentContext) || []; // Ensure we always return an array and never null\n        } else {\n            // For jQuery < 1.8.0, we fall back on the undocumented internal \"clean\" function.\n            var elems = jQueryInstance['clean']([html], documentContext);\n\n            // As of jQuery 1.7.1, jQuery parses the HTML by appending it to some dummy parent nodes held in an in-memory document fragment.\n            // Unfortunately, it never clears the dummy parent nodes from the document fragment, so it leaks memory over time.\n            // Fix this by finding the top-most dummy parent element, and detaching it from its owner fragment.\n            if (elems && elems[0]) {\n                // Find the top-most parent element that's a direct child of a document fragment\n                var elem = elems[0];\n                while (elem.parentNode && elem.parentNode.nodeType !== 11 /* i.e., DocumentFragment */)\n                    elem = elem.parentNode;\n                // ... then detach it\n                if (elem.parentNode)\n                    elem.parentNode.removeChild(elem);\n            }\n\n            return elems;\n        }\n    }\n\n    ko.utils.parseHtmlFragment = function(html, documentContext) {\n        return jQueryInstance ?\n            jQueryHtmlParse(html, documentContext) :   // As below, benefit from jQuery's optimisations where possible\n            simpleHtmlParse(html, documentContext);  // ... otherwise, this simple logic will do in most common cases.\n    };\n\n    ko.utils.setHtml = function(node, html) {\n        ko.utils.emptyDomNode(node);\n\n        // There's no legitimate reason to display a stringified observable without unwrapping it, so we'll unwrap it\n        html = ko.utils.unwrapObservable(html);\n\n        if ((html !== null) && (html !== undefined)) {\n            if (typeof html != 'string')\n                html = html.toString();\n\n            // jQuery contains a lot of sophisticated code to parse arbitrary HTML fragments,\n            // for example <tr> elements which are not normally allowed to exist on their own.\n            // If you've referenced jQuery we'll use that rather than duplicating its code.\n            if (jQueryInstance) {\n                jQueryInstance(node)['html'](html);\n            } else {\n                // ... otherwise, use KO's own parsing logic.\n                var parsedNodes = ko.utils.parseHtmlFragment(html, node.ownerDocument);\n                for (var i = 0; i < parsedNodes.length; i++)\n                    node.appendChild(parsedNodes[i]);\n            }\n        }\n    };\n})();\n\nko.exportSymbol('utils.parseHtmlFragment', ko.utils.parseHtmlFragment);\nko.exportSymbol('utils.setHtml', ko.utils.setHtml);\n\nko.memoization = (function () {\n    var memos = {};\n\n    function randomMax8HexChars() {\n        return (((1 + Math.random()) * 0x100000000) | 0).toString(16).substring(1);\n    }\n    function generateRandomId() {\n        return randomMax8HexChars() + randomMax8HexChars();\n    }\n    function findMemoNodes(rootNode, appendToArray) {\n        if (!rootNode)\n            return;\n        if (rootNode.nodeType == 8) {\n            var memoId = ko.memoization.parseMemoText(rootNode.nodeValue);\n            if (memoId != null)\n                appendToArray.push({ domNode: rootNode, memoId: memoId });\n        } else if (rootNode.nodeType == 1) {\n            for (var i = 0, childNodes = rootNode.childNodes, j = childNodes.length; i < j; i++)\n                findMemoNodes(childNodes[i], appendToArray);\n        }\n    }\n\n    return {\n        memoize: function (callback) {\n            if (typeof callback != \"function\")\n                throw new Error(\"You can only pass a function to ko.memoization.memoize()\");\n            var memoId = generateRandomId();\n            memos[memoId] = callback;\n            return \"<!--[ko_memo:\" + memoId + \"]-->\";\n        },\n\n        unmemoize: function (memoId, callbackParams) {\n            var callback = memos[memoId];\n            if (callback === undefined)\n                throw new Error(\"Couldn't find any memo with ID \" + memoId + \". Perhaps it's already been unmemoized.\");\n            try {\n                callback.apply(null, callbackParams || []);\n                return true;\n            }\n            finally { delete memos[memoId]; }\n        },\n\n        unmemoizeDomNodeAndDescendants: function (domNode, extraCallbackParamsArray) {\n            var memos = [];\n            findMemoNodes(domNode, memos);\n            for (var i = 0, j = memos.length; i < j; i++) {\n                var node = memos[i].domNode;\n                var combinedParams = [node];\n                if (extraCallbackParamsArray)\n                    ko.utils.arrayPushAll(combinedParams, extraCallbackParamsArray);\n                ko.memoization.unmemoize(memos[i].memoId, combinedParams);\n                node.nodeValue = \"\"; // Neuter this node so we don't try to unmemoize it again\n                if (node.parentNode)\n                    node.parentNode.removeChild(node); // If possible, erase it totally (not always possible - someone else might just hold a reference to it then call unmemoizeDomNodeAndDescendants again)\n            }\n        },\n\n        parseMemoText: function (memoText) {\n            var match = memoText.match(/^\\[ko_memo\\:(.*?)\\]$/);\n            return match ? match[1] : null;\n        }\n    };\n})();\n\nko.exportSymbol('memoization', ko.memoization);\nko.exportSymbol('memoization.memoize', ko.memoization.memoize);\nko.exportSymbol('memoization.unmemoize', ko.memoization.unmemoize);\nko.exportSymbol('memoization.parseMemoText', ko.memoization.parseMemoText);\nko.exportSymbol('memoization.unmemoizeDomNodeAndDescendants', ko.memoization.unmemoizeDomNodeAndDescendants);\nko.tasks = (function () {\n    var scheduler,\n        taskQueue = [],\n        taskQueueLength = 0,\n        nextHandle = 1,\n        nextIndexToProcess = 0;\n\n    if (window['MutationObserver']) {\n        // Chrome 27+, Firefox 14+, IE 11+, Opera 15+, Safari 6.1+\n        // From https://github.com/petkaantonov/bluebird * Copyright (c) 2014 Petka Antonov * License: MIT\n        scheduler = (function (callback) {\n            var div = document.createElement(\"div\");\n            new MutationObserver(callback).observe(div, {attributes: true});\n            return function () { div.classList.toggle(\"foo\"); };\n        })(scheduledProcess);\n    } else if (document && \"onreadystatechange\" in document.createElement(\"script\")) {\n        // IE 6-10\n        // From https://github.com/YuzuJS/setImmediate * Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola * License: MIT\n        scheduler = function (callback) {\n            var script = document.createElement(\"script\");\n            script.onreadystatechange = function () {\n                script.onreadystatechange = null;\n                document.documentElement.removeChild(script);\n                script = null;\n                callback();\n            };\n            document.documentElement.appendChild(script);\n        };\n    } else {\n        scheduler = function (callback) {\n            setTimeout(callback, 0);\n        };\n    }\n\n    function processTasks() {\n        if (taskQueueLength) {\n            // Each mark represents the end of a logical group of tasks and the number of these groups is\n            // limited to prevent unchecked recursion.\n            var mark = taskQueueLength, countMarks = 0;\n\n            // nextIndexToProcess keeps track of where we are in the queue; processTasks can be called recursively without issue\n            for (var task; nextIndexToProcess < taskQueueLength; ) {\n                if (task = taskQueue[nextIndexToProcess++]) {\n                    if (nextIndexToProcess > mark) {\n                        if (++countMarks >= 5000) {\n                            nextIndexToProcess = taskQueueLength;   // skip all tasks remaining in the queue since any of them could be causing the recursion\n                            ko.utils.deferError(Error(\"'Too much recursion' after processing \" + countMarks + \" task groups.\"));\n                            break;\n                        }\n                        mark = taskQueueLength;\n                    }\n                    try {\n                        task();\n                    } catch (ex) {\n                        ko.utils.deferError(ex);\n                    }\n                }\n            }\n        }\n    }\n\n    function scheduledProcess() {\n        processTasks();\n\n        // Reset the queue\n        nextIndexToProcess = taskQueueLength = taskQueue.length = 0;\n    }\n\n    function scheduleTaskProcessing() {\n        ko.tasks['scheduler'](scheduledProcess);\n    }\n\n    var tasks = {\n        'scheduler': scheduler,     // Allow overriding the scheduler\n\n        schedule: function (func) {\n            if (!taskQueueLength) {\n                scheduleTaskProcessing();\n            }\n\n            taskQueue[taskQueueLength++] = func;\n            return nextHandle++;\n        },\n\n        cancel: function (handle) {\n            var index = handle - (nextHandle - taskQueueLength);\n            if (index >= nextIndexToProcess && index < taskQueueLength) {\n                taskQueue[index] = null;\n            }\n        },\n\n        // For testing only: reset the queue and return the previous queue length\n        'resetForTesting': function () {\n            var length = taskQueueLength - nextIndexToProcess;\n            nextIndexToProcess = taskQueueLength = taskQueue.length = 0;\n            return length;\n        },\n\n        runEarly: processTasks\n    };\n\n    return tasks;\n})();\n\nko.exportSymbol('tasks', ko.tasks);\nko.exportSymbol('tasks.schedule', ko.tasks.schedule);\n//ko.exportSymbol('tasks.cancel', ko.tasks.cancel);  \"cancel\" isn't minified\nko.exportSymbol('tasks.runEarly', ko.tasks.runEarly);\nko.extenders = {\n    'throttle': function(target, timeout) {\n        // Throttling means two things:\n\n        // (1) For dependent observables, we throttle *evaluations* so that, no matter how fast its dependencies\n        //     notify updates, the target doesn't re-evaluate (and hence doesn't notify) faster than a certain rate\n        target['throttleEvaluation'] = timeout;\n\n        // (2) For writable targets (observables, or writable dependent observables), we throttle *writes*\n        //     so the target cannot change value synchronously or faster than a certain rate\n        var writeTimeoutInstance = null;\n        return ko.dependentObservable({\n            'read': target,\n            'write': function(value) {\n                clearTimeout(writeTimeoutInstance);\n                writeTimeoutInstance = ko.utils.setTimeout(function() {\n                    target(value);\n                }, timeout);\n            }\n        });\n    },\n\n    'rateLimit': function(target, options) {\n        var timeout, method, limitFunction;\n\n        if (typeof options == 'number') {\n            timeout = options;\n        } else {\n            timeout = options['timeout'];\n            method = options['method'];\n        }\n\n        // rateLimit supersedes deferred updates\n        target._deferUpdates = false;\n\n        limitFunction = method == 'notifyWhenChangesStop' ?  debounce : throttle;\n        target.limit(function(callback) {\n            return limitFunction(callback, timeout);\n        });\n    },\n\n    'deferred': function(target, options) {\n        if (options !== true) {\n            throw new Error('The \\'deferred\\' extender only accepts the value \\'true\\', because it is not supported to turn deferral off once enabled.')\n        }\n\n        if (!target._deferUpdates) {\n            target._deferUpdates = true;\n            target.limit(function (callback) {\n                var handle,\n                    ignoreUpdates = false;\n                return function () {\n                    if (!ignoreUpdates) {\n                        ko.tasks.cancel(handle);\n                        handle = ko.tasks.schedule(callback);\n\n                        try {\n                            ignoreUpdates = true;\n                            target['notifySubscribers'](undefined, 'dirty');\n                        } finally {\n                            ignoreUpdates = false;\n                        }\n                    }\n                };\n            });\n        }\n    },\n\n    'notify': function(target, notifyWhen) {\n        target[\"equalityComparer\"] = notifyWhen == \"always\" ?\n            null :  // null equalityComparer means to always notify\n            valuesArePrimitiveAndEqual;\n    }\n};\n\nvar primitiveTypes = { 'undefined':1, 'boolean':1, 'number':1, 'string':1 };\nfunction valuesArePrimitiveAndEqual(a, b) {\n    var oldValueIsPrimitive = (a === null) || (typeof(a) in primitiveTypes);\n    return oldValueIsPrimitive ? (a === b) : false;\n}\n\nfunction throttle(callback, timeout) {\n    var timeoutInstance;\n    return function () {\n        if (!timeoutInstance) {\n            timeoutInstance = ko.utils.setTimeout(function () {\n                timeoutInstance = undefined;\n                callback();\n            }, timeout);\n        }\n    };\n}\n\nfunction debounce(callback, timeout) {\n    var timeoutInstance;\n    return function () {\n        clearTimeout(timeoutInstance);\n        timeoutInstance = ko.utils.setTimeout(callback, timeout);\n    };\n}\n\nfunction applyExtenders(requestedExtenders) {\n    var target = this;\n    if (requestedExtenders) {\n        ko.utils.objectForEach(requestedExtenders, function(key, value) {\n            var extenderHandler = ko.extenders[key];\n            if (typeof extenderHandler == 'function') {\n                target = extenderHandler(target, value) || target;\n            }\n        });\n    }\n    return target;\n}\n\nko.exportSymbol('extenders', ko.extenders);\n\nko.subscription = function (target, callback, disposeCallback) {\n    this._target = target;\n    this.callback = callback;\n    this.disposeCallback = disposeCallback;\n    this.isDisposed = false;\n    ko.exportProperty(this, 'dispose', this.dispose);\n};\nko.subscription.prototype.dispose = function () {\n    this.isDisposed = true;\n    this.disposeCallback();\n};\n\nko.subscribable = function () {\n    ko.utils.setPrototypeOfOrExtend(this, ko_subscribable_fn);\n    ko_subscribable_fn.init(this);\n}\n\nvar defaultEvent = \"change\";\n\n// Moved out of \"limit\" to avoid the extra closure\nfunction limitNotifySubscribers(value, event) {\n    if (!event || event === defaultEvent) {\n        this._limitChange(value);\n    } else if (event === 'beforeChange') {\n        this._limitBeforeChange(value);\n    } else {\n        this._origNotifySubscribers(value, event);\n    }\n}\n\nvar ko_subscribable_fn = {\n    init: function(instance) {\n        instance._subscriptions = { \"change\": [] };\n        instance._versionNumber = 1;\n    },\n\n    subscribe: function (callback, callbackTarget, event) {\n        var self = this;\n\n        event = event || defaultEvent;\n        var boundCallback = callbackTarget ? callback.bind(callbackTarget) : callback;\n\n        var subscription = new ko.subscription(self, boundCallback, function () {\n            ko.utils.arrayRemoveItem(self._subscriptions[event], subscription);\n            if (self.afterSubscriptionRemove)\n                self.afterSubscriptionRemove(event);\n        });\n\n        if (self.beforeSubscriptionAdd)\n            self.beforeSubscriptionAdd(event);\n\n        if (!self._subscriptions[event])\n            self._subscriptions[event] = [];\n        self._subscriptions[event].push(subscription);\n\n        return subscription;\n    },\n\n    \"notifySubscribers\": function (valueToNotify, event) {\n        event = event || defaultEvent;\n        if (event === defaultEvent) {\n            this.updateVersion();\n        }\n        if (this.hasSubscriptionsForEvent(event)) {\n            var subs = event === defaultEvent && this._changeSubscriptions || this._subscriptions[event].slice(0);\n            try {\n                ko.dependencyDetection.begin(); // Begin suppressing dependency detection (by setting the top frame to undefined)\n                for (var i = 0, subscription; subscription = subs[i]; ++i) {\n                    // In case a subscription was disposed during the arrayForEach cycle, check\n                    // for isDisposed on each subscription before invoking its callback\n                    if (!subscription.isDisposed)\n                        subscription.callback(valueToNotify);\n                }\n            } finally {\n                ko.dependencyDetection.end(); // End suppressing dependency detection\n            }\n        }\n    },\n\n    getVersion: function () {\n        return this._versionNumber;\n    },\n\n    hasChanged: function (versionToCheck) {\n        return this.getVersion() !== versionToCheck;\n    },\n\n    updateVersion: function () {\n        ++this._versionNumber;\n    },\n\n    limit: function(limitFunction) {\n        var self = this, selfIsObservable = ko.isObservable(self),\n            ignoreBeforeChange, notifyNextChange, previousValue, pendingValue, beforeChange = 'beforeChange';\n\n        if (!self._origNotifySubscribers) {\n            self._origNotifySubscribers = self[\"notifySubscribers\"];\n            self[\"notifySubscribers\"] = limitNotifySubscribers;\n        }\n\n        var finish = limitFunction(function() {\n            self._notificationIsPending = false;\n\n            // If an observable provided a reference to itself, access it to get the latest value.\n            // This allows computed observables to delay calculating their value until needed.\n            if (selfIsObservable && pendingValue === self) {\n                pendingValue = self._evalIfChanged ? self._evalIfChanged() : self();\n            }\n            var shouldNotify = notifyNextChange || self.isDifferent(previousValue, pendingValue);\n\n            notifyNextChange = ignoreBeforeChange = false;\n\n            if (shouldNotify) {\n                self._origNotifySubscribers(previousValue = pendingValue);\n            }\n        });\n\n        self._limitChange = function(value) {\n            self._changeSubscriptions = self._subscriptions[defaultEvent].slice(0);\n            self._notificationIsPending = ignoreBeforeChange = true;\n            pendingValue = value;\n            finish();\n        };\n        self._limitBeforeChange = function(value) {\n            if (!ignoreBeforeChange) {\n                previousValue = value;\n                self._origNotifySubscribers(value, beforeChange);\n            }\n        };\n        self._notifyNextChangeIfValueIsDifferent = function() {\n            if (self.isDifferent(previousValue, self.peek(true /*evaluate*/))) {\n                notifyNextChange = true;\n            }\n        };\n    },\n\n    hasSubscriptionsForEvent: function(event) {\n        return this._subscriptions[event] && this._subscriptions[event].length;\n    },\n\n    getSubscriptionsCount: function (event) {\n        if (event) {\n            return this._subscriptions[event] && this._subscriptions[event].length || 0;\n        } else {\n            var total = 0;\n            ko.utils.objectForEach(this._subscriptions, function(eventName, subscriptions) {\n                if (eventName !== 'dirty')\n                    total += subscriptions.length;\n            });\n            return total;\n        }\n    },\n\n    isDifferent: function(oldValue, newValue) {\n        return !this['equalityComparer'] || !this['equalityComparer'](oldValue, newValue);\n    },\n\n    extend: applyExtenders\n};\n\nko.exportProperty(ko_subscribable_fn, 'subscribe', ko_subscribable_fn.subscribe);\nko.exportProperty(ko_subscribable_fn, 'extend', ko_subscribable_fn.extend);\nko.exportProperty(ko_subscribable_fn, 'getSubscriptionsCount', ko_subscribable_fn.getSubscriptionsCount);\n\n// For browsers that support proto assignment, we overwrite the prototype of each\n// observable instance. Since observables are functions, we need Function.prototype\n// to still be in the prototype chain.\nif (ko.utils.canSetPrototype) {\n    ko.utils.setPrototypeOf(ko_subscribable_fn, Function.prototype);\n}\n\nko.subscribable['fn'] = ko_subscribable_fn;\n\n\nko.isSubscribable = function (instance) {\n    return instance != null && typeof instance.subscribe == \"function\" && typeof instance[\"notifySubscribers\"] == \"function\";\n};\n\nko.exportSymbol('subscribable', ko.subscribable);\nko.exportSymbol('isSubscribable', ko.isSubscribable);\n\nko.computedContext = ko.dependencyDetection = (function () {\n    var outerFrames = [],\n        currentFrame,\n        lastId = 0;\n\n    // Return a unique ID that can be assigned to an observable for dependency tracking.\n    // Theoretically, you could eventually overflow the number storage size, resulting\n    // in duplicate IDs. But in JavaScript, the largest exact integral value is 2^53\n    // or 9,007,199,254,740,992. If you created 1,000,000 IDs per second, it would\n    // take over 285 years to reach that number.\n    // Reference http://blog.vjeux.com/2010/javascript/javascript-max_int-number-limits.html\n    function getId() {\n        return ++lastId;\n    }\n\n    function begin(options) {\n        outerFrames.push(currentFrame);\n        currentFrame = options;\n    }\n\n    function end() {\n        currentFrame = outerFrames.pop();\n    }\n\n    return {\n        begin: begin,\n\n        end: end,\n\n        registerDependency: function (subscribable) {\n            if (currentFrame) {\n                if (!ko.isSubscribable(subscribable))\n                    throw new Error(\"Only subscribable things can act as dependencies\");\n                currentFrame.callback.call(currentFrame.callbackTarget, subscribable, subscribable._id || (subscribable._id = getId()));\n            }\n        },\n\n        ignore: function (callback, callbackTarget, callbackArgs) {\n            try {\n                begin();\n                return callback.apply(callbackTarget, callbackArgs || []);\n            } finally {\n                end();\n            }\n        },\n\n        getDependenciesCount: function () {\n            if (currentFrame)\n                return currentFrame.computed.getDependenciesCount();\n        },\n\n        isInitial: function() {\n            if (currentFrame)\n                return currentFrame.isInitial;\n        }\n    };\n})();\n\nko.exportSymbol('computedContext', ko.computedContext);\nko.exportSymbol('computedContext.getDependenciesCount', ko.computedContext.getDependenciesCount);\nko.exportSymbol('computedContext.isInitial', ko.computedContext.isInitial);\n\nko.exportSymbol('ignoreDependencies', ko.ignoreDependencies = ko.dependencyDetection.ignore);\nvar observableLatestValue = ko.utils.createSymbolOrString('_latestValue');\n\nko.observable = function (initialValue) {\n    function observable() {\n        if (arguments.length > 0) {\n            // Write\n\n            // Ignore writes if the value hasn't changed\n            if (observable.isDifferent(observable[observableLatestValue], arguments[0])) {\n                observable.valueWillMutate();\n                observable[observableLatestValue] = arguments[0];\n                observable.valueHasMutated();\n            }\n            return this; // Permits chained assignments\n        }\n        else {\n            // Read\n            ko.dependencyDetection.registerDependency(observable); // The caller only needs to be notified of changes if they did a \"read\" operation\n            return observable[observableLatestValue];\n        }\n    }\n\n    observable[observableLatestValue] = initialValue;\n\n    // Inherit from 'subscribable'\n    if (!ko.utils.canSetPrototype) {\n        // 'subscribable' won't be on the prototype chain unless we put it there directly\n        ko.utils.extend(observable, ko.subscribable['fn']);\n    }\n    ko.subscribable['fn'].init(observable);\n\n    // Inherit from 'observable'\n    ko.utils.setPrototypeOfOrExtend(observable, observableFn);\n\n    if (ko.options['deferUpdates']) {\n        ko.extenders['deferred'](observable, true);\n    }\n\n    return observable;\n}\n\n// Define prototype for observables\nvar observableFn = {\n    'equalityComparer': valuesArePrimitiveAndEqual,\n    peek: function() { return this[observableLatestValue]; },\n    valueHasMutated: function () { this['notifySubscribers'](this[observableLatestValue]); },\n    valueWillMutate: function () { this['notifySubscribers'](this[observableLatestValue], 'beforeChange'); }\n};\n\n// Note that for browsers that don't support proto assignment, the\n// inheritance chain is created manually in the ko.observable constructor\nif (ko.utils.canSetPrototype) {\n    ko.utils.setPrototypeOf(observableFn, ko.subscribable['fn']);\n}\n\nvar protoProperty = ko.observable.protoProperty = '__ko_proto__';\nobservableFn[protoProperty] = ko.observable;\n\nko.hasPrototype = function(instance, prototype) {\n    if ((instance === null) || (instance === undefined) || (instance[protoProperty] === undefined)) return false;\n    if (instance[protoProperty] === prototype) return true;\n    return ko.hasPrototype(instance[protoProperty], prototype); // Walk the prototype chain\n};\n\nko.isObservable = function (instance) {\n    return ko.hasPrototype(instance, ko.observable);\n}\nko.isWriteableObservable = function (instance) {\n    // Observable\n    if ((typeof instance == 'function') && instance[protoProperty] === ko.observable)\n        return true;\n    // Writeable dependent observable\n    if ((typeof instance == 'function') && (instance[protoProperty] === ko.dependentObservable) && (instance.hasWriteFunction))\n        return true;\n    // Anything else\n    return false;\n}\n\nko.exportSymbol('observable', ko.observable);\nko.exportSymbol('isObservable', ko.isObservable);\nko.exportSymbol('isWriteableObservable', ko.isWriteableObservable);\nko.exportSymbol('isWritableObservable', ko.isWriteableObservable);\nko.exportSymbol('observable.fn', observableFn);\nko.exportProperty(observableFn, 'peek', observableFn.peek);\nko.exportProperty(observableFn, 'valueHasMutated', observableFn.valueHasMutated);\nko.exportProperty(observableFn, 'valueWillMutate', observableFn.valueWillMutate);\nko.observableArray = function (initialValues) {\n    initialValues = initialValues || [];\n\n    if (typeof initialValues != 'object' || !('length' in initialValues))\n        throw new Error(\"The argument passed when initializing an observable array must be an array, or null, or undefined.\");\n\n    var result = ko.observable(initialValues);\n    ko.utils.setPrototypeOfOrExtend(result, ko.observableArray['fn']);\n    return result.extend({'trackArrayChanges':true});\n};\n\nko.observableArray['fn'] = {\n    'remove': function (valueOrPredicate) {\n        var underlyingArray = this.peek();\n        var removedValues = [];\n        var predicate = typeof valueOrPredicate == \"function\" && !ko.isObservable(valueOrPredicate) ? valueOrPredicate : function (value) { return value === valueOrPredicate; };\n        for (var i = 0; i < underlyingArray.length; i++) {\n            var value = underlyingArray[i];\n            if (predicate(value)) {\n                if (removedValues.length === 0) {\n                    this.valueWillMutate();\n                }\n                removedValues.push(value);\n                underlyingArray.splice(i, 1);\n                i--;\n            }\n        }\n        if (removedValues.length) {\n            this.valueHasMutated();\n        }\n        return removedValues;\n    },\n\n    'removeAll': function (arrayOfValues) {\n        // If you passed zero args, we remove everything\n        if (arrayOfValues === undefined) {\n            var underlyingArray = this.peek();\n            var allValues = underlyingArray.slice(0);\n            this.valueWillMutate();\n            underlyingArray.splice(0, underlyingArray.length);\n            this.valueHasMutated();\n            return allValues;\n        }\n        // If you passed an arg, we interpret it as an array of entries to remove\n        if (!arrayOfValues)\n            return [];\n        return this['remove'](function (value) {\n            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;\n        });\n    },\n\n    'destroy': function (valueOrPredicate) {\n        var underlyingArray = this.peek();\n        var predicate = typeof valueOrPredicate == \"function\" && !ko.isObservable(valueOrPredicate) ? valueOrPredicate : function (value) { return value === valueOrPredicate; };\n        this.valueWillMutate();\n        for (var i = underlyingArray.length - 1; i >= 0; i--) {\n            var value = underlyingArray[i];\n            if (predicate(value))\n                underlyingArray[i][\"_destroy\"] = true;\n        }\n        this.valueHasMutated();\n    },\n\n    'destroyAll': function (arrayOfValues) {\n        // If you passed zero args, we destroy everything\n        if (arrayOfValues === undefined)\n            return this['destroy'](function() { return true });\n\n        // If you passed an arg, we interpret it as an array of entries to destroy\n        if (!arrayOfValues)\n            return [];\n        return this['destroy'](function (value) {\n            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;\n        });\n    },\n\n    'indexOf': function (item) {\n        var underlyingArray = this();\n        return ko.utils.arrayIndexOf(underlyingArray, item);\n    },\n\n    'replace': function(oldItem, newItem) {\n        var index = this['indexOf'](oldItem);\n        if (index >= 0) {\n            this.valueWillMutate();\n            this.peek()[index] = newItem;\n            this.valueHasMutated();\n        }\n    }\n};\n\n// Note that for browsers that don't support proto assignment, the\n// inheritance chain is created manually in the ko.observableArray constructor\nif (ko.utils.canSetPrototype) {\n    ko.utils.setPrototypeOf(ko.observableArray['fn'], ko.observable['fn']);\n}\n\n// Populate ko.observableArray.fn with read/write functions from native arrays\n// Important: Do not add any additional functions here that may reasonably be used to *read* data from the array\n// because we'll eval them without causing subscriptions, so ko.computed output could end up getting stale\nko.utils.arrayForEach([\"pop\", \"push\", \"reverse\", \"shift\", \"sort\", \"splice\", \"unshift\"], function (methodName) {\n    ko.observableArray['fn'][methodName] = function () {\n        // Use \"peek\" to avoid creating a subscription in any computed that we're executing in the context of\n        // (for consistency with mutating regular observables)\n        var underlyingArray = this.peek();\n        this.valueWillMutate();\n        this.cacheDiffForKnownOperation(underlyingArray, methodName, arguments);\n        var methodCallResult = underlyingArray[methodName].apply(underlyingArray, arguments);\n        this.valueHasMutated();\n        // The native sort and reverse methods return a reference to the array, but it makes more sense to return the observable array instead.\n        return methodCallResult === underlyingArray ? this : methodCallResult;\n    };\n});\n\n// Populate ko.observableArray.fn with read-only functions from native arrays\nko.utils.arrayForEach([\"slice\"], function (methodName) {\n    ko.observableArray['fn'][methodName] = function () {\n        var underlyingArray = this();\n        return underlyingArray[methodName].apply(underlyingArray, arguments);\n    };\n});\n\nko.exportSymbol('observableArray', ko.observableArray);\nvar arrayChangeEventName = 'arrayChange';\nko.extenders['trackArrayChanges'] = function(target, options) {\n    // Use the provided options--each call to trackArrayChanges overwrites the previously set options\n    target.compareArrayOptions = {};\n    if (options && typeof options == \"object\") {\n        ko.utils.extend(target.compareArrayOptions, options);\n    }\n    target.compareArrayOptions['sparse'] = true;\n\n    // Only modify the target observable once\n    if (target.cacheDiffForKnownOperation) {\n        return;\n    }\n    var trackingChanges = false,\n        cachedDiff = null,\n        arrayChangeSubscription,\n        pendingNotifications = 0,\n        underlyingNotifySubscribersFunction,\n        underlyingBeforeSubscriptionAddFunction = target.beforeSubscriptionAdd,\n        underlyingAfterSubscriptionRemoveFunction = target.afterSubscriptionRemove;\n\n    // Watch \"subscribe\" calls, and for array change events, ensure change tracking is enabled\n    target.beforeSubscriptionAdd = function (event) {\n        if (underlyingBeforeSubscriptionAddFunction)\n            underlyingBeforeSubscriptionAddFunction.call(target, event);\n        if (event === arrayChangeEventName) {\n            trackChanges();\n        }\n    };\n    // Watch \"dispose\" calls, and for array change events, ensure change tracking is disabled when all are disposed\n    target.afterSubscriptionRemove = function (event) {\n        if (underlyingAfterSubscriptionRemoveFunction)\n            underlyingAfterSubscriptionRemoveFunction.call(target, event);\n        if (event === arrayChangeEventName && !target.hasSubscriptionsForEvent(arrayChangeEventName)) {\n            if (underlyingNotifySubscribersFunction) {\n                target['notifySubscribers'] = underlyingNotifySubscribersFunction;\n                underlyingNotifySubscribersFunction = undefined;\n            }\n            arrayChangeSubscription.dispose();\n            trackingChanges = false;\n        }\n    };\n\n    function trackChanges() {\n        // Calling 'trackChanges' multiple times is the same as calling it once\n        if (trackingChanges) {\n            return;\n        }\n\n        trackingChanges = true;\n\n        // Intercept \"notifySubscribers\" to track how many times it was called.\n        underlyingNotifySubscribersFunction = target['notifySubscribers'];\n        target['notifySubscribers'] = function(valueToNotify, event) {\n            if (!event || event === defaultEvent) {\n                ++pendingNotifications;\n            }\n            return underlyingNotifySubscribersFunction.apply(this, arguments);\n        };\n\n        // Each time the array changes value, capture a clone so that on the next\n        // change it's possible to produce a diff\n        var previousContents = [].concat(target.peek() || []);\n        cachedDiff = null;\n        arrayChangeSubscription = target.subscribe(function(currentContents) {\n            // Make a copy of the current contents and ensure it's an array\n            currentContents = [].concat(currentContents || []);\n\n            // Compute the diff and issue notifications, but only if someone is listening\n            if (target.hasSubscriptionsForEvent(arrayChangeEventName)) {\n                var changes = getChanges(previousContents, currentContents);\n            }\n\n            // Eliminate references to the old, removed items, so they can be GCed\n            previousContents = currentContents;\n            cachedDiff = null;\n            pendingNotifications = 0;\n\n            if (changes && changes.length) {\n                target['notifySubscribers'](changes, arrayChangeEventName);\n            }\n        });\n    }\n\n    function getChanges(previousContents, currentContents) {\n        // We try to re-use cached diffs.\n        // The scenarios where pendingNotifications > 1 are when using rate-limiting or the Deferred Updates\n        // plugin, which without this check would not be compatible with arrayChange notifications. Normally,\n        // notifications are issued immediately so we wouldn't be queueing up more than one.\n        if (!cachedDiff || pendingNotifications > 1) {\n            cachedDiff = ko.utils.compareArrays(previousContents, currentContents, target.compareArrayOptions);\n        }\n\n        return cachedDiff;\n    }\n\n    target.cacheDiffForKnownOperation = function(rawArray, operationName, args) {\n        // Only run if we're currently tracking changes for this observable array\n        // and there aren't any pending deferred notifications.\n        if (!trackingChanges || pendingNotifications) {\n            return;\n        }\n        var diff = [],\n            arrayLength = rawArray.length,\n            argsLength = args.length,\n            offset = 0;\n\n        function pushDiff(status, value, index) {\n            return diff[diff.length] = { 'status': status, 'value': value, 'index': index };\n        }\n        switch (operationName) {\n            case 'push':\n                offset = arrayLength;\n            case 'unshift':\n                for (var index = 0; index < argsLength; index++) {\n                    pushDiff('added', args[index], offset + index);\n                }\n                break;\n\n            case 'pop':\n                offset = arrayLength - 1;\n            case 'shift':\n                if (arrayLength) {\n                    pushDiff('deleted', rawArray[offset], offset);\n                }\n                break;\n\n            case 'splice':\n                // Negative start index means 'from end of array'. After that we clamp to [0...arrayLength].\n                // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n                var startIndex = Math.min(Math.max(0, args[0] < 0 ? arrayLength + args[0] : args[0]), arrayLength),\n                    endDeleteIndex = argsLength === 1 ? arrayLength : Math.min(startIndex + (args[1] || 0), arrayLength),\n                    endAddIndex = startIndex + argsLength - 2,\n                    endIndex = Math.max(endDeleteIndex, endAddIndex),\n                    additions = [], deletions = [];\n                for (var index = startIndex, argsIndex = 2; index < endIndex; ++index, ++argsIndex) {\n                    if (index < endDeleteIndex)\n                        deletions.push(pushDiff('deleted', rawArray[index], index));\n                    if (index < endAddIndex)\n                        additions.push(pushDiff('added', args[argsIndex], index));\n                }\n                ko.utils.findMovesInArrayComparison(deletions, additions);\n                break;\n\n            default:\n                return;\n        }\n        cachedDiff = diff;\n    };\n};\nvar computedState = ko.utils.createSymbolOrString('_state');\n\nko.computed = ko.dependentObservable = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget, options) {\n    if (typeof evaluatorFunctionOrOptions === \"object\") {\n        // Single-parameter syntax - everything is on this \"options\" param\n        options = evaluatorFunctionOrOptions;\n    } else {\n        // Multi-parameter syntax - construct the options according to the params passed\n        options = options || {};\n        if (evaluatorFunctionOrOptions) {\n            options[\"read\"] = evaluatorFunctionOrOptions;\n        }\n    }\n    if (typeof options[\"read\"] != \"function\")\n        throw Error(\"Pass a function that returns the value of the ko.computed\");\n\n    var writeFunction = options[\"write\"];\n    var state = {\n        latestValue: undefined,\n        isStale: true,\n        isDirty: true,\n        isBeingEvaluated: false,\n        suppressDisposalUntilDisposeWhenReturnsFalse: false,\n        isDisposed: false,\n        pure: false,\n        isSleeping: false,\n        readFunction: options[\"read\"],\n        evaluatorFunctionTarget: evaluatorFunctionTarget || options[\"owner\"],\n        disposeWhenNodeIsRemoved: options[\"disposeWhenNodeIsRemoved\"] || options.disposeWhenNodeIsRemoved || null,\n        disposeWhen: options[\"disposeWhen\"] || options.disposeWhen,\n        domNodeDisposalCallback: null,\n        dependencyTracking: {},\n        dependenciesCount: 0,\n        evaluationTimeoutInstance: null\n    };\n\n    function computedObservable() {\n        if (arguments.length > 0) {\n            if (typeof writeFunction === \"function\") {\n                // Writing a value\n                writeFunction.apply(state.evaluatorFunctionTarget, arguments);\n            } else {\n                throw new Error(\"Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.\");\n            }\n            return this; // Permits chained assignments\n        } else {\n            // Reading the value\n            ko.dependencyDetection.registerDependency(computedObservable);\n            if (state.isDirty || (state.isSleeping && computedObservable.haveDependenciesChanged())) {\n                computedObservable.evaluateImmediate();\n            }\n            return state.latestValue;\n        }\n    }\n\n    computedObservable[computedState] = state;\n    computedObservable.hasWriteFunction = typeof writeFunction === \"function\";\n\n    // Inherit from 'subscribable'\n    if (!ko.utils.canSetPrototype) {\n        // 'subscribable' won't be on the prototype chain unless we put it there directly\n        ko.utils.extend(computedObservable, ko.subscribable['fn']);\n    }\n    ko.subscribable['fn'].init(computedObservable);\n\n    // Inherit from 'computed'\n    ko.utils.setPrototypeOfOrExtend(computedObservable, computedFn);\n\n    if (options['pure']) {\n        state.pure = true;\n        state.isSleeping = true;     // Starts off sleeping; will awake on the first subscription\n        ko.utils.extend(computedObservable, pureComputedOverrides);\n    } else if (options['deferEvaluation']) {\n        ko.utils.extend(computedObservable, deferEvaluationOverrides);\n    }\n\n    if (ko.options['deferUpdates']) {\n        ko.extenders['deferred'](computedObservable, true);\n    }\n\n    if (DEBUG) {\n        // #1731 - Aid debugging by exposing the computed's options\n        computedObservable[\"_options\"] = options;\n    }\n\n    if (state.disposeWhenNodeIsRemoved) {\n        // Since this computed is associated with a DOM node, and we don't want to dispose the computed\n        // until the DOM node is *removed* from the document (as opposed to never having been in the document),\n        // we'll prevent disposal until \"disposeWhen\" first returns false.\n        state.suppressDisposalUntilDisposeWhenReturnsFalse = true;\n\n        // disposeWhenNodeIsRemoved: true can be used to opt into the \"only dispose after first false result\"\n        // behaviour even if there's no specific node to watch. In that case, clear the option so we don't try\n        // to watch for a non-node's disposal. This technique is intended for KO's internal use only and shouldn't\n        // be documented or used by application code, as it's likely to change in a future version of KO.\n        if (!state.disposeWhenNodeIsRemoved.nodeType) {\n            state.disposeWhenNodeIsRemoved = null;\n        }\n    }\n\n    // Evaluate, unless sleeping or deferEvaluation is true\n    if (!state.isSleeping && !options['deferEvaluation']) {\n        computedObservable.evaluateImmediate();\n    }\n\n    // Attach a DOM node disposal callback so that the computed will be proactively disposed as soon as the node is\n    // removed using ko.removeNode. But skip if isActive is false (there will never be any dependencies to dispose).\n    if (state.disposeWhenNodeIsRemoved && computedObservable.isActive()) {\n        ko.utils.domNodeDisposal.addDisposeCallback(state.disposeWhenNodeIsRemoved, state.domNodeDisposalCallback = function () {\n            computedObservable.dispose();\n        });\n    }\n\n    return computedObservable;\n};\n\n// Utility function that disposes a given dependencyTracking entry\nfunction computedDisposeDependencyCallback(id, entryToDispose) {\n    if (entryToDispose !== null && entryToDispose.dispose) {\n        entryToDispose.dispose();\n    }\n}\n\n// This function gets called each time a dependency is detected while evaluating a computed.\n// It's factored out as a shared function to avoid creating unnecessary function instances during evaluation.\nfunction computedBeginDependencyDetectionCallback(subscribable, id) {\n    var computedObservable = this.computedObservable,\n        state = computedObservable[computedState];\n    if (!state.isDisposed) {\n        if (this.disposalCount && this.disposalCandidates[id]) {\n            // Don't want to dispose this subscription, as it's still being used\n            computedObservable.addDependencyTracking(id, subscribable, this.disposalCandidates[id]);\n            this.disposalCandidates[id] = null; // No need to actually delete the property - disposalCandidates is a transient object anyway\n            --this.disposalCount;\n        } else if (!state.dependencyTracking[id]) {\n            // Brand new subscription - add it\n            computedObservable.addDependencyTracking(id, subscribable, state.isSleeping ? { _target: subscribable } : computedObservable.subscribeToDependency(subscribable));\n        }\n        // If the observable we've accessed has a pending notification, ensure we get notified of the actual final value (bypass equality checks)\n        if (subscribable._notificationIsPending) {\n            subscribable._notifyNextChangeIfValueIsDifferent();\n        }\n    }\n}\n\nvar computedFn = {\n    \"equalityComparer\": valuesArePrimitiveAndEqual,\n    getDependenciesCount: function () {\n        return this[computedState].dependenciesCount;\n    },\n    addDependencyTracking: function (id, target, trackingObj) {\n        if (this[computedState].pure && target === this) {\n            throw Error(\"A 'pure' computed must not be called recursively\");\n        }\n\n        this[computedState].dependencyTracking[id] = trackingObj;\n        trackingObj._order = this[computedState].dependenciesCount++;\n        trackingObj._version = target.getVersion();\n    },\n    haveDependenciesChanged: function () {\n        var id, dependency, dependencyTracking = this[computedState].dependencyTracking;\n        for (id in dependencyTracking) {\n            if (dependencyTracking.hasOwnProperty(id)) {\n                dependency = dependencyTracking[id];\n                if ((this._evalDelayed && dependency._target._notificationIsPending) || dependency._target.hasChanged(dependency._version)) {\n                    return true;\n                }\n            }\n        }\n    },\n    markDirty: function () {\n        // Process \"dirty\" events if we can handle delayed notifications\n        if (this._evalDelayed && !this[computedState].isBeingEvaluated) {\n            this._evalDelayed(false /*isChange*/);\n        }\n    },\n    isActive: function () {\n        var state = this[computedState];\n        return state.isDirty || state.dependenciesCount > 0;\n    },\n    respondToChange: function () {\n        // Ignore \"change\" events if we've already scheduled a delayed notification\n        if (!this._notificationIsPending) {\n            this.evaluatePossiblyAsync();\n        } else if (this[computedState].isDirty) {\n            this[computedState].isStale = true;\n        }\n    },\n    subscribeToDependency: function (target) {\n        if (target._deferUpdates && !this[computedState].disposeWhenNodeIsRemoved) {\n            var dirtySub = target.subscribe(this.markDirty, this, 'dirty'),\n                changeSub = target.subscribe(this.respondToChange, this);\n            return {\n                _target: target,\n                dispose: function () {\n                    dirtySub.dispose();\n                    changeSub.dispose();\n                }\n            };\n        } else {\n            return target.subscribe(this.evaluatePossiblyAsync, this);\n        }\n    },\n    evaluatePossiblyAsync: function () {\n        var computedObservable = this,\n            throttleEvaluationTimeout = computedObservable['throttleEvaluation'];\n        if (throttleEvaluationTimeout && throttleEvaluationTimeout >= 0) {\n            clearTimeout(this[computedState].evaluationTimeoutInstance);\n            this[computedState].evaluationTimeoutInstance = ko.utils.setTimeout(function () {\n                computedObservable.evaluateImmediate(true /*notifyChange*/);\n            }, throttleEvaluationTimeout);\n        } else if (computedObservable._evalDelayed) {\n            computedObservable._evalDelayed(true /*isChange*/);\n        } else {\n            computedObservable.evaluateImmediate(true /*notifyChange*/);\n        }\n    },\n    evaluateImmediate: function (notifyChange) {\n        var computedObservable = this,\n            state = computedObservable[computedState],\n            disposeWhen = state.disposeWhen,\n            changed = false;\n\n        if (state.isBeingEvaluated) {\n            // If the evaluation of a ko.computed causes side effects, it's possible that it will trigger its own re-evaluation.\n            // This is not desirable (it's hard for a developer to realise a chain of dependencies might cause this, and they almost\n            // certainly didn't intend infinite re-evaluations). So, for predictability, we simply prevent ko.computeds from causing\n            // their own re-evaluation. Further discussion at https://github.com/SteveSanderson/knockout/pull/387\n            return;\n        }\n\n        // Do not evaluate (and possibly capture new dependencies) if disposed\n        if (state.isDisposed) {\n            return;\n        }\n\n        if (state.disposeWhenNodeIsRemoved && !ko.utils.domNodeIsAttachedToDocument(state.disposeWhenNodeIsRemoved) || disposeWhen && disposeWhen()) {\n            // See comment above about suppressDisposalUntilDisposeWhenReturnsFalse\n            if (!state.suppressDisposalUntilDisposeWhenReturnsFalse) {\n                computedObservable.dispose();\n                return;\n            }\n        } else {\n            // It just did return false, so we can stop suppressing now\n            state.suppressDisposalUntilDisposeWhenReturnsFalse = false;\n        }\n\n        state.isBeingEvaluated = true;\n        try {\n            changed = this.evaluateImmediate_CallReadWithDependencyDetection(notifyChange);\n        } finally {\n            state.isBeingEvaluated = false;\n        }\n\n        if (!state.dependenciesCount) {\n            computedObservable.dispose();\n        }\n\n        return changed;\n    },\n    evaluateImmediate_CallReadWithDependencyDetection: function (notifyChange) {\n        // This function is really just part of the evaluateImmediate logic. You would never call it from anywhere else.\n        // Factoring it out into a separate function means it can be independent of the try/catch block in evaluateImmediate,\n        // which contributes to saving about 40% off the CPU overhead of computed evaluation (on V8 at least).\n\n        var computedObservable = this,\n            state = computedObservable[computedState],\n            changed = false;\n\n        // Initially, we assume that none of the subscriptions are still being used (i.e., all are candidates for disposal).\n        // Then, during evaluation, we cross off any that are in fact still being used.\n        var isInitial = state.pure ? undefined : !state.dependenciesCount,   // If we're evaluating when there are no previous dependencies, it must be the first time\n            dependencyDetectionContext = {\n                computedObservable: computedObservable,\n                disposalCandidates: state.dependencyTracking,\n                disposalCount: state.dependenciesCount\n            };\n\n        ko.dependencyDetection.begin({\n            callbackTarget: dependencyDetectionContext,\n            callback: computedBeginDependencyDetectionCallback,\n            computed: computedObservable,\n            isInitial: isInitial\n        });\n\n        state.dependencyTracking = {};\n        state.dependenciesCount = 0;\n\n        var newValue = this.evaluateImmediate_CallReadThenEndDependencyDetection(state, dependencyDetectionContext);\n\n        if (computedObservable.isDifferent(state.latestValue, newValue)) {\n            if (!state.isSleeping) {\n                computedObservable[\"notifySubscribers\"](state.latestValue, \"beforeChange\");\n            }\n\n            state.latestValue = newValue;\n            if (DEBUG) computedObservable._latestValue = newValue;\n\n            if (state.isSleeping) {\n                computedObservable.updateVersion();\n            } else if (notifyChange) {\n                computedObservable[\"notifySubscribers\"](state.latestValue);\n            }\n\n            changed = true;\n        }\n\n        if (isInitial) {\n            computedObservable[\"notifySubscribers\"](state.latestValue, \"awake\");\n        }\n\n        return changed;\n    },\n    evaluateImmediate_CallReadThenEndDependencyDetection: function (state, dependencyDetectionContext) {\n        // This function is really part of the evaluateImmediate_CallReadWithDependencyDetection logic.\n        // You'd never call it from anywhere else. Factoring it out means that evaluateImmediate_CallReadWithDependencyDetection\n        // can be independent of try/finally blocks, which contributes to saving about 40% off the CPU\n        // overhead of computed evaluation (on V8 at least).\n\n        try {\n            var readFunction = state.readFunction;\n            return state.evaluatorFunctionTarget ? readFunction.call(state.evaluatorFunctionTarget) : readFunction();\n        } finally {\n            ko.dependencyDetection.end();\n\n            // For each subscription no longer being used, remove it from the active subscriptions list and dispose it\n            if (dependencyDetectionContext.disposalCount && !state.isSleeping) {\n                ko.utils.objectForEach(dependencyDetectionContext.disposalCandidates, computedDisposeDependencyCallback);\n            }\n\n            state.isStale = state.isDirty = false;\n        }\n    },\n    peek: function (evaluate) {\n        // By default, peek won't re-evaluate, except while the computed is sleeping or to get the initial value when \"deferEvaluation\" is set.\n        // Pass in true to evaluate if needed.\n        var state = this[computedState];\n        if ((state.isDirty && (evaluate || !state.dependenciesCount)) || (state.isSleeping && this.haveDependenciesChanged())) {\n            this.evaluateImmediate();\n        }\n        return state.latestValue;\n    },\n    limit: function (limitFunction) {\n        // Override the limit function with one that delays evaluation as well\n        ko.subscribable['fn'].limit.call(this, limitFunction);\n        this._evalIfChanged = function () {\n            if (this[computedState].isStale) {\n                this.evaluateImmediate();\n            } else {\n                this[computedState].isDirty = false;\n            }\n            return this[computedState].latestValue;\n        };\n        this._evalDelayed = function (isChange) {\n            this._limitBeforeChange(this[computedState].latestValue);\n\n            // Mark as dirty\n            this[computedState].isDirty = true;\n            if (isChange) {\n                this[computedState].isStale = true;\n            }\n\n            // Pass the observable to the \"limit\" code, which will evaluate it when\n            // it's time to do the notification.\n            this._limitChange(this);\n        };\n    },\n    dispose: function () {\n        var state = this[computedState];\n        if (!state.isSleeping && state.dependencyTracking) {\n            ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {\n                if (dependency.dispose)\n                    dependency.dispose();\n            });\n        }\n        if (state.disposeWhenNodeIsRemoved && state.domNodeDisposalCallback) {\n            ko.utils.domNodeDisposal.removeDisposeCallback(state.disposeWhenNodeIsRemoved, state.domNodeDisposalCallback);\n        }\n        state.dependencyTracking = null;\n        state.dependenciesCount = 0;\n        state.isDisposed = true;\n        state.isStale = false;\n        state.isDirty = false;\n        state.isSleeping = false;\n        state.disposeWhenNodeIsRemoved = null;\n    }\n};\n\nvar pureComputedOverrides = {\n    beforeSubscriptionAdd: function (event) {\n        // If asleep, wake up the computed by subscribing to any dependencies.\n        var computedObservable = this,\n            state = computedObservable[computedState];\n        if (!state.isDisposed && state.isSleeping && event == 'change') {\n            state.isSleeping = false;\n            if (state.isStale || computedObservable.haveDependenciesChanged()) {\n                state.dependencyTracking = null;\n                state.dependenciesCount = 0;\n                if (computedObservable.evaluateImmediate()) {\n                    computedObservable.updateVersion();\n                }\n            } else {\n                // First put the dependencies in order\n                var dependeciesOrder = [];\n                ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {\n                    dependeciesOrder[dependency._order] = id;\n                });\n                // Next, subscribe to each one\n                ko.utils.arrayForEach(dependeciesOrder, function (id, order) {\n                    var dependency = state.dependencyTracking[id],\n                        subscription = computedObservable.subscribeToDependency(dependency._target);\n                    subscription._order = order;\n                    subscription._version = dependency._version;\n                    state.dependencyTracking[id] = subscription;\n                });\n            }\n            if (!state.isDisposed) {     // test since evaluating could trigger disposal\n                computedObservable[\"notifySubscribers\"](state.latestValue, \"awake\");\n            }\n        }\n    },\n    afterSubscriptionRemove: function (event) {\n        var state = this[computedState];\n        if (!state.isDisposed && event == 'change' && !this.hasSubscriptionsForEvent('change')) {\n            ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {\n                if (dependency.dispose) {\n                    state.dependencyTracking[id] = {\n                        _target: dependency._target,\n                        _order: dependency._order,\n                        _version: dependency._version\n                    };\n                    dependency.dispose();\n                }\n            });\n            state.isSleeping = true;\n            this[\"notifySubscribers\"](undefined, \"asleep\");\n        }\n    },\n    getVersion: function () {\n        // Because a pure computed is not automatically updated while it is sleeping, we can't\n        // simply return the version number. Instead, we check if any of the dependencies have\n        // changed and conditionally re-evaluate the computed observable.\n        var state = this[computedState];\n        if (state.isSleeping && (state.isStale || this.haveDependenciesChanged())) {\n            this.evaluateImmediate();\n        }\n        return ko.subscribable['fn'].getVersion.call(this);\n    }\n};\n\nvar deferEvaluationOverrides = {\n    beforeSubscriptionAdd: function (event) {\n        // This will force a computed with deferEvaluation to evaluate when the first subscription is registered.\n        if (event == 'change' || event == 'beforeChange') {\n            this.peek();\n        }\n    }\n};\n\n// Note that for browsers that don't support proto assignment, the\n// inheritance chain is created manually in the ko.computed constructor\nif (ko.utils.canSetPrototype) {\n    ko.utils.setPrototypeOf(computedFn, ko.subscribable['fn']);\n}\n\n// Set the proto chain values for ko.hasPrototype\nvar protoProp = ko.observable.protoProperty; // == \"__ko_proto__\"\nko.computed[protoProp] = ko.observable;\ncomputedFn[protoProp] = ko.computed;\n\nko.isComputed = function (instance) {\n    return ko.hasPrototype(instance, ko.computed);\n};\n\nko.isPureComputed = function (instance) {\n    return ko.hasPrototype(instance, ko.computed)\n        && instance[computedState] && instance[computedState].pure;\n};\n\nko.exportSymbol('computed', ko.computed);\nko.exportSymbol('dependentObservable', ko.computed);    // export ko.dependentObservable for backwards compatibility (1.x)\nko.exportSymbol('isComputed', ko.isComputed);\nko.exportSymbol('isPureComputed', ko.isPureComputed);\nko.exportSymbol('computed.fn', computedFn);\nko.exportProperty(computedFn, 'peek', computedFn.peek);\nko.exportProperty(computedFn, 'dispose', computedFn.dispose);\nko.exportProperty(computedFn, 'isActive', computedFn.isActive);\nko.exportProperty(computedFn, 'getDependenciesCount', computedFn.getDependenciesCount);\n\nko.pureComputed = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget) {\n    if (typeof evaluatorFunctionOrOptions === 'function') {\n        return ko.computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget, {'pure':true});\n    } else {\n        evaluatorFunctionOrOptions = ko.utils.extend({}, evaluatorFunctionOrOptions);   // make a copy of the parameter object\n        evaluatorFunctionOrOptions['pure'] = true;\n        return ko.computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget);\n    }\n}\nko.exportSymbol('pureComputed', ko.pureComputed);\n\n(function() {\n    var maxNestedObservableDepth = 10; // Escape the (unlikely) pathalogical case where an observable's current value is itself (or similar reference cycle)\n\n    ko.toJS = function(rootObject) {\n        if (arguments.length == 0)\n            throw new Error(\"When calling ko.toJS, pass the object you want to convert.\");\n\n        // We just unwrap everything at every level in the object graph\n        return mapJsObjectGraph(rootObject, function(valueToMap) {\n            // Loop because an observable's value might in turn be another observable wrapper\n            for (var i = 0; ko.isObservable(valueToMap) && (i < maxNestedObservableDepth); i++)\n                valueToMap = valueToMap();\n            return valueToMap;\n        });\n    };\n\n    ko.toJSON = function(rootObject, replacer, space) {     // replacer and space are optional\n        var plainJavaScriptObject = ko.toJS(rootObject);\n        return ko.utils.stringifyJson(plainJavaScriptObject, replacer, space);\n    };\n\n    function mapJsObjectGraph(rootObject, mapInputCallback, visitedObjects) {\n        visitedObjects = visitedObjects || new objectLookup();\n\n        rootObject = mapInputCallback(rootObject);\n        var canHaveProperties = (typeof rootObject == \"object\") && (rootObject !== null) && (rootObject !== undefined) && (!(rootObject instanceof RegExp)) && (!(rootObject instanceof Date)) && (!(rootObject instanceof String)) && (!(rootObject instanceof Number)) && (!(rootObject instanceof Boolean));\n        if (!canHaveProperties)\n            return rootObject;\n\n        var outputProperties = rootObject instanceof Array ? [] : {};\n        visitedObjects.save(rootObject, outputProperties);\n\n        visitPropertiesOrArrayEntries(rootObject, function(indexer) {\n            var propertyValue = mapInputCallback(rootObject[indexer]);\n\n            switch (typeof propertyValue) {\n                case \"boolean\":\n                case \"number\":\n                case \"string\":\n                case \"function\":\n                    outputProperties[indexer] = propertyValue;\n                    break;\n                case \"object\":\n                case \"undefined\":\n                    var previouslyMappedValue = visitedObjects.get(propertyValue);\n                    outputProperties[indexer] = (previouslyMappedValue !== undefined)\n                        ? previouslyMappedValue\n                        : mapJsObjectGraph(propertyValue, mapInputCallback, visitedObjects);\n                    break;\n            }\n        });\n\n        return outputProperties;\n    }\n\n    function visitPropertiesOrArrayEntries(rootObject, visitorCallback) {\n        if (rootObject instanceof Array) {\n            for (var i = 0; i < rootObject.length; i++)\n                visitorCallback(i);\n\n            // For arrays, also respect toJSON property for custom mappings (fixes #278)\n            if (typeof rootObject['toJSON'] == 'function')\n                visitorCallback('toJSON');\n        } else {\n            for (var propertyName in rootObject) {\n                visitorCallback(propertyName);\n            }\n        }\n    };\n\n    function objectLookup() {\n        this.keys = [];\n        this.values = [];\n    };\n\n    objectLookup.prototype = {\n        constructor: objectLookup,\n        save: function(key, value) {\n            var existingIndex = ko.utils.arrayIndexOf(this.keys, key);\n            if (existingIndex >= 0)\n                this.values[existingIndex] = value;\n            else {\n                this.keys.push(key);\n                this.values.push(value);\n            }\n        },\n        get: function(key) {\n            var existingIndex = ko.utils.arrayIndexOf(this.keys, key);\n            return (existingIndex >= 0) ? this.values[existingIndex] : undefined;\n        }\n    };\n})();\n\nko.exportSymbol('toJS', ko.toJS);\nko.exportSymbol('toJSON', ko.toJSON);\n(function () {\n    var hasDomDataExpandoProperty = '__ko__hasDomDataOptionValue__';\n\n    // Normally, SELECT elements and their OPTIONs can only take value of type 'string' (because the values\n    // are stored on DOM attributes). ko.selectExtensions provides a way for SELECTs/OPTIONs to have values\n    // that are arbitrary objects. This is very convenient when implementing things like cascading dropdowns.\n    ko.selectExtensions = {\n        readValue : function(element) {\n            switch (ko.utils.tagNameLower(element)) {\n                case 'option':\n                    if (element[hasDomDataExpandoProperty] === true)\n                        return ko.utils.domData.get(element, ko.bindingHandlers.options.optionValueDomDataKey);\n                    return ko.utils.ieVersion <= 7\n                        ? (element.getAttributeNode('value') && element.getAttributeNode('value').specified ? element.value : element.text)\n                        : element.value;\n                case 'select':\n                    return element.selectedIndex >= 0 ? ko.selectExtensions.readValue(element.options[element.selectedIndex]) : undefined;\n                default:\n                    return element.value;\n            }\n        },\n\n        writeValue: function(element, value, allowUnset) {\n            switch (ko.utils.tagNameLower(element)) {\n                case 'option':\n                    switch(typeof value) {\n                        case \"string\":\n                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, undefined);\n                            if (hasDomDataExpandoProperty in element) { // IE <= 8 throws errors if you delete non-existent properties from a DOM node\n                                delete element[hasDomDataExpandoProperty];\n                            }\n                            element.value = value;\n                            break;\n                        default:\n                            // Store arbitrary object using DomData\n                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, value);\n                            element[hasDomDataExpandoProperty] = true;\n\n                            // Special treatment of numbers is just for backward compatibility. KO 1.2.1 wrote numerical values to element.value.\n                            element.value = typeof value === \"number\" ? value : \"\";\n                            break;\n                    }\n                    break;\n                case 'select':\n                    if (value === \"\" || value === null)       // A blank string or null value will select the caption\n                        value = undefined;\n                    var selection = -1;\n                    for (var i = 0, n = element.options.length, optionValue; i < n; ++i) {\n                        optionValue = ko.selectExtensions.readValue(element.options[i]);\n                        // Include special check to handle selecting a caption with a blank string value\n                        if (optionValue == value || (optionValue == \"\" && value === undefined)) {\n                            selection = i;\n                            break;\n                        }\n                    }\n                    if (allowUnset || selection >= 0 || (value === undefined && element.size > 1)) {\n                        element.selectedIndex = selection;\n                    }\n                    break;\n                default:\n                    if ((value === null) || (value === undefined))\n                        value = \"\";\n                    element.value = value;\n                    break;\n            }\n        }\n    };\n})();\n\nko.exportSymbol('selectExtensions', ko.selectExtensions);\nko.exportSymbol('selectExtensions.readValue', ko.selectExtensions.readValue);\nko.exportSymbol('selectExtensions.writeValue', ko.selectExtensions.writeValue);\nko.expressionRewriting = (function () {\n    var javaScriptReservedWords = [\"true\", \"false\", \"null\", \"undefined\"];\n\n    // Matches something that can be assigned to--either an isolated identifier or something ending with a property accessor\n    // This is designed to be simple and avoid false negatives, but could produce false positives (e.g., a+b.c).\n    // This also will not properly handle nested brackets (e.g., obj1[obj2['prop']]; see #911).\n    var javaScriptAssignmentTarget = /^(?:[$_a-z][$\\w]*|(.+)(\\.\\s*[$_a-z][$\\w]*|\\[.+\\]))$/i;\n\n    function getWriteableValue(expression) {\n        if (ko.utils.arrayIndexOf(javaScriptReservedWords, expression) >= 0)\n            return false;\n        var match = expression.match(javaScriptAssignmentTarget);\n        return match === null ? false : match[1] ? ('Object(' + match[1] + ')' + match[2]) : expression;\n    }\n\n    // The following regular expressions will be used to split an object-literal string into tokens\n\n        // These two match strings, either with double quotes or single quotes\n    var stringDouble = '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"',\n        stringSingle = \"'(?:[^'\\\\\\\\]|\\\\\\\\.)*'\",\n        // Matches a regular expression (text enclosed by slashes), but will also match sets of divisions\n        // as a regular expression (this is handled by the parsing loop below).\n        stringRegexp = '/(?:[^/\\\\\\\\]|\\\\\\\\.)*/\\w*',\n        // These characters have special meaning to the parser and must not appear in the middle of a\n        // token, except as part of a string.\n        specials = ',\"\\'{}()/:[\\\\]',\n        // Match text (at least two characters) that does not contain any of the above special characters,\n        // although some of the special characters are allowed to start it (all but the colon and comma).\n        // The text can contain spaces, but leading or trailing spaces are skipped.\n        everyThingElse = '[^\\\\s:,/][^' + specials + ']*[^\\\\s' + specials + ']',\n        // Match any non-space character not matched already. This will match colons and commas, since they're\n        // not matched by \"everyThingElse\", but will also match any other single character that wasn't already\n        // matched (for example: in \"a: 1, b: 2\", each of the non-space characters will be matched by oneNotSpace).\n        oneNotSpace = '[^\\\\s]',\n\n        // Create the actual regular expression by or-ing the above strings. The order is important.\n        bindingToken = RegExp(stringDouble + '|' + stringSingle + '|' + stringRegexp + '|' + everyThingElse + '|' + oneNotSpace, 'g'),\n\n        // Match end of previous token to determine whether a slash is a division or regex.\n        divisionLookBehind = /[\\])\"'A-Za-z0-9_$]+$/,\n        keywordRegexLookBehind = {'in':1,'return':1,'typeof':1};\n\n    function parseObjectLiteral(objectLiteralString) {\n        // Trim leading and trailing spaces from the string\n        var str = ko.utils.stringTrim(objectLiteralString);\n\n        // Trim braces '{' surrounding the whole object literal\n        if (str.charCodeAt(0) === 123) str = str.slice(1, -1);\n\n        // Split into tokens\n        var result = [], toks = str.match(bindingToken), key, values = [], depth = 0;\n\n        if (toks) {\n            // Append a comma so that we don't need a separate code block to deal with the last item\n            toks.push(',');\n\n            for (var i = 0, tok; tok = toks[i]; ++i) {\n                var c = tok.charCodeAt(0);\n                // A comma signals the end of a key/value pair if depth is zero\n                if (c === 44) { // \",\"\n                    if (depth <= 0) {\n                        result.push((key && values.length) ? {key: key, value: values.join('')} : {'unknown': key || values.join('')});\n                        key = depth = 0;\n                        values = [];\n                        continue;\n                    }\n                // Simply skip the colon that separates the name and value\n                } else if (c === 58) { // \":\"\n                    if (!depth && !key && values.length === 1) {\n                        key = values.pop();\n                        continue;\n                    }\n                // A set of slashes is initially matched as a regular expression, but could be division\n                } else if (c === 47 && i && tok.length > 1) {  // \"/\"\n                    // Look at the end of the previous token to determine if the slash is actually division\n                    var match = toks[i-1].match(divisionLookBehind);\n                    if (match && !keywordRegexLookBehind[match[0]]) {\n                        // The slash is actually a division punctuator; re-parse the remainder of the string (not including the slash)\n                        str = str.substr(str.indexOf(tok) + 1);\n                        toks = str.match(bindingToken);\n                        toks.push(',');\n                        i = -1;\n                        // Continue with just the slash\n                        tok = '/';\n                    }\n                // Increment depth for parentheses, braces, and brackets so that interior commas are ignored\n                } else if (c === 40 || c === 123 || c === 91) { // '(', '{', '['\n                    ++depth;\n                } else if (c === 41 || c === 125 || c === 93) { // ')', '}', ']'\n                    --depth;\n                // The key will be the first token; if it's a string, trim the quotes\n                } else if (!key && !values.length && (c === 34 || c === 39)) { // '\"', \"'\"\n                    tok = tok.slice(1, -1);\n                }\n                values.push(tok);\n            }\n        }\n        return result;\n    }\n\n    // Two-way bindings include a write function that allow the handler to update the value even if it's not an observable.\n    var twoWayBindings = {};\n\n    function preProcessBindings(bindingsStringOrKeyValueArray, bindingOptions) {\n        bindingOptions = bindingOptions || {};\n\n        function processKeyValue(key, val) {\n            var writableVal;\n            function callPreprocessHook(obj) {\n                return (obj && obj['preprocess']) ? (val = obj['preprocess'](val, key, processKeyValue)) : true;\n            }\n            if (!bindingParams) {\n                if (!callPreprocessHook(ko['getBindingHandler'](key)))\n                    return;\n\n                if (twoWayBindings[key] && (writableVal = getWriteableValue(val))) {\n                    // For two-way bindings, provide a write method in case the value\n                    // isn't a writable observable.\n                    propertyAccessorResultStrings.push(\"'\" + key + \"':function(_z){\" + writableVal + \"=_z}\");\n                }\n            }\n            // Values are wrapped in a function so that each value can be accessed independently\n            if (makeValueAccessors) {\n                val = 'function(){return ' + val + ' }';\n            }\n            resultStrings.push(\"'\" + key + \"':\" + val);\n        }\n\n        var resultStrings = [],\n            propertyAccessorResultStrings = [],\n            makeValueAccessors = bindingOptions['valueAccessors'],\n            bindingParams = bindingOptions['bindingParams'],\n            keyValueArray = typeof bindingsStringOrKeyValueArray === \"string\" ?\n                parseObjectLiteral(bindingsStringOrKeyValueArray) : bindingsStringOrKeyValueArray;\n\n        ko.utils.arrayForEach(keyValueArray, function(keyValue) {\n            processKeyValue(keyValue.key || keyValue['unknown'], keyValue.value);\n        });\n\n        if (propertyAccessorResultStrings.length)\n            processKeyValue('_ko_property_writers', \"{\" + propertyAccessorResultStrings.join(\",\") + \" }\");\n\n        return resultStrings.join(\",\");\n    }\n\n    return {\n        bindingRewriteValidators: [],\n\n        twoWayBindings: twoWayBindings,\n\n        parseObjectLiteral: parseObjectLiteral,\n\n        preProcessBindings: preProcessBindings,\n\n        keyValueArrayContainsKey: function(keyValueArray, key) {\n            for (var i = 0; i < keyValueArray.length; i++)\n                if (keyValueArray[i]['key'] == key)\n                    return true;\n            return false;\n        },\n\n        // Internal, private KO utility for updating model properties from within bindings\n        // property:            If the property being updated is (or might be) an observable, pass it here\n        //                      If it turns out to be a writable observable, it will be written to directly\n        // allBindings:         An object with a get method to retrieve bindings in the current execution context.\n        //                      This will be searched for a '_ko_property_writers' property in case you're writing to a non-observable\n        // key:                 The key identifying the property to be written. Example: for { hasFocus: myValue }, write to 'myValue' by specifying the key 'hasFocus'\n        // value:               The value to be written\n        // checkIfDifferent:    If true, and if the property being written is a writable observable, the value will only be written if\n        //                      it is !== existing value on that writable observable\n        writeValueToProperty: function(property, allBindings, key, value, checkIfDifferent) {\n            if (!property || !ko.isObservable(property)) {\n                var propWriters = allBindings.get('_ko_property_writers');\n                if (propWriters && propWriters[key])\n                    propWriters[key](value);\n            } else if (ko.isWriteableObservable(property) && (!checkIfDifferent || property.peek() !== value)) {\n                property(value);\n            }\n        }\n    };\n})();\n\nko.exportSymbol('expressionRewriting', ko.expressionRewriting);\nko.exportSymbol('expressionRewriting.bindingRewriteValidators', ko.expressionRewriting.bindingRewriteValidators);\nko.exportSymbol('expressionRewriting.parseObjectLiteral', ko.expressionRewriting.parseObjectLiteral);\nko.exportSymbol('expressionRewriting.preProcessBindings', ko.expressionRewriting.preProcessBindings);\n\n// Making bindings explicitly declare themselves as \"two way\" isn't ideal in the long term (it would be better if\n// all bindings could use an official 'property writer' API without needing to declare that they might). However,\n// since this is not, and has never been, a public API (_ko_property_writers was never documented), it's acceptable\n// as an internal implementation detail in the short term.\n// For those developers who rely on _ko_property_writers in their custom bindings, we expose _twoWayBindings as an\n// undocumented feature that makes it relatively easy to upgrade to KO 3.0. However, this is still not an official\n// public API, and we reserve the right to remove it at any time if we create a real public property writers API.\nko.exportSymbol('expressionRewriting._twoWayBindings', ko.expressionRewriting.twoWayBindings);\n\n// For backward compatibility, define the following aliases. (Previously, these function names were misleading because\n// they referred to JSON specifically, even though they actually work with arbitrary JavaScript object literal expressions.)\nko.exportSymbol('jsonExpressionRewriting', ko.expressionRewriting);\nko.exportSymbol('jsonExpressionRewriting.insertPropertyAccessorsIntoJson', ko.expressionRewriting.preProcessBindings);\n(function() {\n    // \"Virtual elements\" is an abstraction on top of the usual DOM API which understands the notion that comment nodes\n    // may be used to represent hierarchy (in addition to the DOM's natural hierarchy).\n    // If you call the DOM-manipulating functions on ko.virtualElements, you will be able to read and write the state\n    // of that virtual hierarchy\n    //\n    // The point of all this is to support containerless templates (e.g., <!-- ko foreach:someCollection -->blah<!-- /ko -->)\n    // without having to scatter special cases all over the binding and templating code.\n\n    // IE 9 cannot reliably read the \"nodeValue\" property of a comment node (see https://github.com/SteveSanderson/knockout/issues/186)\n    // but it does give them a nonstandard alternative property called \"text\" that it can read reliably. Other browsers don't have that property.\n    // So, use node.text where available, and node.nodeValue elsewhere\n    var commentNodesHaveTextProperty = document && document.createComment(\"test\").text === \"<!--test-->\";\n\n    var startCommentRegex = commentNodesHaveTextProperty ? /^<!--\\s*ko(?:\\s+([\\s\\S]+))?\\s*-->$/ : /^\\s*ko(?:\\s+([\\s\\S]+))?\\s*$/;\n    var endCommentRegex =   commentNodesHaveTextProperty ? /^<!--\\s*\\/ko\\s*-->$/ : /^\\s*\\/ko\\s*$/;\n    var htmlTagsWithOptionallyClosingChildren = { 'ul': true, 'ol': true };\n\n    function isStartComment(node) {\n        return (node.nodeType == 8) && startCommentRegex.test(commentNodesHaveTextProperty ? node.text : node.nodeValue);\n    }\n\n    function isEndComment(node) {\n        return (node.nodeType == 8) && endCommentRegex.test(commentNodesHaveTextProperty ? node.text : node.nodeValue);\n    }\n\n    function getVirtualChildren(startComment, allowUnbalanced) {\n        var currentNode = startComment;\n        var depth = 1;\n        var children = [];\n        while (currentNode = currentNode.nextSibling) {\n            if (isEndComment(currentNode)) {\n                depth--;\n                if (depth === 0)\n                    return children;\n            }\n\n            children.push(currentNode);\n\n            if (isStartComment(currentNode))\n                depth++;\n        }\n        if (!allowUnbalanced)\n            throw new Error(\"Cannot find closing comment tag to match: \" + startComment.nodeValue);\n        return null;\n    }\n\n    function getMatchingEndComment(startComment, allowUnbalanced) {\n        var allVirtualChildren = getVirtualChildren(startComment, allowUnbalanced);\n        if (allVirtualChildren) {\n            if (allVirtualChildren.length > 0)\n                return allVirtualChildren[allVirtualChildren.length - 1].nextSibling;\n            return startComment.nextSibling;\n        } else\n            return null; // Must have no matching end comment, and allowUnbalanced is true\n    }\n\n    function getUnbalancedChildTags(node) {\n        // e.g., from <div>OK</div><!-- ko blah --><span>Another</span>, returns: <!-- ko blah --><span>Another</span>\n        //       from <div>OK</div><!-- /ko --><!-- /ko -->,             returns: <!-- /ko --><!-- /ko -->\n        var childNode = node.firstChild, captureRemaining = null;\n        if (childNode) {\n            do {\n                if (captureRemaining)                   // We already hit an unbalanced node and are now just scooping up all subsequent nodes\n                    captureRemaining.push(childNode);\n                else if (isStartComment(childNode)) {\n                    var matchingEndComment = getMatchingEndComment(childNode, /* allowUnbalanced: */ true);\n                    if (matchingEndComment)             // It's a balanced tag, so skip immediately to the end of this virtual set\n                        childNode = matchingEndComment;\n                    else\n                        captureRemaining = [childNode]; // It's unbalanced, so start capturing from this point\n                } else if (isEndComment(childNode)) {\n                    captureRemaining = [childNode];     // It's unbalanced (if it wasn't, we'd have skipped over it already), so start capturing\n                }\n            } while (childNode = childNode.nextSibling);\n        }\n        return captureRemaining;\n    }\n\n    ko.virtualElements = {\n        allowedBindings: {},\n\n        childNodes: function(node) {\n            return isStartComment(node) ? getVirtualChildren(node) : node.childNodes;\n        },\n\n        emptyNode: function(node) {\n            if (!isStartComment(node))\n                ko.utils.emptyDomNode(node);\n            else {\n                var virtualChildren = ko.virtualElements.childNodes(node);\n                for (var i = 0, j = virtualChildren.length; i < j; i++)\n                    ko.removeNode(virtualChildren[i]);\n            }\n        },\n\n        setDomNodeChildren: function(node, childNodes) {\n            if (!isStartComment(node))\n                ko.utils.setDomNodeChildren(node, childNodes);\n            else {\n                ko.virtualElements.emptyNode(node);\n                var endCommentNode = node.nextSibling; // Must be the next sibling, as we just emptied the children\n                for (var i = 0, j = childNodes.length; i < j; i++)\n                    endCommentNode.parentNode.insertBefore(childNodes[i], endCommentNode);\n            }\n        },\n\n        prepend: function(containerNode, nodeToPrepend) {\n            if (!isStartComment(containerNode)) {\n                if (containerNode.firstChild)\n                    containerNode.insertBefore(nodeToPrepend, containerNode.firstChild);\n                else\n                    containerNode.appendChild(nodeToPrepend);\n            } else {\n                // Start comments must always have a parent and at least one following sibling (the end comment)\n                containerNode.parentNode.insertBefore(nodeToPrepend, containerNode.nextSibling);\n            }\n        },\n\n        insertAfter: function(containerNode, nodeToInsert, insertAfterNode) {\n            if (!insertAfterNode) {\n                ko.virtualElements.prepend(containerNode, nodeToInsert);\n            } else if (!isStartComment(containerNode)) {\n                // Insert after insertion point\n                if (insertAfterNode.nextSibling)\n                    containerNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);\n                else\n                    containerNode.appendChild(nodeToInsert);\n            } else {\n                // Children of start comments must always have a parent and at least one following sibling (the end comment)\n                containerNode.parentNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);\n            }\n        },\n\n        firstChild: function(node) {\n            if (!isStartComment(node))\n                return node.firstChild;\n            if (!node.nextSibling || isEndComment(node.nextSibling))\n                return null;\n            return node.nextSibling;\n        },\n\n        nextSibling: function(node) {\n            if (isStartComment(node))\n                node = getMatchingEndComment(node);\n            if (node.nextSibling && isEndComment(node.nextSibling))\n                return null;\n            return node.nextSibling;\n        },\n\n        hasBindingValue: isStartComment,\n\n        virtualNodeBindingValue: function(node) {\n            var regexMatch = (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(startCommentRegex);\n            return regexMatch ? regexMatch[1] : null;\n        },\n\n        normaliseVirtualElementDomStructure: function(elementVerified) {\n            // Workaround for https://github.com/SteveSanderson/knockout/issues/155\n            // (IE <= 8 or IE 9 quirks mode parses your HTML weirdly, treating closing </li> tags as if they don't exist, thereby moving comment nodes\n            // that are direct descendants of <ul> into the preceding <li>)\n            if (!htmlTagsWithOptionallyClosingChildren[ko.utils.tagNameLower(elementVerified)])\n                return;\n\n            // Scan immediate children to see if they contain unbalanced comment tags. If they do, those comment tags\n            // must be intended to appear *after* that child, so move them there.\n            var childNode = elementVerified.firstChild;\n            if (childNode) {\n                do {\n                    if (childNode.nodeType === 1) {\n                        var unbalancedTags = getUnbalancedChildTags(childNode);\n                        if (unbalancedTags) {\n                            // Fix up the DOM by moving the unbalanced tags to where they most likely were intended to be placed - *after* the child\n                            var nodeToInsertBefore = childNode.nextSibling;\n                            for (var i = 0; i < unbalancedTags.length; i++) {\n                                if (nodeToInsertBefore)\n                                    elementVerified.insertBefore(unbalancedTags[i], nodeToInsertBefore);\n                                else\n                                    elementVerified.appendChild(unbalancedTags[i]);\n                            }\n                        }\n                    }\n                } while (childNode = childNode.nextSibling);\n            }\n        }\n    };\n})();\nko.exportSymbol('virtualElements', ko.virtualElements);\nko.exportSymbol('virtualElements.allowedBindings', ko.virtualElements.allowedBindings);\nko.exportSymbol('virtualElements.emptyNode', ko.virtualElements.emptyNode);\n//ko.exportSymbol('virtualElements.firstChild', ko.virtualElements.firstChild);     // firstChild is not minified\nko.exportSymbol('virtualElements.insertAfter', ko.virtualElements.insertAfter);\n//ko.exportSymbol('virtualElements.nextSibling', ko.virtualElements.nextSibling);   // nextSibling is not minified\nko.exportSymbol('virtualElements.prepend', ko.virtualElements.prepend);\nko.exportSymbol('virtualElements.setDomNodeChildren', ko.virtualElements.setDomNodeChildren);\n(function() {\n    var defaultBindingAttributeName = \"data-bind\";\n\n    ko.bindingProvider = function() {\n        this.bindingCache = {};\n    };\n\n    ko.utils.extend(ko.bindingProvider.prototype, {\n        'nodeHasBindings': function(node) {\n            switch (node.nodeType) {\n                case 1: // Element\n                    return node.getAttribute(defaultBindingAttributeName) != null\n                        || ko.components['getComponentNameForNode'](node);\n                case 8: // Comment node\n                    return ko.virtualElements.hasBindingValue(node);\n                default: return false;\n            }\n        },\n\n        'getBindings': function(node, bindingContext) {\n            var bindingsString = this['getBindingsString'](node, bindingContext),\n                parsedBindings = bindingsString ? this['parseBindingsString'](bindingsString, bindingContext, node) : null;\n            return ko.components.addBindingsForCustomElement(parsedBindings, node, bindingContext, /* valueAccessors */ false);\n        },\n\n        'getBindingAccessors': function(node, bindingContext) {\n            var bindingsString = this['getBindingsString'](node, bindingContext),\n                parsedBindings = bindingsString ? this['parseBindingsString'](bindingsString, bindingContext, node, { 'valueAccessors': true }) : null;\n            return ko.components.addBindingsForCustomElement(parsedBindings, node, bindingContext, /* valueAccessors */ true);\n        },\n\n        // The following function is only used internally by this default provider.\n        // It's not part of the interface definition for a general binding provider.\n        'getBindingsString': function(node, bindingContext) {\n            switch (node.nodeType) {\n                case 1: return node.getAttribute(defaultBindingAttributeName);   // Element\n                case 8: return ko.virtualElements.virtualNodeBindingValue(node); // Comment node\n                default: return null;\n            }\n        },\n\n        // The following function is only used internally by this default provider.\n        // It's not part of the interface definition for a general binding provider.\n        'parseBindingsString': function(bindingsString, bindingContext, node, options) {\n            try {\n                var bindingFunction = createBindingsStringEvaluatorViaCache(bindingsString, this.bindingCache, options);\n                return bindingFunction(bindingContext, node);\n            } catch (ex) {\n                ex.message = \"Unable to parse bindings.\\nBindings value: \" + bindingsString + \"\\nMessage: \" + ex.message;\n                throw ex;\n            }\n        }\n    });\n\n    ko.bindingProvider['instance'] = new ko.bindingProvider();\n\n    function createBindingsStringEvaluatorViaCache(bindingsString, cache, options) {\n        var cacheKey = bindingsString + (options && options['valueAccessors'] || '');\n        return cache[cacheKey]\n            || (cache[cacheKey] = createBindingsStringEvaluator(bindingsString, options));\n    }\n\n    function createBindingsStringEvaluator(bindingsString, options) {\n        // Build the source for a function that evaluates \"expression\"\n        // For each scope variable, add an extra level of \"with\" nesting\n        // Example result: with(sc1) { with(sc0) { return (expression) } }\n        var rewrittenBindings = ko.expressionRewriting.preProcessBindings(bindingsString, options),\n            functionBody = \"with($context){with($data||{}){return{\" + rewrittenBindings + \"}}}\";\n        return new Function(\"$context\", \"$element\", functionBody);\n    }\n})();\n\nko.exportSymbol('bindingProvider', ko.bindingProvider);\n(function () {\n    ko.bindingHandlers = {};\n\n    // The following element types will not be recursed into during binding.\n    var bindingDoesNotRecurseIntoElementTypes = {\n        // Don't want bindings that operate on text nodes to mutate <script> and <textarea> contents,\n        // because it's unexpected and a potential XSS issue.\n        // Also bindings should not operate on <template> elements since this breaks in Internet Explorer\n        // and because such elements' contents are always intended to be bound in a different context\n        // from where they appear in the document.\n        'script': true,\n        'textarea': true,\n        'template': true\n    };\n\n    // Use an overridable method for retrieving binding handlers so that a plugins may support dynamically created handlers\n    ko['getBindingHandler'] = function(bindingKey) {\n        return ko.bindingHandlers[bindingKey];\n    };\n\n    // The ko.bindingContext constructor is only called directly to create the root context. For child\n    // contexts, use bindingContext.createChildContext or bindingContext.extend.\n    ko.bindingContext = function(dataItemOrAccessor, parentContext, dataItemAlias, extendCallback, options) {\n\n        // The binding context object includes static properties for the current, parent, and root view models.\n        // If a view model is actually stored in an observable, the corresponding binding context object, and\n        // any child contexts, must be updated when the view model is changed.\n        function updateContext() {\n            // Most of the time, the context will directly get a view model object, but if a function is given,\n            // we call the function to retrieve the view model. If the function accesses any observables or returns\n            // an observable, the dependency is tracked, and those observables can later cause the binding\n            // context to be updated.\n            var dataItemOrObservable = isFunc ? dataItemOrAccessor() : dataItemOrAccessor,\n                dataItem = ko.utils.unwrapObservable(dataItemOrObservable);\n\n            if (parentContext) {\n                // When a \"parent\" context is given, register a dependency on the parent context. Thus whenever the\n                // parent context is updated, this context will also be updated.\n                if (parentContext._subscribable)\n                    parentContext._subscribable();\n\n                // Copy $root and any custom properties from the parent context\n                ko.utils.extend(self, parentContext);\n\n                // Because the above copy overwrites our own properties, we need to reset them.\n                self._subscribable = subscribable;\n            } else {\n                self['$parents'] = [];\n                self['$root'] = dataItem;\n\n                // Export 'ko' in the binding context so it will be available in bindings and templates\n                // even if 'ko' isn't exported as a global, such as when using an AMD loader.\n                // See https://github.com/SteveSanderson/knockout/issues/490\n                self['ko'] = ko;\n            }\n            self['$rawData'] = dataItemOrObservable;\n            self['$data'] = dataItem;\n            if (dataItemAlias)\n                self[dataItemAlias] = dataItem;\n\n            // The extendCallback function is provided when creating a child context or extending a context.\n            // It handles the specific actions needed to finish setting up the binding context. Actions in this\n            // function could also add dependencies to this binding context.\n            if (extendCallback)\n                extendCallback(self, parentContext, dataItem);\n\n            return self['$data'];\n        }\n        function disposeWhen() {\n            return nodes && !ko.utils.anyDomNodeIsAttachedToDocument(nodes);\n        }\n\n        var self = this,\n            isFunc = typeof(dataItemOrAccessor) == \"function\" && !ko.isObservable(dataItemOrAccessor),\n            nodes,\n            subscribable;\n\n        if (options && options['exportDependencies']) {\n            // The \"exportDependencies\" option means that the calling code will track any dependencies and re-create\n            // the binding context when they change.\n            updateContext();\n        } else {\n            subscribable = ko.dependentObservable(updateContext, null, { disposeWhen: disposeWhen, disposeWhenNodeIsRemoved: true });\n\n            // At this point, the binding context has been initialized, and the \"subscribable\" computed observable is\n            // subscribed to any observables that were accessed in the process. If there is nothing to track, the\n            // computed will be inactive, and we can safely throw it away. If it's active, the computed is stored in\n            // the context object.\n            if (subscribable.isActive()) {\n                self._subscribable = subscribable;\n\n                // Always notify because even if the model ($data) hasn't changed, other context properties might have changed\n                subscribable['equalityComparer'] = null;\n\n                // We need to be able to dispose of this computed observable when it's no longer needed. This would be\n                // easy if we had a single node to watch, but binding contexts can be used by many different nodes, and\n                // we cannot assume that those nodes have any relation to each other. So instead we track any node that\n                // the context is attached to, and dispose the computed when all of those nodes have been cleaned.\n\n                // Add properties to *subscribable* instead of *self* because any properties added to *self* may be overwritten on updates\n                nodes = [];\n                subscribable._addNode = function(node) {\n                    nodes.push(node);\n                    ko.utils.domNodeDisposal.addDisposeCallback(node, function(node) {\n                        ko.utils.arrayRemoveItem(nodes, node);\n                        if (!nodes.length) {\n                            subscribable.dispose();\n                            self._subscribable = subscribable = undefined;\n                        }\n                    });\n                };\n            }\n        }\n    }\n\n    // Extend the binding context hierarchy with a new view model object. If the parent context is watching\n    // any observables, the new child context will automatically get a dependency on the parent context.\n    // But this does not mean that the $data value of the child context will also get updated. If the child\n    // view model also depends on the parent view model, you must provide a function that returns the correct\n    // view model on each update.\n    ko.bindingContext.prototype['createChildContext'] = function (dataItemOrAccessor, dataItemAlias, extendCallback, options) {\n        return new ko.bindingContext(dataItemOrAccessor, this, dataItemAlias, function(self, parentContext) {\n            // Extend the context hierarchy by setting the appropriate pointers\n            self['$parentContext'] = parentContext;\n            self['$parent'] = parentContext['$data'];\n            self['$parents'] = (parentContext['$parents'] || []).slice(0);\n            self['$parents'].unshift(self['$parent']);\n            if (extendCallback)\n                extendCallback(self);\n        }, options);\n    };\n\n    // Extend the binding context with new custom properties. This doesn't change the context hierarchy.\n    // Similarly to \"child\" contexts, provide a function here to make sure that the correct values are set\n    // when an observable view model is updated.\n    ko.bindingContext.prototype['extend'] = function(properties) {\n        // If the parent context references an observable view model, \"_subscribable\" will always be the\n        // latest view model object. If not, \"_subscribable\" isn't set, and we can use the static \"$data\" value.\n        return new ko.bindingContext(this._subscribable || this['$data'], this, null, function(self, parentContext) {\n            // This \"child\" context doesn't directly track a parent observable view model,\n            // so we need to manually set the $rawData value to match the parent.\n            self['$rawData'] = parentContext['$rawData'];\n            ko.utils.extend(self, typeof(properties) == \"function\" ? properties() : properties);\n        });\n    };\n\n    ko.bindingContext.prototype.createStaticChildContext = function (dataItemOrAccessor, dataItemAlias) {\n        return this['createChildContext'](dataItemOrAccessor, dataItemAlias, null, { \"exportDependencies\": true });\n    };\n\n    // Returns the valueAccesor function for a binding value\n    function makeValueAccessor(value) {\n        return function() {\n            return value;\n        };\n    }\n\n    // Returns the value of a valueAccessor function\n    function evaluateValueAccessor(valueAccessor) {\n        return valueAccessor();\n    }\n\n    // Given a function that returns bindings, create and return a new object that contains\n    // binding value-accessors functions. Each accessor function calls the original function\n    // so that it always gets the latest value and all dependencies are captured. This is used\n    // by ko.applyBindingsToNode and getBindingsAndMakeAccessors.\n    function makeAccessorsFromFunction(callback) {\n        return ko.utils.objectMap(ko.dependencyDetection.ignore(callback), function(value, key) {\n            return function() {\n                return callback()[key];\n            };\n        });\n    }\n\n    // Given a bindings function or object, create and return a new object that contains\n    // binding value-accessors functions. This is used by ko.applyBindingsToNode.\n    function makeBindingAccessors(bindings, context, node) {\n        if (typeof bindings === 'function') {\n            return makeAccessorsFromFunction(bindings.bind(null, context, node));\n        } else {\n            return ko.utils.objectMap(bindings, makeValueAccessor);\n        }\n    }\n\n    // This function is used if the binding provider doesn't include a getBindingAccessors function.\n    // It must be called with 'this' set to the provider instance.\n    function getBindingsAndMakeAccessors(node, context) {\n        return makeAccessorsFromFunction(this['getBindings'].bind(this, node, context));\n    }\n\n    function validateThatBindingIsAllowedForVirtualElements(bindingName) {\n        var validator = ko.virtualElements.allowedBindings[bindingName];\n        if (!validator)\n            throw new Error(\"The binding '\" + bindingName + \"' cannot be used with virtual elements\")\n    }\n\n    function applyBindingsToDescendantsInternal (bindingContext, elementOrVirtualElement, bindingContextsMayDifferFromDomParentElement) {\n        var currentChild,\n            nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement),\n            provider = ko.bindingProvider['instance'],\n            preprocessNode = provider['preprocessNode'];\n\n        // Preprocessing allows a binding provider to mutate a node before bindings are applied to it. For example it's\n        // possible to insert new siblings after it, and/or replace the node with a different one. This can be used to\n        // implement custom binding syntaxes, such as {{ value }} for string interpolation, or custom element types that\n        // trigger insertion of <template> contents at that point in the document.\n        if (preprocessNode) {\n            while (currentChild = nextInQueue) {\n                nextInQueue = ko.virtualElements.nextSibling(currentChild);\n                preprocessNode.call(provider, currentChild);\n            }\n            // Reset nextInQueue for the next loop\n            nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement);\n        }\n\n        while (currentChild = nextInQueue) {\n            // Keep a record of the next child *before* applying bindings, in case the binding removes the current child from its position\n            nextInQueue = ko.virtualElements.nextSibling(currentChild);\n            applyBindingsToNodeAndDescendantsInternal(bindingContext, currentChild, bindingContextsMayDifferFromDomParentElement);\n        }\n    }\n\n    function applyBindingsToNodeAndDescendantsInternal (bindingContext, nodeVerified, bindingContextMayDifferFromDomParentElement) {\n        var shouldBindDescendants = true;\n\n        // Perf optimisation: Apply bindings only if...\n        // (1) We need to store the binding context on this node (because it may differ from the DOM parent node's binding context)\n        //     Note that we can't store binding contexts on non-elements (e.g., text nodes), as IE doesn't allow expando properties for those\n        // (2) It might have bindings (e.g., it has a data-bind attribute, or it's a marker for a containerless template)\n        var isElement = (nodeVerified.nodeType === 1);\n        if (isElement) // Workaround IE <= 8 HTML parsing weirdness\n            ko.virtualElements.normaliseVirtualElementDomStructure(nodeVerified);\n\n        var shouldApplyBindings = (isElement && bindingContextMayDifferFromDomParentElement)             // Case (1)\n                               || ko.bindingProvider['instance']['nodeHasBindings'](nodeVerified);       // Case (2)\n        if (shouldApplyBindings)\n            shouldBindDescendants = applyBindingsToNodeInternal(nodeVerified, null, bindingContext, bindingContextMayDifferFromDomParentElement)['shouldBindDescendants'];\n\n        if (shouldBindDescendants && !bindingDoesNotRecurseIntoElementTypes[ko.utils.tagNameLower(nodeVerified)]) {\n            // We're recursing automatically into (real or virtual) child nodes without changing binding contexts. So,\n            //  * For children of a *real* element, the binding context is certainly the same as on their DOM .parentNode,\n            //    hence bindingContextsMayDifferFromDomParentElement is false\n            //  * For children of a *virtual* element, we can't be sure. Evaluating .parentNode on those children may\n            //    skip over any number of intermediate virtual elements, any of which might define a custom binding context,\n            //    hence bindingContextsMayDifferFromDomParentElement is true\n            applyBindingsToDescendantsInternal(bindingContext, nodeVerified, /* bindingContextsMayDifferFromDomParentElement: */ !isElement);\n        }\n    }\n\n    var boundElementDomDataKey = ko.utils.domData.nextKey();\n\n\n    function topologicalSortBindings(bindings) {\n        // Depth-first sort\n        var result = [],                // The list of key/handler pairs that we will return\n            bindingsConsidered = {},    // A temporary record of which bindings are already in 'result'\n            cyclicDependencyStack = []; // Keeps track of a depth-search so that, if there's a cycle, we know which bindings caused it\n        ko.utils.objectForEach(bindings, function pushBinding(bindingKey) {\n            if (!bindingsConsidered[bindingKey]) {\n                var binding = ko['getBindingHandler'](bindingKey);\n                if (binding) {\n                    // First add dependencies (if any) of the current binding\n                    if (binding['after']) {\n                        cyclicDependencyStack.push(bindingKey);\n                        ko.utils.arrayForEach(binding['after'], function(bindingDependencyKey) {\n                            if (bindings[bindingDependencyKey]) {\n                                if (ko.utils.arrayIndexOf(cyclicDependencyStack, bindingDependencyKey) !== -1) {\n                                    throw Error(\"Cannot combine the following bindings, because they have a cyclic dependency: \" + cyclicDependencyStack.join(\", \"));\n                                } else {\n                                    pushBinding(bindingDependencyKey);\n                                }\n                            }\n                        });\n                        cyclicDependencyStack.length--;\n                    }\n                    // Next add the current binding\n                    result.push({ key: bindingKey, handler: binding });\n                }\n                bindingsConsidered[bindingKey] = true;\n            }\n        });\n\n        return result;\n    }\n\n    function applyBindingsToNodeInternal(node, sourceBindings, bindingContext, bindingContextMayDifferFromDomParentElement) {\n        // Prevent multiple applyBindings calls for the same node, except when a binding value is specified\n        var alreadyBound = ko.utils.domData.get(node, boundElementDomDataKey);\n        if (!sourceBindings) {\n            if (alreadyBound) {\n                throw Error(\"You cannot apply bindings multiple times to the same element.\");\n            }\n            ko.utils.domData.set(node, boundElementDomDataKey, true);\n        }\n\n        // Optimization: Don't store the binding context on this node if it's definitely the same as on node.parentNode, because\n        // we can easily recover it just by scanning up the node's ancestors in the DOM\n        // (note: here, parent node means \"real DOM parent\" not \"virtual parent\", as there's no O(1) way to find the virtual parent)\n        if (!alreadyBound && bindingContextMayDifferFromDomParentElement)\n            ko.storedBindingContextForNode(node, bindingContext);\n\n        // Use bindings if given, otherwise fall back on asking the bindings provider to give us some bindings\n        var bindings;\n        if (sourceBindings && typeof sourceBindings !== 'function') {\n            bindings = sourceBindings;\n        } else {\n            var provider = ko.bindingProvider['instance'],\n                getBindings = provider['getBindingAccessors'] || getBindingsAndMakeAccessors;\n\n            // Get the binding from the provider within a computed observable so that we can update the bindings whenever\n            // the binding context is updated or if the binding provider accesses observables.\n            var bindingsUpdater = ko.dependentObservable(\n                function() {\n                    bindings = sourceBindings ? sourceBindings(bindingContext, node) : getBindings.call(provider, node, bindingContext);\n                    // Register a dependency on the binding context to support observable view models.\n                    if (bindings && bindingContext._subscribable)\n                        bindingContext._subscribable();\n                    return bindings;\n                },\n                null, { disposeWhenNodeIsRemoved: node }\n            );\n\n            if (!bindings || !bindingsUpdater.isActive())\n                bindingsUpdater = null;\n        }\n\n        var bindingHandlerThatControlsDescendantBindings;\n        if (bindings) {\n            // Return the value accessor for a given binding. When bindings are static (won't be updated because of a binding\n            // context update), just return the value accessor from the binding. Otherwise, return a function that always gets\n            // the latest binding value and registers a dependency on the binding updater.\n            var getValueAccessor = bindingsUpdater\n                ? function(bindingKey) {\n                    return function() {\n                        return evaluateValueAccessor(bindingsUpdater()[bindingKey]);\n                    };\n                } : function(bindingKey) {\n                    return bindings[bindingKey];\n                };\n\n            // Use of allBindings as a function is maintained for backwards compatibility, but its use is deprecated\n            function allBindings() {\n                return ko.utils.objectMap(bindingsUpdater ? bindingsUpdater() : bindings, evaluateValueAccessor);\n            }\n            // The following is the 3.x allBindings API\n            allBindings['get'] = function(key) {\n                return bindings[key] && evaluateValueAccessor(getValueAccessor(key));\n            };\n            allBindings['has'] = function(key) {\n                return key in bindings;\n            };\n\n            // First put the bindings into the right order\n            var orderedBindings = topologicalSortBindings(bindings);\n\n            // Go through the sorted bindings, calling init and update for each\n            ko.utils.arrayForEach(orderedBindings, function(bindingKeyAndHandler) {\n                // Note that topologicalSortBindings has already filtered out any nonexistent binding handlers,\n                // so bindingKeyAndHandler.handler will always be nonnull.\n                var handlerInitFn = bindingKeyAndHandler.handler[\"init\"],\n                    handlerUpdateFn = bindingKeyAndHandler.handler[\"update\"],\n                    bindingKey = bindingKeyAndHandler.key;\n\n                if (node.nodeType === 8) {\n                    validateThatBindingIsAllowedForVirtualElements(bindingKey);\n                }\n\n                try {\n                    // Run init, ignoring any dependencies\n                    if (typeof handlerInitFn == \"function\") {\n                        ko.dependencyDetection.ignore(function() {\n                            var initResult = handlerInitFn(node, getValueAccessor(bindingKey), allBindings, bindingContext['$data'], bindingContext);\n\n                            // If this binding handler claims to control descendant bindings, make a note of this\n                            if (initResult && initResult['controlsDescendantBindings']) {\n                                if (bindingHandlerThatControlsDescendantBindings !== undefined)\n                                    throw new Error(\"Multiple bindings (\" + bindingHandlerThatControlsDescendantBindings + \" and \" + bindingKey + \") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.\");\n                                bindingHandlerThatControlsDescendantBindings = bindingKey;\n                            }\n                        });\n                    }\n\n                    // Run update in its own computed wrapper\n                    if (typeof handlerUpdateFn == \"function\") {\n                        ko.dependentObservable(\n                            function() {\n                                handlerUpdateFn(node, getValueAccessor(bindingKey), allBindings, bindingContext['$data'], bindingContext);\n                            },\n                            null,\n                            { disposeWhenNodeIsRemoved: node }\n                        );\n                    }\n                } catch (ex) {\n                    ex.message = \"Unable to process binding \\\"\" + bindingKey + \": \" + bindings[bindingKey] + \"\\\"\\nMessage: \" + ex.message;\n                    throw ex;\n                }\n            });\n        }\n\n        return {\n            'shouldBindDescendants': bindingHandlerThatControlsDescendantBindings === undefined\n        };\n    };\n\n    var storedBindingContextDomDataKey = ko.utils.domData.nextKey();\n    ko.storedBindingContextForNode = function (node, bindingContext) {\n        if (arguments.length == 2) {\n            ko.utils.domData.set(node, storedBindingContextDomDataKey, bindingContext);\n            if (bindingContext._subscribable)\n                bindingContext._subscribable._addNode(node);\n        } else {\n            return ko.utils.domData.get(node, storedBindingContextDomDataKey);\n        }\n    }\n\n    function getBindingContext(viewModelOrBindingContext) {\n        return viewModelOrBindingContext && (viewModelOrBindingContext instanceof ko.bindingContext)\n            ? viewModelOrBindingContext\n            : new ko.bindingContext(viewModelOrBindingContext);\n    }\n\n    ko.applyBindingAccessorsToNode = function (node, bindings, viewModelOrBindingContext) {\n        if (node.nodeType === 1) // If it's an element, workaround IE <= 8 HTML parsing weirdness\n            ko.virtualElements.normaliseVirtualElementDomStructure(node);\n        return applyBindingsToNodeInternal(node, bindings, getBindingContext(viewModelOrBindingContext), true);\n    };\n\n    ko.applyBindingsToNode = function (node, bindings, viewModelOrBindingContext) {\n        var context = getBindingContext(viewModelOrBindingContext);\n        return ko.applyBindingAccessorsToNode(node, makeBindingAccessors(bindings, context, node), context);\n    };\n\n    ko.applyBindingsToDescendants = function(viewModelOrBindingContext, rootNode) {\n        if (rootNode.nodeType === 1 || rootNode.nodeType === 8)\n            applyBindingsToDescendantsInternal(getBindingContext(viewModelOrBindingContext), rootNode, true);\n    };\n\n    ko.applyBindings = function (viewModelOrBindingContext, rootNode) {\n        // If jQuery is loaded after Knockout, we won't initially have access to it. So save it here.\n        if (!jQueryInstance && window['jQuery']) {\n            jQueryInstance = window['jQuery'];\n        }\n\n        if (rootNode && (rootNode.nodeType !== 1) && (rootNode.nodeType !== 8))\n            throw new Error(\"ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node\");\n        rootNode = rootNode || window.document.body; // Make \"rootNode\" parameter optional\n\n        applyBindingsToNodeAndDescendantsInternal(getBindingContext(viewModelOrBindingContext), rootNode, true);\n    };\n\n    // Retrieving binding context from arbitrary nodes\n    ko.contextFor = function(node) {\n        // We can only do something meaningful for elements and comment nodes (in particular, not text nodes, as IE can't store domdata for them)\n        switch (node.nodeType) {\n            case 1:\n            case 8:\n                var context = ko.storedBindingContextForNode(node);\n                if (context) return context;\n                if (node.parentNode) return ko.contextFor(node.parentNode);\n                break;\n        }\n        return undefined;\n    };\n    ko.dataFor = function(node) {\n        var context = ko.contextFor(node);\n        return context ? context['$data'] : undefined;\n    };\n\n    ko.exportSymbol('bindingHandlers', ko.bindingHandlers);\n    ko.exportSymbol('applyBindings', ko.applyBindings);\n    ko.exportSymbol('applyBindingsToDescendants', ko.applyBindingsToDescendants);\n    ko.exportSymbol('applyBindingAccessorsToNode', ko.applyBindingAccessorsToNode);\n    ko.exportSymbol('applyBindingsToNode', ko.applyBindingsToNode);\n    ko.exportSymbol('contextFor', ko.contextFor);\n    ko.exportSymbol('dataFor', ko.dataFor);\n})();\n(function(undefined) {\n    var loadingSubscribablesCache = {}, // Tracks component loads that are currently in flight\n        loadedDefinitionsCache = {};    // Tracks component loads that have already completed\n\n    ko.components = {\n        get: function(componentName, callback) {\n            var cachedDefinition = getObjectOwnProperty(loadedDefinitionsCache, componentName);\n            if (cachedDefinition) {\n                // It's already loaded and cached. Reuse the same definition object.\n                // Note that for API consistency, even cache hits complete asynchronously by default.\n                // You can bypass this by putting synchronous:true on your component config.\n                if (cachedDefinition.isSynchronousComponent) {\n                    ko.dependencyDetection.ignore(function() { // See comment in loaderRegistryBehaviors.js for reasoning\n                        callback(cachedDefinition.definition);\n                    });\n                } else {\n                    ko.tasks.schedule(function() { callback(cachedDefinition.definition); });\n                }\n            } else {\n                // Join the loading process that is already underway, or start a new one.\n                loadComponentAndNotify(componentName, callback);\n            }\n        },\n\n        clearCachedDefinition: function(componentName) {\n            delete loadedDefinitionsCache[componentName];\n        },\n\n        _getFirstResultFromLoaders: getFirstResultFromLoaders\n    };\n\n    function getObjectOwnProperty(obj, propName) {\n        return obj.hasOwnProperty(propName) ? obj[propName] : undefined;\n    }\n\n    function loadComponentAndNotify(componentName, callback) {\n        var subscribable = getObjectOwnProperty(loadingSubscribablesCache, componentName),\n            completedAsync;\n        if (!subscribable) {\n            // It's not started loading yet. Start loading, and when it's done, move it to loadedDefinitionsCache.\n            subscribable = loadingSubscribablesCache[componentName] = new ko.subscribable();\n            subscribable.subscribe(callback);\n\n            beginLoadingComponent(componentName, function(definition, config) {\n                var isSynchronousComponent = !!(config && config['synchronous']);\n                loadedDefinitionsCache[componentName] = { definition: definition, isSynchronousComponent: isSynchronousComponent };\n                delete loadingSubscribablesCache[componentName];\n\n                // For API consistency, all loads complete asynchronously. However we want to avoid\n                // adding an extra task schedule if it's unnecessary (i.e., the completion is already\n                // async).\n                //\n                // You can bypass the 'always asynchronous' feature by putting the synchronous:true\n                // flag on your component configuration when you register it.\n                if (completedAsync || isSynchronousComponent) {\n                    // Note that notifySubscribers ignores any dependencies read within the callback.\n                    // See comment in loaderRegistryBehaviors.js for reasoning\n                    subscribable['notifySubscribers'](definition);\n                } else {\n                    ko.tasks.schedule(function() {\n                        subscribable['notifySubscribers'](definition);\n                    });\n                }\n            });\n            completedAsync = true;\n        } else {\n            subscribable.subscribe(callback);\n        }\n    }\n\n    function beginLoadingComponent(componentName, callback) {\n        getFirstResultFromLoaders('getConfig', [componentName], function(config) {\n            if (config) {\n                // We have a config, so now load its definition\n                getFirstResultFromLoaders('loadComponent', [componentName, config], function(definition) {\n                    callback(definition, config);\n                });\n            } else {\n                // The component has no config - it's unknown to all the loaders.\n                // Note that this is not an error (e.g., a module loading error) - that would abort the\n                // process and this callback would not run. For this callback to run, all loaders must\n                // have confirmed they don't know about this component.\n                callback(null, null);\n            }\n        });\n    }\n\n    function getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders) {\n        // On the first call in the stack, start with the full set of loaders\n        if (!candidateLoaders) {\n            candidateLoaders = ko.components['loaders'].slice(0); // Use a copy, because we'll be mutating this array\n        }\n\n        // Try the next candidate\n        var currentCandidateLoader = candidateLoaders.shift();\n        if (currentCandidateLoader) {\n            var methodInstance = currentCandidateLoader[methodName];\n            if (methodInstance) {\n                var wasAborted = false,\n                    synchronousReturnValue = methodInstance.apply(currentCandidateLoader, argsExceptCallback.concat(function(result) {\n                        if (wasAborted) {\n                            callback(null);\n                        } else if (result !== null) {\n                            // This candidate returned a value. Use it.\n                            callback(result);\n                        } else {\n                            // Try the next candidate\n                            getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders);\n                        }\n                    }));\n\n                // Currently, loaders may not return anything synchronously. This leaves open the possibility\n                // that we'll extend the API to support synchronous return values in the future. It won't be\n                // a breaking change, because currently no loader is allowed to return anything except undefined.\n                if (synchronousReturnValue !== undefined) {\n                    wasAborted = true;\n\n                    // Method to suppress exceptions will remain undocumented. This is only to keep\n                    // KO's specs running tidily, since we can observe the loading got aborted without\n                    // having exceptions cluttering up the console too.\n                    if (!currentCandidateLoader['suppressLoaderExceptions']) {\n                        throw new Error('Component loaders must supply values by invoking the callback, not by returning values synchronously.');\n                    }\n                }\n            } else {\n                // This candidate doesn't have the relevant handler. Synchronously move on to the next one.\n                getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders);\n            }\n        } else {\n            // No candidates returned a value\n            callback(null);\n        }\n    }\n\n    // Reference the loaders via string name so it's possible for developers\n    // to replace the whole array by assigning to ko.components.loaders\n    ko.components['loaders'] = [];\n\n    ko.exportSymbol('components', ko.components);\n    ko.exportSymbol('components.get', ko.components.get);\n    ko.exportSymbol('components.clearCachedDefinition', ko.components.clearCachedDefinition);\n})();\n(function(undefined) {\n\n    // The default loader is responsible for two things:\n    // 1. Maintaining the default in-memory registry of component configuration objects\n    //    (i.e., the thing you're writing to when you call ko.components.register(someName, ...))\n    // 2. Answering requests for components by fetching configuration objects\n    //    from that default in-memory registry and resolving them into standard\n    //    component definition objects (of the form { createViewModel: ..., template: ... })\n    // Custom loaders may override either of these facilities, i.e.,\n    // 1. To supply configuration objects from some other source (e.g., conventions)\n    // 2. Or, to resolve configuration objects by loading viewmodels/templates via arbitrary logic.\n\n    var defaultConfigRegistry = {};\n\n    ko.components.register = function(componentName, config) {\n        if (!config) {\n            throw new Error('Invalid configuration for ' + componentName);\n        }\n\n        if (ko.components.isRegistered(componentName)) {\n            throw new Error('Component ' + componentName + ' is already registered');\n        }\n\n        defaultConfigRegistry[componentName] = config;\n    };\n\n    ko.components.isRegistered = function(componentName) {\n        return defaultConfigRegistry.hasOwnProperty(componentName);\n    };\n\n    ko.components.unregister = function(componentName) {\n        delete defaultConfigRegistry[componentName];\n        ko.components.clearCachedDefinition(componentName);\n    };\n\n    ko.components.defaultLoader = {\n        'getConfig': function(componentName, callback) {\n            var result = defaultConfigRegistry.hasOwnProperty(componentName)\n                ? defaultConfigRegistry[componentName]\n                : null;\n            callback(result);\n        },\n\n        'loadComponent': function(componentName, config, callback) {\n            var errorCallback = makeErrorCallback(componentName);\n            possiblyGetConfigFromAmd(errorCallback, config, function(loadedConfig) {\n                resolveConfig(componentName, errorCallback, loadedConfig, callback);\n            });\n        },\n\n        'loadTemplate': function(componentName, templateConfig, callback) {\n            resolveTemplate(makeErrorCallback(componentName), templateConfig, callback);\n        },\n\n        'loadViewModel': function(componentName, viewModelConfig, callback) {\n            resolveViewModel(makeErrorCallback(componentName), viewModelConfig, callback);\n        }\n    };\n\n    var createViewModelKey = 'createViewModel';\n\n    // Takes a config object of the form { template: ..., viewModel: ... }, and asynchronously convert it\n    // into the standard component definition format:\n    //    { template: <ArrayOfDomNodes>, createViewModel: function(params, componentInfo) { ... } }.\n    // Since both template and viewModel may need to be resolved asynchronously, both tasks are performed\n    // in parallel, and the results joined when both are ready. We don't depend on any promises infrastructure,\n    // so this is implemented manually below.\n    function resolveConfig(componentName, errorCallback, config, callback) {\n        var result = {},\n            makeCallBackWhenZero = 2,\n            tryIssueCallback = function() {\n                if (--makeCallBackWhenZero === 0) {\n                    callback(result);\n                }\n            },\n            templateConfig = config['template'],\n            viewModelConfig = config['viewModel'];\n\n        if (templateConfig) {\n            possiblyGetConfigFromAmd(errorCallback, templateConfig, function(loadedConfig) {\n                ko.components._getFirstResultFromLoaders('loadTemplate', [componentName, loadedConfig], function(resolvedTemplate) {\n                    result['template'] = resolvedTemplate;\n                    tryIssueCallback();\n                });\n            });\n        } else {\n            tryIssueCallback();\n        }\n\n        if (viewModelConfig) {\n            possiblyGetConfigFromAmd(errorCallback, viewModelConfig, function(loadedConfig) {\n                ko.components._getFirstResultFromLoaders('loadViewModel', [componentName, loadedConfig], function(resolvedViewModel) {\n                    result[createViewModelKey] = resolvedViewModel;\n                    tryIssueCallback();\n                });\n            });\n        } else {\n            tryIssueCallback();\n        }\n    }\n\n    function resolveTemplate(errorCallback, templateConfig, callback) {\n        if (typeof templateConfig === 'string') {\n            // Markup - parse it\n            callback(ko.utils.parseHtmlFragment(templateConfig));\n        } else if (templateConfig instanceof Array) {\n            // Assume already an array of DOM nodes - pass through unchanged\n            callback(templateConfig);\n        } else if (isDocumentFragment(templateConfig)) {\n            // Document fragment - use its child nodes\n            callback(ko.utils.makeArray(templateConfig.childNodes));\n        } else if (templateConfig['element']) {\n            var element = templateConfig['element'];\n            if (isDomElement(element)) {\n                // Element instance - copy its child nodes\n                callback(cloneNodesFromTemplateSourceElement(element));\n            } else if (typeof element === 'string') {\n                // Element ID - find it, then copy its child nodes\n                var elemInstance = document.getElementById(element);\n                if (elemInstance) {\n                    callback(cloneNodesFromTemplateSourceElement(elemInstance));\n                } else {\n                    errorCallback('Cannot find element with ID ' + element);\n                }\n            } else {\n                errorCallback('Unknown element type: ' + element);\n            }\n        } else {\n            errorCallback('Unknown template value: ' + templateConfig);\n        }\n    }\n\n    function resolveViewModel(errorCallback, viewModelConfig, callback) {\n        if (typeof viewModelConfig === 'function') {\n            // Constructor - convert to standard factory function format\n            // By design, this does *not* supply componentInfo to the constructor, as the intent is that\n            // componentInfo contains non-viewmodel data (e.g., the component's element) that should only\n            // be used in factory functions, not viewmodel constructors.\n            callback(function (params /*, componentInfo */) {\n                return new viewModelConfig(params);\n            });\n        } else if (typeof viewModelConfig[createViewModelKey] === 'function') {\n            // Already a factory function - use it as-is\n            callback(viewModelConfig[createViewModelKey]);\n        } else if ('instance' in viewModelConfig) {\n            // Fixed object instance - promote to createViewModel format for API consistency\n            var fixedInstance = viewModelConfig['instance'];\n            callback(function (params, componentInfo) {\n                return fixedInstance;\n            });\n        } else if ('viewModel' in viewModelConfig) {\n            // Resolved AMD module whose value is of the form { viewModel: ... }\n            resolveViewModel(errorCallback, viewModelConfig['viewModel'], callback);\n        } else {\n            errorCallback('Unknown viewModel value: ' + viewModelConfig);\n        }\n    }\n\n    function cloneNodesFromTemplateSourceElement(elemInstance) {\n        switch (ko.utils.tagNameLower(elemInstance)) {\n            case 'script':\n                return ko.utils.parseHtmlFragment(elemInstance.text);\n            case 'textarea':\n                return ko.utils.parseHtmlFragment(elemInstance.value);\n            case 'template':\n                // For browsers with proper <template> element support (i.e., where the .content property\n                // gives a document fragment), use that document fragment.\n                if (isDocumentFragment(elemInstance.content)) {\n                    return ko.utils.cloneNodes(elemInstance.content.childNodes);\n                }\n        }\n\n        // Regular elements such as <div>, and <template> elements on old browsers that don't really\n        // understand <template> and just treat it as a regular container\n        return ko.utils.cloneNodes(elemInstance.childNodes);\n    }\n\n    function isDomElement(obj) {\n        if (window['HTMLElement']) {\n            return obj instanceof HTMLElement;\n        } else {\n            return obj && obj.tagName && obj.nodeType === 1;\n        }\n    }\n\n    function isDocumentFragment(obj) {\n        if (window['DocumentFragment']) {\n            return obj instanceof DocumentFragment;\n        } else {\n            return obj && obj.nodeType === 11;\n        }\n    }\n\n    function possiblyGetConfigFromAmd(errorCallback, config, callback) {\n        if (typeof config['require'] === 'string') {\n            // The config is the value of an AMD module\n            if (amdRequire || window['require']) {\n                (amdRequire || window['require'])([config['require']], callback);\n            } else {\n                errorCallback('Uses require, but no AMD loader is present');\n            }\n        } else {\n            callback(config);\n        }\n    }\n\n    function makeErrorCallback(componentName) {\n        return function (message) {\n            throw new Error('Component \\'' + componentName + '\\': ' + message);\n        };\n    }\n\n    ko.exportSymbol('components.register', ko.components.register);\n    ko.exportSymbol('components.isRegistered', ko.components.isRegistered);\n    ko.exportSymbol('components.unregister', ko.components.unregister);\n\n    // Expose the default loader so that developers can directly ask it for configuration\n    // or to resolve configuration\n    ko.exportSymbol('components.defaultLoader', ko.components.defaultLoader);\n\n    // By default, the default loader is the only registered component loader\n    ko.components['loaders'].push(ko.components.defaultLoader);\n\n    // Privately expose the underlying config registry for use in old-IE shim\n    ko.components._allRegisteredComponents = defaultConfigRegistry;\n})();\n(function (undefined) {\n    // Overridable API for determining which component name applies to a given node. By overriding this,\n    // you can for example map specific tagNames to components that are not preregistered.\n    ko.components['getComponentNameForNode'] = function(node) {\n        var tagNameLower = ko.utils.tagNameLower(node);\n        if (ko.components.isRegistered(tagNameLower)) {\n            // Try to determine that this node can be considered a *custom* element; see https://github.com/knockout/knockout/issues/1603\n            if (tagNameLower.indexOf('-') != -1 || ('' + node) == \"[object HTMLUnknownElement]\" || (ko.utils.ieVersion <= 8 && node.tagName === tagNameLower)) {\n                return tagNameLower;\n            }\n        }\n    };\n\n    ko.components.addBindingsForCustomElement = function(allBindings, node, bindingContext, valueAccessors) {\n        // Determine if it's really a custom element matching a component\n        if (node.nodeType === 1) {\n            var componentName = ko.components['getComponentNameForNode'](node);\n            if (componentName) {\n                // It does represent a component, so add a component binding for it\n                allBindings = allBindings || {};\n\n                if (allBindings['component']) {\n                    // Avoid silently overwriting some other 'component' binding that may already be on the element\n                    throw new Error('Cannot use the \"component\" binding on a custom element matching a component');\n                }\n\n                var componentBindingValue = { 'name': componentName, 'params': getComponentParamsFromCustomElement(node, bindingContext) };\n\n                allBindings['component'] = valueAccessors\n                    ? function() { return componentBindingValue; }\n                    : componentBindingValue;\n            }\n        }\n\n        return allBindings;\n    }\n\n    var nativeBindingProviderInstance = new ko.bindingProvider();\n\n    function getComponentParamsFromCustomElement(elem, bindingContext) {\n        var paramsAttribute = elem.getAttribute('params');\n\n        if (paramsAttribute) {\n            var params = nativeBindingProviderInstance['parseBindingsString'](paramsAttribute, bindingContext, elem, { 'valueAccessors': true, 'bindingParams': true }),\n                rawParamComputedValues = ko.utils.objectMap(params, function(paramValue, paramName) {\n                    return ko.computed(paramValue, null, { disposeWhenNodeIsRemoved: elem });\n                }),\n                result = ko.utils.objectMap(rawParamComputedValues, function(paramValueComputed, paramName) {\n                    var paramValue = paramValueComputed.peek();\n                    // Does the evaluation of the parameter value unwrap any observables?\n                    if (!paramValueComputed.isActive()) {\n                        // No it doesn't, so there's no need for any computed wrapper. Just pass through the supplied value directly.\n                        // Example: \"someVal: firstName, age: 123\" (whether or not firstName is an observable/computed)\n                        return paramValue;\n                    } else {\n                        // Yes it does. Supply a computed property that unwraps both the outer (binding expression)\n                        // level of observability, and any inner (resulting model value) level of observability.\n                        // This means the component doesn't have to worry about multiple unwrapping. If the value is a\n                        // writable observable, the computed will also be writable and pass the value on to the observable.\n                        return ko.computed({\n                            'read': function() {\n                                return ko.utils.unwrapObservable(paramValueComputed());\n                            },\n                            'write': ko.isWriteableObservable(paramValue) && function(value) {\n                                paramValueComputed()(value);\n                            },\n                            disposeWhenNodeIsRemoved: elem\n                        });\n                    }\n                });\n\n            // Give access to the raw computeds, as long as that wouldn't overwrite any custom param also called '$raw'\n            // This is in case the developer wants to react to outer (binding) observability separately from inner\n            // (model value) observability, or in case the model value observable has subobservables.\n            if (!result.hasOwnProperty('$raw')) {\n                result['$raw'] = rawParamComputedValues;\n            }\n\n            return result;\n        } else {\n            // For consistency, absence of a \"params\" attribute is treated the same as the presence of\n            // any empty one. Otherwise component viewmodels need special code to check whether or not\n            // 'params' or 'params.$raw' is null/undefined before reading subproperties, which is annoying.\n            return { '$raw': {} };\n        }\n    }\n\n    // --------------------------------------------------------------------------------\n    // Compatibility code for older (pre-HTML5) IE browsers\n\n    if (ko.utils.ieVersion < 9) {\n        // Whenever you preregister a component, enable it as a custom element in the current document\n        ko.components['register'] = (function(originalFunction) {\n            return function(componentName) {\n                document.createElement(componentName); // Allows IE<9 to parse markup containing the custom element\n                return originalFunction.apply(this, arguments);\n            }\n        })(ko.components['register']);\n\n        // Whenever you create a document fragment, enable all preregistered component names as custom elements\n        // This is needed to make innerShiv/jQuery HTML parsing correctly handle the custom elements\n        document.createDocumentFragment = (function(originalFunction) {\n            return function() {\n                var newDocFrag = originalFunction(),\n                    allComponents = ko.components._allRegisteredComponents;\n                for (var componentName in allComponents) {\n                    if (allComponents.hasOwnProperty(componentName)) {\n                        newDocFrag.createElement(componentName);\n                    }\n                }\n                return newDocFrag;\n            };\n        })(document.createDocumentFragment);\n    }\n})();(function(undefined) {\n\n    var componentLoadingOperationUniqueId = 0;\n\n    ko.bindingHandlers['component'] = {\n        'init': function(element, valueAccessor, ignored1, ignored2, bindingContext) {\n            var currentViewModel,\n                currentLoadingOperationId,\n                disposeAssociatedComponentViewModel = function () {\n                    var currentViewModelDispose = currentViewModel && currentViewModel['dispose'];\n                    if (typeof currentViewModelDispose === 'function') {\n                        currentViewModelDispose.call(currentViewModel);\n                    }\n                    currentViewModel = null;\n                    // Any in-flight loading operation is no longer relevant, so make sure we ignore its completion\n                    currentLoadingOperationId = null;\n                },\n                originalChildNodes = ko.utils.makeArray(ko.virtualElements.childNodes(element));\n\n            ko.utils.domNodeDisposal.addDisposeCallback(element, disposeAssociatedComponentViewModel);\n\n            ko.computed(function () {\n                var value = ko.utils.unwrapObservable(valueAccessor()),\n                    componentName, componentParams;\n\n                if (typeof value === 'string') {\n                    componentName = value;\n                } else {\n                    componentName = ko.utils.unwrapObservable(value['name']);\n                    componentParams = ko.utils.unwrapObservable(value['params']);\n                }\n\n                if (!componentName) {\n                    throw new Error('No component name specified');\n                }\n\n                var loadingOperationId = currentLoadingOperationId = ++componentLoadingOperationUniqueId;\n                ko.components.get(componentName, function(componentDefinition) {\n                    // If this is not the current load operation for this element, ignore it.\n                    if (currentLoadingOperationId !== loadingOperationId) {\n                        return;\n                    }\n\n                    // Clean up previous state\n                    disposeAssociatedComponentViewModel();\n\n                    // Instantiate and bind new component. Implicitly this cleans any old DOM nodes.\n                    if (!componentDefinition) {\n                        throw new Error('Unknown component \\'' + componentName + '\\'');\n                    }\n                    cloneTemplateIntoElement(componentName, componentDefinition, element);\n                    var componentViewModel = createViewModel(componentDefinition, element, originalChildNodes, componentParams),\n                        childBindingContext = bindingContext['createChildContext'](componentViewModel, /* dataItemAlias */ undefined, function(ctx) {\n                            ctx['$component'] = componentViewModel;\n                            ctx['$componentTemplateNodes'] = originalChildNodes;\n                        });\n                    currentViewModel = componentViewModel;\n                    ko.applyBindingsToDescendants(childBindingContext, element);\n                });\n            }, null, { disposeWhenNodeIsRemoved: element });\n\n            return { 'controlsDescendantBindings': true };\n        }\n    };\n\n    ko.virtualElements.allowedBindings['component'] = true;\n\n    function cloneTemplateIntoElement(componentName, componentDefinition, element) {\n        var template = componentDefinition['template'];\n        if (!template) {\n            throw new Error('Component \\'' + componentName + '\\' has no template');\n        }\n\n        var clonedNodesArray = ko.utils.cloneNodes(template);\n        ko.virtualElements.setDomNodeChildren(element, clonedNodesArray);\n    }\n\n    function createViewModel(componentDefinition, element, originalChildNodes, componentParams) {\n        var componentViewModelFactory = componentDefinition['createViewModel'];\n        return componentViewModelFactory\n            ? componentViewModelFactory.call(componentDefinition, componentParams, { 'element': element, 'templateNodes': originalChildNodes })\n            : componentParams; // Template-only component\n    }\n\n})();\nvar attrHtmlToJavascriptMap = { 'class': 'className', 'for': 'htmlFor' };\nko.bindingHandlers['attr'] = {\n    'update': function(element, valueAccessor, allBindings) {\n        var value = ko.utils.unwrapObservable(valueAccessor()) || {};\n        ko.utils.objectForEach(value, function(attrName, attrValue) {\n            attrValue = ko.utils.unwrapObservable(attrValue);\n\n            // To cover cases like \"attr: { checked:someProp }\", we want to remove the attribute entirely\n            // when someProp is a \"no value\"-like value (strictly null, false, or undefined)\n            // (because the absence of the \"checked\" attr is how to mark an element as not checked, etc.)\n            var toRemove = (attrValue === false) || (attrValue === null) || (attrValue === undefined);\n            if (toRemove)\n                element.removeAttribute(attrName);\n\n            // In IE <= 7 and IE8 Quirks Mode, you have to use the Javascript property name instead of the\n            // HTML attribute name for certain attributes. IE8 Standards Mode supports the correct behavior,\n            // but instead of figuring out the mode, we'll just set the attribute through the Javascript\n            // property for IE <= 8.\n            if (ko.utils.ieVersion <= 8 && attrName in attrHtmlToJavascriptMap) {\n                attrName = attrHtmlToJavascriptMap[attrName];\n                if (toRemove)\n                    element.removeAttribute(attrName);\n                else\n                    element[attrName] = attrValue;\n            } else if (!toRemove) {\n                element.setAttribute(attrName, attrValue.toString());\n            }\n\n            // Treat \"name\" specially - although you can think of it as an attribute, it also needs\n            // special handling on older versions of IE (https://github.com/SteveSanderson/knockout/pull/333)\n            // Deliberately being case-sensitive here because XHTML would regard \"Name\" as a different thing\n            // entirely, and there's no strong reason to allow for such casing in HTML.\n            if (attrName === \"name\") {\n                ko.utils.setElementName(element, toRemove ? \"\" : attrValue.toString());\n            }\n        });\n    }\n};\n(function() {\n\nko.bindingHandlers['checked'] = {\n    'after': ['value', 'attr'],\n    'init': function (element, valueAccessor, allBindings) {\n        var checkedValue = ko.pureComputed(function() {\n            // Treat \"value\" like \"checkedValue\" when it is included with \"checked\" binding\n            if (allBindings['has']('checkedValue')) {\n                return ko.utils.unwrapObservable(allBindings.get('checkedValue'));\n            } else if (allBindings['has']('value')) {\n                return ko.utils.unwrapObservable(allBindings.get('value'));\n            }\n\n            return element.value;\n        });\n\n        function updateModel() {\n            // This updates the model value from the view value.\n            // It runs in response to DOM events (click) and changes in checkedValue.\n            var isChecked = element.checked,\n                elemValue = useCheckedValue ? checkedValue() : isChecked;\n\n            // When we're first setting up this computed, don't change any model state.\n            if (ko.computedContext.isInitial()) {\n                return;\n            }\n\n            // We can ignore unchecked radio buttons, because some other radio\n            // button will be getting checked, and that one can take care of updating state.\n            if (isRadio && !isChecked) {\n                return;\n            }\n\n            var modelValue = ko.dependencyDetection.ignore(valueAccessor);\n            if (valueIsArray) {\n                var writableValue = rawValueIsNonArrayObservable ? modelValue.peek() : modelValue;\n                if (oldElemValue !== elemValue) {\n                    // When we're responding to the checkedValue changing, and the element is\n                    // currently checked, replace the old elem value with the new elem value\n                    // in the model array.\n                    if (isChecked) {\n                        ko.utils.addOrRemoveItem(writableValue, elemValue, true);\n                        ko.utils.addOrRemoveItem(writableValue, oldElemValue, false);\n                    }\n\n                    oldElemValue = elemValue;\n                } else {\n                    // When we're responding to the user having checked/unchecked a checkbox,\n                    // add/remove the element value to the model array.\n                    ko.utils.addOrRemoveItem(writableValue, elemValue, isChecked);\n                }\n                if (rawValueIsNonArrayObservable && ko.isWriteableObservable(modelValue)) {\n                    modelValue(writableValue);\n                }\n            } else {\n                ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'checked', elemValue, true);\n            }\n        };\n\n        function updateView() {\n            // This updates the view value from the model value.\n            // It runs in response to changes in the bound (checked) value.\n            var modelValue = ko.utils.unwrapObservable(valueAccessor());\n\n            if (valueIsArray) {\n                // When a checkbox is bound to an array, being checked represents its value being present in that array\n                element.checked = ko.utils.arrayIndexOf(modelValue, checkedValue()) >= 0;\n            } else if (isCheckbox) {\n                // When a checkbox is bound to any other value (not an array), being checked represents the value being trueish\n                element.checked = modelValue;\n            } else {\n                // For radio buttons, being checked means that the radio button's value corresponds to the model value\n                element.checked = (checkedValue() === modelValue);\n            }\n        };\n\n        var isCheckbox = element.type == \"checkbox\",\n            isRadio = element.type == \"radio\";\n\n        // Only bind to check boxes and radio buttons\n        if (!isCheckbox && !isRadio) {\n            return;\n        }\n\n        var rawValue = valueAccessor(),\n            valueIsArray = isCheckbox && (ko.utils.unwrapObservable(rawValue) instanceof Array),\n            rawValueIsNonArrayObservable = !(valueIsArray && rawValue.push && rawValue.splice),\n            oldElemValue = valueIsArray ? checkedValue() : undefined,\n            useCheckedValue = isRadio || valueIsArray;\n\n        // IE 6 won't allow radio buttons to be selected unless they have a name\n        if (isRadio && !element.name)\n            ko.bindingHandlers['uniqueName']['init'](element, function() { return true });\n\n        // Set up two computeds to update the binding:\n\n        // The first responds to changes in the checkedValue value and to element clicks\n        ko.computed(updateModel, null, { disposeWhenNodeIsRemoved: element });\n        ko.utils.registerEventHandler(element, \"click\", updateModel);\n\n        // The second responds to changes in the model value (the one associated with the checked binding)\n        ko.computed(updateView, null, { disposeWhenNodeIsRemoved: element });\n\n        rawValue = undefined;\n    }\n};\nko.expressionRewriting.twoWayBindings['checked'] = true;\n\nko.bindingHandlers['checkedValue'] = {\n    'update': function (element, valueAccessor) {\n        element.value = ko.utils.unwrapObservable(valueAccessor());\n    }\n};\n\n})();var classesWrittenByBindingKey = '__ko__cssValue';\nko.bindingHandlers['css'] = {\n    'update': function (element, valueAccessor) {\n        var value = ko.utils.unwrapObservable(valueAccessor());\n        if (value !== null && typeof value == \"object\") {\n            ko.utils.objectForEach(value, function(className, shouldHaveClass) {\n                shouldHaveClass = ko.utils.unwrapObservable(shouldHaveClass);\n                ko.utils.toggleDomNodeCssClass(element, className, shouldHaveClass);\n            });\n        } else {\n            value = ko.utils.stringTrim(String(value || '')); // Make sure we don't try to store or set a non-string value\n            ko.utils.toggleDomNodeCssClass(element, element[classesWrittenByBindingKey], false);\n            element[classesWrittenByBindingKey] = value;\n            ko.utils.toggleDomNodeCssClass(element, value, true);\n        }\n    }\n};\nko.bindingHandlers['enable'] = {\n    'update': function (element, valueAccessor) {\n        var value = ko.utils.unwrapObservable(valueAccessor());\n        if (value && element.disabled)\n            element.removeAttribute(\"disabled\");\n        else if ((!value) && (!element.disabled))\n            element.disabled = true;\n    }\n};\n\nko.bindingHandlers['disable'] = {\n    'update': function (element, valueAccessor) {\n        ko.bindingHandlers['enable']['update'](element, function() { return !ko.utils.unwrapObservable(valueAccessor()) });\n    }\n};\n// For certain common events (currently just 'click'), allow a simplified data-binding syntax\n// e.g. click:handler instead of the usual full-length event:{click:handler}\nfunction makeEventHandlerShortcut(eventName) {\n    ko.bindingHandlers[eventName] = {\n        'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n            var newValueAccessor = function () {\n                var result = {};\n                result[eventName] = valueAccessor();\n                return result;\n            };\n            return ko.bindingHandlers['event']['init'].call(this, element, newValueAccessor, allBindings, viewModel, bindingContext);\n        }\n    }\n}\n\nko.bindingHandlers['event'] = {\n    'init' : function (element, valueAccessor, allBindings, viewModel, bindingContext) {\n        var eventsToHandle = valueAccessor() || {};\n        ko.utils.objectForEach(eventsToHandle, function(eventName) {\n            if (typeof eventName == \"string\") {\n                ko.utils.registerEventHandler(element, eventName, function (event) {\n                    var handlerReturnValue;\n                    var handlerFunction = valueAccessor()[eventName];\n                    if (!handlerFunction)\n                        return;\n\n                    try {\n                        // Take all the event args, and prefix with the viewmodel\n                        var argsForHandler = ko.utils.makeArray(arguments);\n                        viewModel = bindingContext['$data'];\n                        argsForHandler.unshift(viewModel);\n                        handlerReturnValue = handlerFunction.apply(viewModel, argsForHandler);\n                    } finally {\n                        if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.\n                            if (event.preventDefault)\n                                event.preventDefault();\n                            else\n                                event.returnValue = false;\n                        }\n                    }\n\n                    var bubble = allBindings.get(eventName + 'Bubble') !== false;\n                    if (!bubble) {\n                        event.cancelBubble = true;\n                        if (event.stopPropagation)\n                            event.stopPropagation();\n                    }\n                });\n            }\n        });\n    }\n};\n// \"foreach: someExpression\" is equivalent to \"template: { foreach: someExpression }\"\n// \"foreach: { data: someExpression, afterAdd: myfn }\" is equivalent to \"template: { foreach: someExpression, afterAdd: myfn }\"\nko.bindingHandlers['foreach'] = {\n    makeTemplateValueAccessor: function(valueAccessor) {\n        return function() {\n            var modelValue = valueAccessor(),\n                unwrappedValue = ko.utils.peekObservable(modelValue);    // Unwrap without setting a dependency here\n\n            // If unwrappedValue is the array, pass in the wrapped value on its own\n            // The value will be unwrapped and tracked within the template binding\n            // (See https://github.com/SteveSanderson/knockout/issues/523)\n            if ((!unwrappedValue) || typeof unwrappedValue.length == \"number\")\n                return { 'foreach': modelValue, 'templateEngine': ko.nativeTemplateEngine.instance };\n\n            // If unwrappedValue.data is the array, preserve all relevant options and unwrap again value so we get updates\n            ko.utils.unwrapObservable(modelValue);\n            return {\n                'foreach': unwrappedValue['data'],\n                'as': unwrappedValue['as'],\n                'includeDestroyed': unwrappedValue['includeDestroyed'],\n                'afterAdd': unwrappedValue['afterAdd'],\n                'beforeRemove': unwrappedValue['beforeRemove'],\n                'afterRender': unwrappedValue['afterRender'],\n                'beforeMove': unwrappedValue['beforeMove'],\n                'afterMove': unwrappedValue['afterMove'],\n                'templateEngine': ko.nativeTemplateEngine.instance\n            };\n        };\n    },\n    'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor));\n    },\n    'update': function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor), allBindings, viewModel, bindingContext);\n    }\n};\nko.expressionRewriting.bindingRewriteValidators['foreach'] = false; // Can't rewrite control flow bindings\nko.virtualElements.allowedBindings['foreach'] = true;\nvar hasfocusUpdatingProperty = '__ko_hasfocusUpdating';\nvar hasfocusLastValue = '__ko_hasfocusLastValue';\nko.bindingHandlers['hasfocus'] = {\n    'init': function(element, valueAccessor, allBindings) {\n        var handleElementFocusChange = function(isFocused) {\n            // Where possible, ignore which event was raised and determine focus state using activeElement,\n            // as this avoids phantom focus/blur events raised when changing tabs in modern browsers.\n            // However, not all KO-targeted browsers (Firefox 2) support activeElement. For those browsers,\n            // prevent a loss of focus when changing tabs/windows by setting a flag that prevents hasfocus\n            // from calling 'blur()' on the element when it loses focus.\n            // Discussion at https://github.com/SteveSanderson/knockout/pull/352\n            element[hasfocusUpdatingProperty] = true;\n            var ownerDoc = element.ownerDocument;\n            if (\"activeElement\" in ownerDoc) {\n                var active;\n                try {\n                    active = ownerDoc.activeElement;\n                } catch(e) {\n                    // IE9 throws if you access activeElement during page load (see issue #703)\n                    active = ownerDoc.body;\n                }\n                isFocused = (active === element);\n            }\n            var modelValue = valueAccessor();\n            ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'hasfocus', isFocused, true);\n\n            //cache the latest value, so we can avoid unnecessarily calling focus/blur in the update function\n            element[hasfocusLastValue] = isFocused;\n            element[hasfocusUpdatingProperty] = false;\n        };\n        var handleElementFocusIn = handleElementFocusChange.bind(null, true);\n        var handleElementFocusOut = handleElementFocusChange.bind(null, false);\n\n        ko.utils.registerEventHandler(element, \"focus\", handleElementFocusIn);\n        ko.utils.registerEventHandler(element, \"focusin\", handleElementFocusIn); // For IE\n        ko.utils.registerEventHandler(element, \"blur\",  handleElementFocusOut);\n        ko.utils.registerEventHandler(element, \"focusout\",  handleElementFocusOut); // For IE\n    },\n    'update': function(element, valueAccessor) {\n        var value = !!ko.utils.unwrapObservable(valueAccessor());\n\n        if (!element[hasfocusUpdatingProperty] && element[hasfocusLastValue] !== value) {\n            value ? element.focus() : element.blur();\n\n            // In IE, the blur method doesn't always cause the element to lose focus (for example, if the window is not in focus).\n            // Setting focus to the body element does seem to be reliable in IE, but should only be used if we know that the current\n            // element was focused already.\n            if (!value && element[hasfocusLastValue]) {\n                element.ownerDocument.body.focus();\n            }\n\n            // For IE, which doesn't reliably fire \"focus\" or \"blur\" events synchronously\n            ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, value ? \"focusin\" : \"focusout\"]);\n        }\n    }\n};\nko.expressionRewriting.twoWayBindings['hasfocus'] = true;\n\nko.bindingHandlers['hasFocus'] = ko.bindingHandlers['hasfocus']; // Make \"hasFocus\" an alias\nko.expressionRewriting.twoWayBindings['hasFocus'] = true;\nko.bindingHandlers['html'] = {\n    'init': function() {\n        // Prevent binding on the dynamically-injected HTML (as developers are unlikely to expect that, and it has security implications)\n        return { 'controlsDescendantBindings': true };\n    },\n    'update': function (element, valueAccessor) {\n        // setHtml will unwrap the value if needed\n        ko.utils.setHtml(element, valueAccessor());\n    }\n};\n// Makes a binding like with or if\nfunction makeWithIfBinding(bindingKey, isWith, isNot, makeContextCallback) {\n    ko.bindingHandlers[bindingKey] = {\n        'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n            var didDisplayOnLastUpdate,\n                savedNodes;\n            ko.computed(function() {\n                var rawValue = valueAccessor(),\n                    dataValue = ko.utils.unwrapObservable(rawValue),\n                    shouldDisplay = !isNot !== !dataValue, // equivalent to isNot ? !dataValue : !!dataValue\n                    isFirstRender = !savedNodes,\n                    needsRefresh = isFirstRender || isWith || (shouldDisplay !== didDisplayOnLastUpdate);\n\n                if (needsRefresh) {\n                    // Save a copy of the inner nodes on the initial update, but only if we have dependencies.\n                    if (isFirstRender && ko.computedContext.getDependenciesCount()) {\n                        savedNodes = ko.utils.cloneNodes(ko.virtualElements.childNodes(element), true /* shouldCleanNodes */);\n                    }\n\n                    if (shouldDisplay) {\n                        if (!isFirstRender) {\n                            ko.virtualElements.setDomNodeChildren(element, ko.utils.cloneNodes(savedNodes));\n                        }\n                        ko.applyBindingsToDescendants(makeContextCallback ? makeContextCallback(bindingContext, rawValue) : bindingContext, element);\n                    } else {\n                        ko.virtualElements.emptyNode(element);\n                    }\n\n                    didDisplayOnLastUpdate = shouldDisplay;\n                }\n            }, null, { disposeWhenNodeIsRemoved: element });\n            return { 'controlsDescendantBindings': true };\n        }\n    };\n    ko.expressionRewriting.bindingRewriteValidators[bindingKey] = false; // Can't rewrite control flow bindings\n    ko.virtualElements.allowedBindings[bindingKey] = true;\n}\n\n// Construct the actual binding handlers\nmakeWithIfBinding('if');\nmakeWithIfBinding('ifnot', false /* isWith */, true /* isNot */);\nmakeWithIfBinding('with', true /* isWith */, false /* isNot */,\n    function(bindingContext, dataValue) {\n        return bindingContext.createStaticChildContext(dataValue);\n    }\n);\nvar captionPlaceholder = {};\nko.bindingHandlers['options'] = {\n    'init': function(element) {\n        if (ko.utils.tagNameLower(element) !== \"select\")\n            throw new Error(\"options binding applies only to SELECT elements\");\n\n        // Remove all existing <option>s.\n        while (element.length > 0) {\n            element.remove(0);\n        }\n\n        // Ensures that the binding processor doesn't try to bind the options\n        return { 'controlsDescendantBindings': true };\n    },\n    'update': function (element, valueAccessor, allBindings) {\n        function selectedOptions() {\n            return ko.utils.arrayFilter(element.options, function (node) { return node.selected; });\n        }\n\n        var selectWasPreviouslyEmpty = element.length == 0,\n            multiple = element.multiple,\n            previousScrollTop = (!selectWasPreviouslyEmpty && multiple) ? element.scrollTop : null,\n            unwrappedArray = ko.utils.unwrapObservable(valueAccessor()),\n            valueAllowUnset = allBindings.get('valueAllowUnset') && allBindings['has']('value'),\n            includeDestroyed = allBindings.get('optionsIncludeDestroyed'),\n            arrayToDomNodeChildrenOptions = {},\n            captionValue,\n            filteredArray,\n            previousSelectedValues = [];\n\n        if (!valueAllowUnset) {\n            if (multiple) {\n                previousSelectedValues = ko.utils.arrayMap(selectedOptions(), ko.selectExtensions.readValue);\n            } else if (element.selectedIndex >= 0) {\n                previousSelectedValues.push(ko.selectExtensions.readValue(element.options[element.selectedIndex]));\n            }\n        }\n\n        if (unwrappedArray) {\n            if (typeof unwrappedArray.length == \"undefined\") // Coerce single value into array\n                unwrappedArray = [unwrappedArray];\n\n            // Filter out any entries marked as destroyed\n            filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {\n                return includeDestroyed || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);\n            });\n\n            // If caption is included, add it to the array\n            if (allBindings['has']('optionsCaption')) {\n                captionValue = ko.utils.unwrapObservable(allBindings.get('optionsCaption'));\n                // If caption value is null or undefined, don't show a caption\n                if (captionValue !== null && captionValue !== undefined) {\n                    filteredArray.unshift(captionPlaceholder);\n                }\n            }\n        } else {\n            // If a falsy value is provided (e.g. null), we'll simply empty the select element\n        }\n\n        function applyToObject(object, predicate, defaultValue) {\n            var predicateType = typeof predicate;\n            if (predicateType == \"function\")    // Given a function; run it against the data value\n                return predicate(object);\n            else if (predicateType == \"string\") // Given a string; treat it as a property name on the data value\n                return object[predicate];\n            else                                // Given no optionsText arg; use the data value itself\n                return defaultValue;\n        }\n\n        // The following functions can run at two different times:\n        // The first is when the whole array is being updated directly from this binding handler.\n        // The second is when an observable value for a specific array entry is updated.\n        // oldOptions will be empty in the first case, but will be filled with the previously generated option in the second.\n        var itemUpdate = false;\n        function optionForArrayItem(arrayEntry, index, oldOptions) {\n            if (oldOptions.length) {\n                previousSelectedValues = !valueAllowUnset && oldOptions[0].selected ? [ ko.selectExtensions.readValue(oldOptions[0]) ] : [];\n                itemUpdate = true;\n            }\n            var option = element.ownerDocument.createElement(\"option\");\n            if (arrayEntry === captionPlaceholder) {\n                ko.utils.setTextContent(option, allBindings.get('optionsCaption'));\n                ko.selectExtensions.writeValue(option, undefined);\n            } else {\n                // Apply a value to the option element\n                var optionValue = applyToObject(arrayEntry, allBindings.get('optionsValue'), arrayEntry);\n                ko.selectExtensions.writeValue(option, ko.utils.unwrapObservable(optionValue));\n\n                // Apply some text to the option element\n                var optionText = applyToObject(arrayEntry, allBindings.get('optionsText'), optionValue);\n                ko.utils.setTextContent(option, optionText);\n            }\n            return [option];\n        }\n\n        // By using a beforeRemove callback, we delay the removal until after new items are added. This fixes a selection\n        // problem in IE<=8 and Firefox. See https://github.com/knockout/knockout/issues/1208\n        arrayToDomNodeChildrenOptions['beforeRemove'] =\n            function (option) {\n                element.removeChild(option);\n            };\n\n        function setSelectionCallback(arrayEntry, newOptions) {\n            if (itemUpdate && valueAllowUnset) {\n                // The model value is authoritative, so make sure its value is the one selected\n                // There is no need to use dependencyDetection.ignore since setDomNodeChildrenFromArrayMapping does so already.\n                ko.selectExtensions.writeValue(element, ko.utils.unwrapObservable(allBindings.get('value')), true /* allowUnset */);\n            } else if (previousSelectedValues.length) {\n                // IE6 doesn't like us to assign selection to OPTION nodes before they're added to the document.\n                // That's why we first added them without selection. Now it's time to set the selection.\n                var isSelected = ko.utils.arrayIndexOf(previousSelectedValues, ko.selectExtensions.readValue(newOptions[0])) >= 0;\n                ko.utils.setOptionNodeSelectionState(newOptions[0], isSelected);\n\n                // If this option was changed from being selected during a single-item update, notify the change\n                if (itemUpdate && !isSelected) {\n                    ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, \"change\"]);\n                }\n            }\n        }\n\n        var callback = setSelectionCallback;\n        if (allBindings['has']('optionsAfterRender') && typeof allBindings.get('optionsAfterRender') == \"function\") {\n            callback = function(arrayEntry, newOptions) {\n                setSelectionCallback(arrayEntry, newOptions);\n                ko.dependencyDetection.ignore(allBindings.get('optionsAfterRender'), null, [newOptions[0], arrayEntry !== captionPlaceholder ? arrayEntry : undefined]);\n            }\n        }\n\n        ko.utils.setDomNodeChildrenFromArrayMapping(element, filteredArray, optionForArrayItem, arrayToDomNodeChildrenOptions, callback);\n\n        ko.dependencyDetection.ignore(function () {\n            if (valueAllowUnset) {\n                // The model value is authoritative, so make sure its value is the one selected\n                ko.selectExtensions.writeValue(element, ko.utils.unwrapObservable(allBindings.get('value')), true /* allowUnset */);\n            } else {\n                // Determine if the selection has changed as a result of updating the options list\n                var selectionChanged;\n                if (multiple) {\n                    // For a multiple-select box, compare the new selection count to the previous one\n                    // But if nothing was selected before, the selection can't have changed\n                    selectionChanged = previousSelectedValues.length && selectedOptions().length < previousSelectedValues.length;\n                } else {\n                    // For a single-select box, compare the current value to the previous value\n                    // But if nothing was selected before or nothing is selected now, just look for a change in selection\n                    selectionChanged = (previousSelectedValues.length && element.selectedIndex >= 0)\n                        ? (ko.selectExtensions.readValue(element.options[element.selectedIndex]) !== previousSelectedValues[0])\n                        : (previousSelectedValues.length || element.selectedIndex >= 0);\n                }\n\n                // Ensure consistency between model value and selected option.\n                // If the dropdown was changed so that selection is no longer the same,\n                // notify the value or selectedOptions binding.\n                if (selectionChanged) {\n                    ko.utils.triggerEvent(element, \"change\");\n                }\n            }\n        });\n\n        // Workaround for IE bug\n        ko.utils.ensureSelectElementIsRenderedCorrectly(element);\n\n        if (previousScrollTop && Math.abs(previousScrollTop - element.scrollTop) > 20)\n            element.scrollTop = previousScrollTop;\n    }\n};\nko.bindingHandlers['options'].optionValueDomDataKey = ko.utils.domData.nextKey();\nko.bindingHandlers['selectedOptions'] = {\n    'after': ['options', 'foreach'],\n    'init': function (element, valueAccessor, allBindings) {\n        ko.utils.registerEventHandler(element, \"change\", function () {\n            var value = valueAccessor(), valueToWrite = [];\n            ko.utils.arrayForEach(element.getElementsByTagName(\"option\"), function(node) {\n                if (node.selected)\n                    valueToWrite.push(ko.selectExtensions.readValue(node));\n            });\n            ko.expressionRewriting.writeValueToProperty(value, allBindings, 'selectedOptions', valueToWrite);\n        });\n    },\n    'update': function (element, valueAccessor) {\n        if (ko.utils.tagNameLower(element) != \"select\")\n            throw new Error(\"values binding applies only to SELECT elements\");\n\n        var newValue = ko.utils.unwrapObservable(valueAccessor()),\n            previousScrollTop = element.scrollTop;\n\n        if (newValue && typeof newValue.length == \"number\") {\n            ko.utils.arrayForEach(element.getElementsByTagName(\"option\"), function(node) {\n                var isSelected = ko.utils.arrayIndexOf(newValue, ko.selectExtensions.readValue(node)) >= 0;\n                if (node.selected != isSelected) {      // This check prevents flashing of the select element in IE\n                    ko.utils.setOptionNodeSelectionState(node, isSelected);\n                }\n            });\n        }\n\n        element.scrollTop = previousScrollTop;\n    }\n};\nko.expressionRewriting.twoWayBindings['selectedOptions'] = true;\nko.bindingHandlers['style'] = {\n    'update': function (element, valueAccessor) {\n        var value = ko.utils.unwrapObservable(valueAccessor() || {});\n        ko.utils.objectForEach(value, function(styleName, styleValue) {\n            styleValue = ko.utils.unwrapObservable(styleValue);\n\n            if (styleValue === null || styleValue === undefined || styleValue === false) {\n                // Empty string removes the value, whereas null/undefined have no effect\n                styleValue = \"\";\n            }\n\n            element.style[styleName] = styleValue;\n        });\n    }\n};\nko.bindingHandlers['submit'] = {\n    'init': function (element, valueAccessor, allBindings, viewModel, bindingContext) {\n        if (typeof valueAccessor() != \"function\")\n            throw new Error(\"The value for a submit binding must be a function\");\n        ko.utils.registerEventHandler(element, \"submit\", function (event) {\n            var handlerReturnValue;\n            var value = valueAccessor();\n            try { handlerReturnValue = value.call(bindingContext['$data'], element); }\n            finally {\n                if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.\n                    if (event.preventDefault)\n                        event.preventDefault();\n                    else\n                        event.returnValue = false;\n                }\n            }\n        });\n    }\n};\nko.bindingHandlers['text'] = {\n    'init': function() {\n        // Prevent binding on the dynamically-injected text node (as developers are unlikely to expect that, and it has security implications).\n        // It should also make things faster, as we no longer have to consider whether the text node might be bindable.\n        return { 'controlsDescendantBindings': true };\n    },\n    'update': function (element, valueAccessor) {\n        ko.utils.setTextContent(element, valueAccessor());\n    }\n};\nko.virtualElements.allowedBindings['text'] = true;\n(function () {\n\nif (window && window.navigator) {\n    var parseVersion = function (matches) {\n        if (matches) {\n            return parseFloat(matches[1]);\n        }\n    };\n\n    // Detect various browser versions because some old versions don't fully support the 'input' event\n    var operaVersion = window.opera && window.opera.version && parseInt(window.opera.version()),\n        userAgent = window.navigator.userAgent,\n        safariVersion = parseVersion(userAgent.match(/^(?:(?!chrome).)*version\\/([^ ]*) safari/i)),\n        firefoxVersion = parseVersion(userAgent.match(/Firefox\\/([^ ]*)/));\n}\n\n// IE 8 and 9 have bugs that prevent the normal events from firing when the value changes.\n// But it does fire the 'selectionchange' event on many of those, presumably because the\n// cursor is moving and that counts as the selection changing. The 'selectionchange' event is\n// fired at the document level only and doesn't directly indicate which element changed. We\n// set up just one event handler for the document and use 'activeElement' to determine which\n// element was changed.\nif (ko.utils.ieVersion < 10) {\n    var selectionChangeRegisteredName = ko.utils.domData.nextKey(),\n        selectionChangeHandlerName = ko.utils.domData.nextKey();\n    var selectionChangeHandler = function(event) {\n        var target = this.activeElement,\n            handler = target && ko.utils.domData.get(target, selectionChangeHandlerName);\n        if (handler) {\n            handler(event);\n        }\n    };\n    var registerForSelectionChangeEvent = function (element, handler) {\n        var ownerDoc = element.ownerDocument;\n        if (!ko.utils.domData.get(ownerDoc, selectionChangeRegisteredName)) {\n            ko.utils.domData.set(ownerDoc, selectionChangeRegisteredName, true);\n            ko.utils.registerEventHandler(ownerDoc, 'selectionchange', selectionChangeHandler);\n        }\n        ko.utils.domData.set(element, selectionChangeHandlerName, handler);\n    };\n}\n\nko.bindingHandlers['textInput'] = {\n    'init': function (element, valueAccessor, allBindings) {\n\n        var previousElementValue = element.value,\n            timeoutHandle,\n            elementValueBeforeEvent;\n\n        var updateModel = function (event) {\n            clearTimeout(timeoutHandle);\n            elementValueBeforeEvent = timeoutHandle = undefined;\n\n            var elementValue = element.value;\n            if (previousElementValue !== elementValue) {\n                // Provide a way for tests to know exactly which event was processed\n                if (DEBUG && event) element['_ko_textInputProcessedEvent'] = event.type;\n                previousElementValue = elementValue;\n                ko.expressionRewriting.writeValueToProperty(valueAccessor(), allBindings, 'textInput', elementValue);\n            }\n        };\n\n        var deferUpdateModel = function (event) {\n            if (!timeoutHandle) {\n                // The elementValueBeforeEvent variable is set *only* during the brief gap between an\n                // event firing and the updateModel function running. This allows us to ignore model\n                // updates that are from the previous state of the element, usually due to techniques\n                // such as rateLimit. Such updates, if not ignored, can cause keystrokes to be lost.\n                elementValueBeforeEvent = element.value;\n                var handler = DEBUG ? updateModel.bind(element, {type: event.type}) : updateModel;\n                timeoutHandle = ko.utils.setTimeout(handler, 4);\n            }\n        };\n\n        // IE9 will mess up the DOM if you handle events synchronously which results in DOM changes (such as other bindings);\n        // so we'll make sure all updates are asynchronous\n        var ieUpdateModel = ko.utils.ieVersion == 9 ? deferUpdateModel : updateModel;\n\n        var updateView = function () {\n            var modelValue = ko.utils.unwrapObservable(valueAccessor());\n\n            if (modelValue === null || modelValue === undefined) {\n                modelValue = '';\n            }\n\n            if (elementValueBeforeEvent !== undefined && modelValue === elementValueBeforeEvent) {\n                ko.utils.setTimeout(updateView, 4);\n                return;\n            }\n\n            // Update the element only if the element and model are different. On some browsers, updating the value\n            // will move the cursor to the end of the input, which would be bad while the user is typing.\n            if (element.value !== modelValue) {\n                previousElementValue = modelValue;  // Make sure we ignore events (propertychange) that result from updating the value\n                element.value = modelValue;\n            }\n        };\n\n        var onEvent = function (event, handler) {\n            ko.utils.registerEventHandler(element, event, handler);\n        };\n\n        if (DEBUG && ko.bindingHandlers['textInput']['_forceUpdateOn']) {\n            // Provide a way for tests to specify exactly which events are bound\n            ko.utils.arrayForEach(ko.bindingHandlers['textInput']['_forceUpdateOn'], function(eventName) {\n                if (eventName.slice(0,5) == 'after') {\n                    onEvent(eventName.slice(5), deferUpdateModel);\n                } else {\n                    onEvent(eventName, updateModel);\n                }\n            });\n        } else {\n            if (ko.utils.ieVersion < 10) {\n                // Internet Explorer <= 8 doesn't support the 'input' event, but does include 'propertychange' that fires whenever\n                // any property of an element changes. Unlike 'input', it also fires if a property is changed from JavaScript code,\n                // but that's an acceptable compromise for this binding. IE 9 does support 'input', but since it doesn't fire it\n                // when using autocomplete, we'll use 'propertychange' for it also.\n                onEvent('propertychange', function(event) {\n                    if (event.propertyName === 'value') {\n                        ieUpdateModel(event);\n                    }\n                });\n\n                if (ko.utils.ieVersion == 8) {\n                    // IE 8 has a bug where it fails to fire 'propertychange' on the first update following a value change from\n                    // JavaScript code. It also doesn't fire if you clear the entire value. To fix this, we bind to the following\n                    // events too.\n                    onEvent('keyup', updateModel);      // A single keystoke\n                    onEvent('keydown', updateModel);    // The first character when a key is held down\n                }\n                if (ko.utils.ieVersion >= 8) {\n                    // Internet Explorer 9 doesn't fire the 'input' event when deleting text, including using\n                    // the backspace, delete, or ctrl-x keys, clicking the 'x' to clear the input, dragging text\n                    // out of the field, and cutting or deleting text using the context menu. 'selectionchange'\n                    // can detect all of those except dragging text out of the field, for which we use 'dragend'.\n                    // These are also needed in IE8 because of the bug described above.\n                    registerForSelectionChangeEvent(element, ieUpdateModel);  // 'selectionchange' covers cut, paste, drop, delete, etc.\n                    onEvent('dragend', deferUpdateModel);\n                }\n            } else {\n                // All other supported browsers support the 'input' event, which fires whenever the content of the element is changed\n                // through the user interface.\n                onEvent('input', updateModel);\n\n                if (safariVersion < 5 && ko.utils.tagNameLower(element) === \"textarea\") {\n                    // Safari <5 doesn't fire the 'input' event for <textarea> elements (it does fire 'textInput'\n                    // but only when typing). So we'll just catch as much as we can with keydown, cut, and paste.\n                    onEvent('keydown', deferUpdateModel);\n                    onEvent('paste', deferUpdateModel);\n                    onEvent('cut', deferUpdateModel);\n                } else if (operaVersion < 11) {\n                    // Opera 10 doesn't always fire the 'input' event for cut, paste, undo & drop operations.\n                    // We can try to catch some of those using 'keydown'.\n                    onEvent('keydown', deferUpdateModel);\n                } else if (firefoxVersion < 4.0) {\n                    // Firefox <= 3.6 doesn't fire the 'input' event when text is filled in through autocomplete\n                    onEvent('DOMAutoComplete', updateModel);\n\n                    // Firefox <=3.5 doesn't fire the 'input' event when text is dropped into the input.\n                    onEvent('dragdrop', updateModel);       // <3.5\n                    onEvent('drop', updateModel);           // 3.5\n                }\n            }\n        }\n\n        // Bind to the change event so that we can catch programmatic updates of the value that fire this event.\n        onEvent('change', updateModel);\n\n        ko.computed(updateView, null, { disposeWhenNodeIsRemoved: element });\n    }\n};\nko.expressionRewriting.twoWayBindings['textInput'] = true;\n\n// textinput is an alias for textInput\nko.bindingHandlers['textinput'] = {\n    // preprocess is the only way to set up a full alias\n    'preprocess': function (value, name, addBinding) {\n        addBinding('textInput', value);\n    }\n};\n\n})();ko.bindingHandlers['uniqueName'] = {\n    'init': function (element, valueAccessor) {\n        if (valueAccessor()) {\n            var name = \"ko_unique_\" + (++ko.bindingHandlers['uniqueName'].currentIndex);\n            ko.utils.setElementName(element, name);\n        }\n    }\n};\nko.bindingHandlers['uniqueName'].currentIndex = 0;\nko.bindingHandlers['value'] = {\n    'after': ['options', 'foreach'],\n    'init': function (element, valueAccessor, allBindings) {\n        // If the value binding is placed on a radio/checkbox, then just pass through to checkedValue and quit\n        if (element.tagName.toLowerCase() == \"input\" && (element.type == \"checkbox\" || element.type == \"radio\")) {\n            ko.applyBindingAccessorsToNode(element, { 'checkedValue': valueAccessor });\n            return;\n        }\n\n        // Always catch \"change\" event; possibly other events too if asked\n        var eventsToCatch = [\"change\"];\n        var requestedEventsToCatch = allBindings.get(\"valueUpdate\");\n        var propertyChangedFired = false;\n        var elementValueBeforeEvent = null;\n\n        if (requestedEventsToCatch) {\n            if (typeof requestedEventsToCatch == \"string\") // Allow both individual event names, and arrays of event names\n                requestedEventsToCatch = [requestedEventsToCatch];\n            ko.utils.arrayPushAll(eventsToCatch, requestedEventsToCatch);\n            eventsToCatch = ko.utils.arrayGetDistinctValues(eventsToCatch);\n        }\n\n        var valueUpdateHandler = function() {\n            elementValueBeforeEvent = null;\n            propertyChangedFired = false;\n            var modelValue = valueAccessor();\n            var elementValue = ko.selectExtensions.readValue(element);\n            ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'value', elementValue);\n        }\n\n        // Workaround for https://github.com/SteveSanderson/knockout/issues/122\n        // IE doesn't fire \"change\" events on textboxes if the user selects a value from its autocomplete list\n        var ieAutoCompleteHackNeeded = ko.utils.ieVersion && element.tagName.toLowerCase() == \"input\" && element.type == \"text\"\n                                       && element.autocomplete != \"off\" && (!element.form || element.form.autocomplete != \"off\");\n        if (ieAutoCompleteHackNeeded && ko.utils.arrayIndexOf(eventsToCatch, \"propertychange\") == -1) {\n            ko.utils.registerEventHandler(element, \"propertychange\", function () { propertyChangedFired = true });\n            ko.utils.registerEventHandler(element, \"focus\", function () { propertyChangedFired = false });\n            ko.utils.registerEventHandler(element, \"blur\", function() {\n                if (propertyChangedFired) {\n                    valueUpdateHandler();\n                }\n            });\n        }\n\n        ko.utils.arrayForEach(eventsToCatch, function(eventName) {\n            // The syntax \"after<eventname>\" means \"run the handler asynchronously after the event\"\n            // This is useful, for example, to catch \"keydown\" events after the browser has updated the control\n            // (otherwise, ko.selectExtensions.readValue(this) will receive the control's value *before* the key event)\n            var handler = valueUpdateHandler;\n            if (ko.utils.stringStartsWith(eventName, \"after\")) {\n                handler = function() {\n                    // The elementValueBeforeEvent variable is non-null *only* during the brief gap between\n                    // a keyX event firing and the valueUpdateHandler running, which is scheduled to happen\n                    // at the earliest asynchronous opportunity. We store this temporary information so that\n                    // if, between keyX and valueUpdateHandler, the underlying model value changes separately,\n                    // we can overwrite that model value change with the value the user just typed. Otherwise,\n                    // techniques like rateLimit can trigger model changes at critical moments that will\n                    // override the user's inputs, causing keystrokes to be lost.\n                    elementValueBeforeEvent = ko.selectExtensions.readValue(element);\n                    ko.utils.setTimeout(valueUpdateHandler, 0);\n                };\n                eventName = eventName.substring(\"after\".length);\n            }\n            ko.utils.registerEventHandler(element, eventName, handler);\n        });\n\n        var updateFromModel = function () {\n            var newValue = ko.utils.unwrapObservable(valueAccessor());\n            var elementValue = ko.selectExtensions.readValue(element);\n\n            if (elementValueBeforeEvent !== null && newValue === elementValueBeforeEvent) {\n                ko.utils.setTimeout(updateFromModel, 0);\n                return;\n            }\n\n            var valueHasChanged = (newValue !== elementValue);\n\n            if (valueHasChanged) {\n                if (ko.utils.tagNameLower(element) === \"select\") {\n                    var allowUnset = allBindings.get('valueAllowUnset');\n                    var applyValueAction = function () {\n                        ko.selectExtensions.writeValue(element, newValue, allowUnset);\n                    };\n                    applyValueAction();\n\n                    if (!allowUnset && newValue !== ko.selectExtensions.readValue(element)) {\n                        // If you try to set a model value that can't be represented in an already-populated dropdown, reject that change,\n                        // because you're not allowed to have a model value that disagrees with a visible UI selection.\n                        ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, \"change\"]);\n                    } else {\n                        // Workaround for IE6 bug: It won't reliably apply values to SELECT nodes during the same execution thread\n                        // right after you've changed the set of OPTION nodes on it. So for that node type, we'll schedule a second thread\n                        // to apply the value as well.\n                        ko.utils.setTimeout(applyValueAction, 0);\n                    }\n                } else {\n                    ko.selectExtensions.writeValue(element, newValue);\n                }\n            }\n        };\n\n        ko.computed(updateFromModel, null, { disposeWhenNodeIsRemoved: element });\n    },\n    'update': function() {} // Keep for backwards compatibility with code that may have wrapped value binding\n};\nko.expressionRewriting.twoWayBindings['value'] = true;\nko.bindingHandlers['visible'] = {\n    'update': function (element, valueAccessor) {\n        var value = ko.utils.unwrapObservable(valueAccessor());\n        var isCurrentlyVisible = !(element.style.display == \"none\");\n        if (value && !isCurrentlyVisible)\n            element.style.display = \"\";\n        else if ((!value) && isCurrentlyVisible)\n            element.style.display = \"none\";\n    }\n};\n// 'click' is just a shorthand for the usual full-length event:{click:handler}\nmakeEventHandlerShortcut('click');\n// If you want to make a custom template engine,\n//\n// [1] Inherit from this class (like ko.nativeTemplateEngine does)\n// [2] Override 'renderTemplateSource', supplying a function with this signature:\n//\n//        function (templateSource, bindingContext, options) {\n//            // - templateSource.text() is the text of the template you should render\n//            // - bindingContext.$data is the data you should pass into the template\n//            //   - you might also want to make bindingContext.$parent, bindingContext.$parents,\n//            //     and bindingContext.$root available in the template too\n//            // - options gives you access to any other properties set on \"data-bind: { template: options }\"\n//            // - templateDocument is the document object of the template\n//            //\n//            // Return value: an array of DOM nodes\n//        }\n//\n// [3] Override 'createJavaScriptEvaluatorBlock', supplying a function with this signature:\n//\n//        function (script) {\n//            // Return value: Whatever syntax means \"Evaluate the JavaScript statement 'script' and output the result\"\n//            //               For example, the jquery.tmpl template engine converts 'someScript' to '${ someScript }'\n//        }\n//\n//     This is only necessary if you want to allow data-bind attributes to reference arbitrary template variables.\n//     If you don't want to allow that, you can set the property 'allowTemplateRewriting' to false (like ko.nativeTemplateEngine does)\n//     and then you don't need to override 'createJavaScriptEvaluatorBlock'.\n\nko.templateEngine = function () { };\n\nko.templateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options, templateDocument) {\n    throw new Error(\"Override renderTemplateSource\");\n};\n\nko.templateEngine.prototype['createJavaScriptEvaluatorBlock'] = function (script) {\n    throw new Error(\"Override createJavaScriptEvaluatorBlock\");\n};\n\nko.templateEngine.prototype['makeTemplateSource'] = function(template, templateDocument) {\n    // Named template\n    if (typeof template == \"string\") {\n        templateDocument = templateDocument || document;\n        var elem = templateDocument.getElementById(template);\n        if (!elem)\n            throw new Error(\"Cannot find template with ID \" + template);\n        return new ko.templateSources.domElement(elem);\n    } else if ((template.nodeType == 1) || (template.nodeType == 8)) {\n        // Anonymous template\n        return new ko.templateSources.anonymousTemplate(template);\n    } else\n        throw new Error(\"Unknown template type: \" + template);\n};\n\nko.templateEngine.prototype['renderTemplate'] = function (template, bindingContext, options, templateDocument) {\n    var templateSource = this['makeTemplateSource'](template, templateDocument);\n    return this['renderTemplateSource'](templateSource, bindingContext, options, templateDocument);\n};\n\nko.templateEngine.prototype['isTemplateRewritten'] = function (template, templateDocument) {\n    // Skip rewriting if requested\n    if (this['allowTemplateRewriting'] === false)\n        return true;\n    return this['makeTemplateSource'](template, templateDocument)['data'](\"isRewritten\");\n};\n\nko.templateEngine.prototype['rewriteTemplate'] = function (template, rewriterCallback, templateDocument) {\n    var templateSource = this['makeTemplateSource'](template, templateDocument);\n    var rewritten = rewriterCallback(templateSource['text']());\n    templateSource['text'](rewritten);\n    templateSource['data'](\"isRewritten\", true);\n};\n\nko.exportSymbol('templateEngine', ko.templateEngine);\n\nko.templateRewriting = (function () {\n    var memoizeDataBindingAttributeSyntaxRegex = /(<([a-z]+\\d*)(?:\\s+(?!data-bind\\s*=\\s*)[a-z0-9\\-]+(?:=(?:\\\"[^\\\"]*\\\"|\\'[^\\']*\\'|[^>]*))?)*\\s+)data-bind\\s*=\\s*([\"'])([\\s\\S]*?)\\3/gi;\n    var memoizeVirtualContainerBindingSyntaxRegex = /<!--\\s*ko\\b\\s*([\\s\\S]*?)\\s*-->/g;\n\n    function validateDataBindValuesForRewriting(keyValueArray) {\n        var allValidators = ko.expressionRewriting.bindingRewriteValidators;\n        for (var i = 0; i < keyValueArray.length; i++) {\n            var key = keyValueArray[i]['key'];\n            if (allValidators.hasOwnProperty(key)) {\n                var validator = allValidators[key];\n\n                if (typeof validator === \"function\") {\n                    var possibleErrorMessage = validator(keyValueArray[i]['value']);\n                    if (possibleErrorMessage)\n                        throw new Error(possibleErrorMessage);\n                } else if (!validator) {\n                    throw new Error(\"This template engine does not support the '\" + key + \"' binding within its templates\");\n                }\n            }\n        }\n    }\n\n    function constructMemoizedTagReplacement(dataBindAttributeValue, tagToRetain, nodeName, templateEngine) {\n        var dataBindKeyValueArray = ko.expressionRewriting.parseObjectLiteral(dataBindAttributeValue);\n        validateDataBindValuesForRewriting(dataBindKeyValueArray);\n        var rewrittenDataBindAttributeValue = ko.expressionRewriting.preProcessBindings(dataBindKeyValueArray, {'valueAccessors':true});\n\n        // For no obvious reason, Opera fails to evaluate rewrittenDataBindAttributeValue unless it's wrapped in an additional\n        // anonymous function, even though Opera's built-in debugger can evaluate it anyway. No other browser requires this\n        // extra indirection.\n        var applyBindingsToNextSiblingScript =\n            \"ko.__tr_ambtns(function($context,$element){return(function(){return{ \" + rewrittenDataBindAttributeValue + \" } })()},'\" + nodeName.toLowerCase() + \"')\";\n        return templateEngine['createJavaScriptEvaluatorBlock'](applyBindingsToNextSiblingScript) + tagToRetain;\n    }\n\n    return {\n        ensureTemplateIsRewritten: function (template, templateEngine, templateDocument) {\n            if (!templateEngine['isTemplateRewritten'](template, templateDocument))\n                templateEngine['rewriteTemplate'](template, function (htmlString) {\n                    return ko.templateRewriting.memoizeBindingAttributeSyntax(htmlString, templateEngine);\n                }, templateDocument);\n        },\n\n        memoizeBindingAttributeSyntax: function (htmlString, templateEngine) {\n            return htmlString.replace(memoizeDataBindingAttributeSyntaxRegex, function () {\n                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[4], /* tagToRetain: */ arguments[1], /* nodeName: */ arguments[2], templateEngine);\n            }).replace(memoizeVirtualContainerBindingSyntaxRegex, function() {\n                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[1], /* tagToRetain: */ \"<!-- ko -->\", /* nodeName: */ \"#comment\", templateEngine);\n            });\n        },\n\n        applyMemoizedBindingsToNextSibling: function (bindings, nodeName) {\n            return ko.memoization.memoize(function (domNode, bindingContext) {\n                var nodeToBind = domNode.nextSibling;\n                if (nodeToBind && nodeToBind.nodeName.toLowerCase() === nodeName) {\n                    ko.applyBindingAccessorsToNode(nodeToBind, bindings, bindingContext);\n                }\n            });\n        }\n    }\n})();\n\n\n// Exported only because it has to be referenced by string lookup from within rewritten template\nko.exportSymbol('__tr_ambtns', ko.templateRewriting.applyMemoizedBindingsToNextSibling);\n(function() {\n    // A template source represents a read/write way of accessing a template. This is to eliminate the need for template loading/saving\n    // logic to be duplicated in every template engine (and means they can all work with anonymous templates, etc.)\n    //\n    // Two are provided by default:\n    //  1. ko.templateSources.domElement       - reads/writes the text content of an arbitrary DOM element\n    //  2. ko.templateSources.anonymousElement - uses ko.utils.domData to read/write text *associated* with the DOM element, but\n    //                                           without reading/writing the actual element text content, since it will be overwritten\n    //                                           with the rendered template output.\n    // You can implement your own template source if you want to fetch/store templates somewhere other than in DOM elements.\n    // Template sources need to have the following functions:\n    //   text() \t\t\t- returns the template text from your storage location\n    //   text(value)\t\t- writes the supplied template text to your storage location\n    //   data(key)\t\t\t- reads values stored using data(key, value) - see below\n    //   data(key, value)\t- associates \"value\" with this template and the key \"key\". Is used to store information like \"isRewritten\".\n    //\n    // Optionally, template sources can also have the following functions:\n    //   nodes()            - returns a DOM element containing the nodes of this template, where available\n    //   nodes(value)       - writes the given DOM element to your storage location\n    // If a DOM element is available for a given template source, template engines are encouraged to use it in preference over text()\n    // for improved speed. However, all templateSources must supply text() even if they don't supply nodes().\n    //\n    // Once you've implemented a templateSource, make your template engine use it by subclassing whatever template engine you were\n    // using and overriding \"makeTemplateSource\" to return an instance of your custom template source.\n\n    ko.templateSources = {};\n\n    // ---- ko.templateSources.domElement -----\n\n    // template types\n    var templateScript = 1,\n        templateTextArea = 2,\n        templateTemplate = 3,\n        templateElement = 4;\n\n    ko.templateSources.domElement = function(element) {\n        this.domElement = element;\n\n        if (element) {\n            var tagNameLower = ko.utils.tagNameLower(element);\n            this.templateType =\n                tagNameLower === \"script\" ? templateScript :\n                tagNameLower === \"textarea\" ? templateTextArea :\n                    // For browsers with proper <template> element support, where the .content property gives a document fragment\n                tagNameLower == \"template\" && element.content && element.content.nodeType === 11 ? templateTemplate :\n                templateElement;\n        }\n    }\n\n    ko.templateSources.domElement.prototype['text'] = function(/* valueToWrite */) {\n        var elemContentsProperty = this.templateType === templateScript ? \"text\"\n                                 : this.templateType === templateTextArea ? \"value\"\n                                 : \"innerHTML\";\n\n        if (arguments.length == 0) {\n            return this.domElement[elemContentsProperty];\n        } else {\n            var valueToWrite = arguments[0];\n            if (elemContentsProperty === \"innerHTML\")\n                ko.utils.setHtml(this.domElement, valueToWrite);\n            else\n                this.domElement[elemContentsProperty] = valueToWrite;\n        }\n    };\n\n    var dataDomDataPrefix = ko.utils.domData.nextKey() + \"_\";\n    ko.templateSources.domElement.prototype['data'] = function(key /*, valueToWrite */) {\n        if (arguments.length === 1) {\n            return ko.utils.domData.get(this.domElement, dataDomDataPrefix + key);\n        } else {\n            ko.utils.domData.set(this.domElement, dataDomDataPrefix + key, arguments[1]);\n        }\n    };\n\n    var templatesDomDataKey = ko.utils.domData.nextKey();\n    function getTemplateDomData(element) {\n        return ko.utils.domData.get(element, templatesDomDataKey) || {};\n    }\n    function setTemplateDomData(element, data) {\n        ko.utils.domData.set(element, templatesDomDataKey, data);\n    }\n\n    ko.templateSources.domElement.prototype['nodes'] = function(/* valueToWrite */) {\n        var element = this.domElement;\n        if (arguments.length == 0) {\n            var templateData = getTemplateDomData(element),\n                containerData = templateData.containerData;\n            return containerData || (\n                this.templateType === templateTemplate ? element.content :\n                this.templateType === templateElement ? element :\n                undefined);\n        } else {\n            var valueToWrite = arguments[0];\n            setTemplateDomData(element, {containerData: valueToWrite});\n        }\n    };\n\n    // ---- ko.templateSources.anonymousTemplate -----\n    // Anonymous templates are normally saved/retrieved as DOM nodes through \"nodes\".\n    // For compatibility, you can also read \"text\"; it will be serialized from the nodes on demand.\n    // Writing to \"text\" is still supported, but then the template data will not be available as DOM nodes.\n\n    ko.templateSources.anonymousTemplate = function(element) {\n        this.domElement = element;\n    }\n    ko.templateSources.anonymousTemplate.prototype = new ko.templateSources.domElement();\n    ko.templateSources.anonymousTemplate.prototype.constructor = ko.templateSources.anonymousTemplate;\n    ko.templateSources.anonymousTemplate.prototype['text'] = function(/* valueToWrite */) {\n        if (arguments.length == 0) {\n            var templateData = getTemplateDomData(this.domElement);\n            if (templateData.textData === undefined && templateData.containerData)\n                templateData.textData = templateData.containerData.innerHTML;\n            return templateData.textData;\n        } else {\n            var valueToWrite = arguments[0];\n            setTemplateDomData(this.domElement, {textData: valueToWrite});\n        }\n    };\n\n    ko.exportSymbol('templateSources', ko.templateSources);\n    ko.exportSymbol('templateSources.domElement', ko.templateSources.domElement);\n    ko.exportSymbol('templateSources.anonymousTemplate', ko.templateSources.anonymousTemplate);\n})();\n(function () {\n    var _templateEngine;\n    ko.setTemplateEngine = function (templateEngine) {\n        if ((templateEngine != undefined) && !(templateEngine instanceof ko.templateEngine))\n            throw new Error(\"templateEngine must inherit from ko.templateEngine\");\n        _templateEngine = templateEngine;\n    }\n\n    function invokeForEachNodeInContinuousRange(firstNode, lastNode, action) {\n        var node, nextInQueue = firstNode, firstOutOfRangeNode = ko.virtualElements.nextSibling(lastNode);\n        while (nextInQueue && ((node = nextInQueue) !== firstOutOfRangeNode)) {\n            nextInQueue = ko.virtualElements.nextSibling(node);\n            action(node, nextInQueue);\n        }\n    }\n\n    function activateBindingsOnContinuousNodeArray(continuousNodeArray, bindingContext) {\n        // To be used on any nodes that have been rendered by a template and have been inserted into some parent element\n        // Walks through continuousNodeArray (which *must* be continuous, i.e., an uninterrupted sequence of sibling nodes, because\n        // the algorithm for walking them relies on this), and for each top-level item in the virtual-element sense,\n        // (1) Does a regular \"applyBindings\" to associate bindingContext with this node and to activate any non-memoized bindings\n        // (2) Unmemoizes any memos in the DOM subtree (e.g., to activate bindings that had been memoized during template rewriting)\n\n        if (continuousNodeArray.length) {\n            var firstNode = continuousNodeArray[0],\n                lastNode = continuousNodeArray[continuousNodeArray.length - 1],\n                parentNode = firstNode.parentNode,\n                provider = ko.bindingProvider['instance'],\n                preprocessNode = provider['preprocessNode'];\n\n            if (preprocessNode) {\n                invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node, nextNodeInRange) {\n                    var nodePreviousSibling = node.previousSibling;\n                    var newNodes = preprocessNode.call(provider, node);\n                    if (newNodes) {\n                        if (node === firstNode)\n                            firstNode = newNodes[0] || nextNodeInRange;\n                        if (node === lastNode)\n                            lastNode = newNodes[newNodes.length - 1] || nodePreviousSibling;\n                    }\n                });\n\n                // Because preprocessNode can change the nodes, including the first and last nodes, update continuousNodeArray to match.\n                // We need the full set, including inner nodes, because the unmemoize step might remove the first node (and so the real\n                // first node needs to be in the array).\n                continuousNodeArray.length = 0;\n                if (!firstNode) { // preprocessNode might have removed all the nodes, in which case there's nothing left to do\n                    return;\n                }\n                if (firstNode === lastNode) {\n                    continuousNodeArray.push(firstNode);\n                } else {\n                    continuousNodeArray.push(firstNode, lastNode);\n                    ko.utils.fixUpContinuousNodeArray(continuousNodeArray, parentNode);\n                }\n            }\n\n            // Need to applyBindings *before* unmemoziation, because unmemoization might introduce extra nodes (that we don't want to re-bind)\n            // whereas a regular applyBindings won't introduce new memoized nodes\n            invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node) {\n                if (node.nodeType === 1 || node.nodeType === 8)\n                    ko.applyBindings(bindingContext, node);\n            });\n            invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node) {\n                if (node.nodeType === 1 || node.nodeType === 8)\n                    ko.memoization.unmemoizeDomNodeAndDescendants(node, [bindingContext]);\n            });\n\n            // Make sure any changes done by applyBindings or unmemoize are reflected in the array\n            ko.utils.fixUpContinuousNodeArray(continuousNodeArray, parentNode);\n        }\n    }\n\n    function getFirstNodeFromPossibleArray(nodeOrNodeArray) {\n        return nodeOrNodeArray.nodeType ? nodeOrNodeArray\n                                        : nodeOrNodeArray.length > 0 ? nodeOrNodeArray[0]\n                                        : null;\n    }\n\n    function executeTemplate(targetNodeOrNodeArray, renderMode, template, bindingContext, options) {\n        options = options || {};\n        var firstTargetNode = targetNodeOrNodeArray && getFirstNodeFromPossibleArray(targetNodeOrNodeArray);\n        var templateDocument = (firstTargetNode || template || {}).ownerDocument;\n        var templateEngineToUse = (options['templateEngine'] || _templateEngine);\n        ko.templateRewriting.ensureTemplateIsRewritten(template, templateEngineToUse, templateDocument);\n        var renderedNodesArray = templateEngineToUse['renderTemplate'](template, bindingContext, options, templateDocument);\n\n        // Loosely check result is an array of DOM nodes\n        if ((typeof renderedNodesArray.length != \"number\") || (renderedNodesArray.length > 0 && typeof renderedNodesArray[0].nodeType != \"number\"))\n            throw new Error(\"Template engine must return an array of DOM nodes\");\n\n        var haveAddedNodesToParent = false;\n        switch (renderMode) {\n            case \"replaceChildren\":\n                ko.virtualElements.setDomNodeChildren(targetNodeOrNodeArray, renderedNodesArray);\n                haveAddedNodesToParent = true;\n                break;\n            case \"replaceNode\":\n                ko.utils.replaceDomNodes(targetNodeOrNodeArray, renderedNodesArray);\n                haveAddedNodesToParent = true;\n                break;\n            case \"ignoreTargetNode\": break;\n            default:\n                throw new Error(\"Unknown renderMode: \" + renderMode);\n        }\n\n        if (haveAddedNodesToParent) {\n            activateBindingsOnContinuousNodeArray(renderedNodesArray, bindingContext);\n            if (options['afterRender'])\n                ko.dependencyDetection.ignore(options['afterRender'], null, [renderedNodesArray, bindingContext['$data']]);\n        }\n\n        return renderedNodesArray;\n    }\n\n    function resolveTemplateName(template, data, context) {\n        // The template can be specified as:\n        if (ko.isObservable(template)) {\n            // 1. An observable, with string value\n            return template();\n        } else if (typeof template === 'function') {\n            // 2. A function of (data, context) returning a string\n            return template(data, context);\n        } else {\n            // 3. A string\n            return template;\n        }\n    }\n\n    ko.renderTemplate = function (template, dataOrBindingContext, options, targetNodeOrNodeArray, renderMode) {\n        options = options || {};\n        if ((options['templateEngine'] || _templateEngine) == undefined)\n            throw new Error(\"Set a template engine before calling renderTemplate\");\n        renderMode = renderMode || \"replaceChildren\";\n\n        if (targetNodeOrNodeArray) {\n            var firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);\n\n            var whenToDispose = function () { return (!firstTargetNode) || !ko.utils.domNodeIsAttachedToDocument(firstTargetNode); }; // Passive disposal (on next evaluation)\n            var activelyDisposeWhenNodeIsRemoved = (firstTargetNode && renderMode == \"replaceNode\") ? firstTargetNode.parentNode : firstTargetNode;\n\n            return ko.dependentObservable( // So the DOM is automatically updated when any dependency changes\n                function () {\n                    // Ensure we've got a proper binding context to work with\n                    var bindingContext = (dataOrBindingContext && (dataOrBindingContext instanceof ko.bindingContext))\n                        ? dataOrBindingContext\n                        : new ko.bindingContext(dataOrBindingContext, null, null, null, { \"exportDependencies\": true });\n\n                    var templateName = resolveTemplateName(template, bindingContext['$data'], bindingContext),\n                        renderedNodesArray = executeTemplate(targetNodeOrNodeArray, renderMode, templateName, bindingContext, options);\n\n                    if (renderMode == \"replaceNode\") {\n                        targetNodeOrNodeArray = renderedNodesArray;\n                        firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);\n                    }\n                },\n                null,\n                { disposeWhen: whenToDispose, disposeWhenNodeIsRemoved: activelyDisposeWhenNodeIsRemoved }\n            );\n        } else {\n            // We don't yet have a DOM node to evaluate, so use a memo and render the template later when there is a DOM node\n            return ko.memoization.memoize(function (domNode) {\n                ko.renderTemplate(template, dataOrBindingContext, options, domNode, \"replaceNode\");\n            });\n        }\n    };\n\n    ko.renderTemplateForEach = function (template, arrayOrObservableArray, options, targetNode, parentBindingContext) {\n        // Since setDomNodeChildrenFromArrayMapping always calls executeTemplateForArrayItem and then\n        // activateBindingsCallback for added items, we can store the binding context in the former to use in the latter.\n        var arrayItemContext;\n\n        // This will be called by setDomNodeChildrenFromArrayMapping to get the nodes to add to targetNode\n        var executeTemplateForArrayItem = function (arrayValue, index) {\n            // Support selecting template as a function of the data being rendered\n            arrayItemContext = parentBindingContext['createChildContext'](arrayValue, options['as'], function(context) {\n                context['$index'] = index;\n            });\n\n            var templateName = resolveTemplateName(template, arrayValue, arrayItemContext);\n            return executeTemplate(null, \"ignoreTargetNode\", templateName, arrayItemContext, options);\n        }\n\n        // This will be called whenever setDomNodeChildrenFromArrayMapping has added nodes to targetNode\n        var activateBindingsCallback = function(arrayValue, addedNodesArray, index) {\n            activateBindingsOnContinuousNodeArray(addedNodesArray, arrayItemContext);\n            if (options['afterRender'])\n                options['afterRender'](addedNodesArray, arrayValue);\n\n            // release the \"cache\" variable, so that it can be collected by\n            // the GC when its value isn't used from within the bindings anymore.\n            arrayItemContext = null;\n        };\n\n        return ko.dependentObservable(function () {\n            var unwrappedArray = ko.utils.unwrapObservable(arrayOrObservableArray) || [];\n            if (typeof unwrappedArray.length == \"undefined\") // Coerce single value into array\n                unwrappedArray = [unwrappedArray];\n\n            // Filter out any entries marked as destroyed\n            var filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {\n                return options['includeDestroyed'] || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);\n            });\n\n            // Call setDomNodeChildrenFromArrayMapping, ignoring any observables unwrapped within (most likely from a callback function).\n            // If the array items are observables, though, they will be unwrapped in executeTemplateForArrayItem and managed within setDomNodeChildrenFromArrayMapping.\n            ko.dependencyDetection.ignore(ko.utils.setDomNodeChildrenFromArrayMapping, null, [targetNode, filteredArray, executeTemplateForArrayItem, options, activateBindingsCallback]);\n\n        }, null, { disposeWhenNodeIsRemoved: targetNode });\n    };\n\n    var templateComputedDomDataKey = ko.utils.domData.nextKey();\n    function disposeOldComputedAndStoreNewOne(element, newComputed) {\n        var oldComputed = ko.utils.domData.get(element, templateComputedDomDataKey);\n        if (oldComputed && (typeof(oldComputed.dispose) == 'function'))\n            oldComputed.dispose();\n        ko.utils.domData.set(element, templateComputedDomDataKey, (newComputed && newComputed.isActive()) ? newComputed : undefined);\n    }\n\n    ko.bindingHandlers['template'] = {\n        'init': function(element, valueAccessor) {\n            // Support anonymous templates\n            var bindingValue = ko.utils.unwrapObservable(valueAccessor());\n            if (typeof bindingValue == \"string\" || bindingValue['name']) {\n                // It's a named template - clear the element\n                ko.virtualElements.emptyNode(element);\n            } else if ('nodes' in bindingValue) {\n                // We've been given an array of DOM nodes. Save them as the template source.\n                // There is no known use case for the node array being an observable array (if the output\n                // varies, put that behavior *into* your template - that's what templates are for), and\n                // the implementation would be a mess, so assert that it's not observable.\n                var nodes = bindingValue['nodes'] || [];\n                if (ko.isObservable(nodes)) {\n                    throw new Error('The \"nodes\" option must be a plain, non-observable array.');\n                }\n                var container = ko.utils.moveCleanedNodesToContainerElement(nodes); // This also removes the nodes from their current parent\n                new ko.templateSources.anonymousTemplate(element)['nodes'](container);\n            } else {\n                // It's an anonymous template - store the element contents, then clear the element\n                var templateNodes = ko.virtualElements.childNodes(element),\n                    container = ko.utils.moveCleanedNodesToContainerElement(templateNodes); // This also removes the nodes from their current parent\n                new ko.templateSources.anonymousTemplate(element)['nodes'](container);\n            }\n            return { 'controlsDescendantBindings': true };\n        },\n        'update': function (element, valueAccessor, allBindings, viewModel, bindingContext) {\n            var value = valueAccessor(),\n                options = ko.utils.unwrapObservable(value),\n                shouldDisplay = true,\n                templateComputed = null,\n                templateName;\n\n            if (typeof options == \"string\") {\n                templateName = value;\n                options = {};\n            } else {\n                templateName = options['name'];\n\n                // Support \"if\"/\"ifnot\" conditions\n                if ('if' in options)\n                    shouldDisplay = ko.utils.unwrapObservable(options['if']);\n                if (shouldDisplay && 'ifnot' in options)\n                    shouldDisplay = !ko.utils.unwrapObservable(options['ifnot']);\n            }\n\n            if ('foreach' in options) {\n                // Render once for each data point (treating data set as empty if shouldDisplay==false)\n                var dataArray = (shouldDisplay && options['foreach']) || [];\n                templateComputed = ko.renderTemplateForEach(templateName || element, dataArray, options, element, bindingContext);\n            } else if (!shouldDisplay) {\n                ko.virtualElements.emptyNode(element);\n            } else {\n                // Render once for this single data point (or use the viewModel if no data was provided)\n                var innerBindingContext = ('data' in options) ?\n                    bindingContext.createStaticChildContext(options['data'], options['as']) :  // Given an explitit 'data' value, we create a child binding context for it\n                    bindingContext;                                                        // Given no explicit 'data' value, we retain the same binding context\n                templateComputed = ko.renderTemplate(templateName || element, innerBindingContext, options, element);\n            }\n\n            // It only makes sense to have a single template computed per element (otherwise which one should have its output displayed?)\n            disposeOldComputedAndStoreNewOne(element, templateComputed);\n        }\n    };\n\n    // Anonymous templates can't be rewritten. Give a nice error message if you try to do it.\n    ko.expressionRewriting.bindingRewriteValidators['template'] = function(bindingValue) {\n        var parsedBindingValue = ko.expressionRewriting.parseObjectLiteral(bindingValue);\n\n        if ((parsedBindingValue.length == 1) && parsedBindingValue[0]['unknown'])\n            return null; // It looks like a string literal, not an object literal, so treat it as a named template (which is allowed for rewriting)\n\n        if (ko.expressionRewriting.keyValueArrayContainsKey(parsedBindingValue, \"name\"))\n            return null; // Named templates can be rewritten, so return \"no error\"\n        return \"This template engine does not support anonymous templates nested within its templates\";\n    };\n\n    ko.virtualElements.allowedBindings['template'] = true;\n})();\n\nko.exportSymbol('setTemplateEngine', ko.setTemplateEngine);\nko.exportSymbol('renderTemplate', ko.renderTemplate);\n// Go through the items that have been added and deleted and try to find matches between them.\nko.utils.findMovesInArrayComparison = function (left, right, limitFailedCompares) {\n    if (left.length && right.length) {\n        var failedCompares, l, r, leftItem, rightItem;\n        for (failedCompares = l = 0; (!limitFailedCompares || failedCompares < limitFailedCompares) && (leftItem = left[l]); ++l) {\n            for (r = 0; rightItem = right[r]; ++r) {\n                if (leftItem['value'] === rightItem['value']) {\n                    leftItem['moved'] = rightItem['index'];\n                    rightItem['moved'] = leftItem['index'];\n                    right.splice(r, 1);         // This item is marked as moved; so remove it from right list\n                    failedCompares = r = 0;     // Reset failed compares count because we're checking for consecutive failures\n                    break;\n                }\n            }\n            failedCompares += r;\n        }\n    }\n};\n\nko.utils.compareArrays = (function () {\n    var statusNotInOld = 'added', statusNotInNew = 'deleted';\n\n    // Simple calculation based on Levenshtein distance.\n    function compareArrays(oldArray, newArray, options) {\n        // For backward compatibility, if the third arg is actually a bool, interpret\n        // it as the old parameter 'dontLimitMoves'. Newer code should use { dontLimitMoves: true }.\n        options = (typeof options === 'boolean') ? { 'dontLimitMoves': options } : (options || {});\n        oldArray = oldArray || [];\n        newArray = newArray || [];\n\n        if (oldArray.length < newArray.length)\n            return compareSmallArrayToBigArray(oldArray, newArray, statusNotInOld, statusNotInNew, options);\n        else\n            return compareSmallArrayToBigArray(newArray, oldArray, statusNotInNew, statusNotInOld, options);\n    }\n\n    function compareSmallArrayToBigArray(smlArray, bigArray, statusNotInSml, statusNotInBig, options) {\n        var myMin = Math.min,\n            myMax = Math.max,\n            editDistanceMatrix = [],\n            smlIndex, smlIndexMax = smlArray.length,\n            bigIndex, bigIndexMax = bigArray.length,\n            compareRange = (bigIndexMax - smlIndexMax) || 1,\n            maxDistance = smlIndexMax + bigIndexMax + 1,\n            thisRow, lastRow,\n            bigIndexMaxForRow, bigIndexMinForRow;\n\n        for (smlIndex = 0; smlIndex <= smlIndexMax; smlIndex++) {\n            lastRow = thisRow;\n            editDistanceMatrix.push(thisRow = []);\n            bigIndexMaxForRow = myMin(bigIndexMax, smlIndex + compareRange);\n            bigIndexMinForRow = myMax(0, smlIndex - 1);\n            for (bigIndex = bigIndexMinForRow; bigIndex <= bigIndexMaxForRow; bigIndex++) {\n                if (!bigIndex)\n                    thisRow[bigIndex] = smlIndex + 1;\n                else if (!smlIndex)  // Top row - transform empty array into new array via additions\n                    thisRow[bigIndex] = bigIndex + 1;\n                else if (smlArray[smlIndex - 1] === bigArray[bigIndex - 1])\n                    thisRow[bigIndex] = lastRow[bigIndex - 1];                  // copy value (no edit)\n                else {\n                    var northDistance = lastRow[bigIndex] || maxDistance;       // not in big (deletion)\n                    var westDistance = thisRow[bigIndex - 1] || maxDistance;    // not in small (addition)\n                    thisRow[bigIndex] = myMin(northDistance, westDistance) + 1;\n                }\n            }\n        }\n\n        var editScript = [], meMinusOne, notInSml = [], notInBig = [];\n        for (smlIndex = smlIndexMax, bigIndex = bigIndexMax; smlIndex || bigIndex;) {\n            meMinusOne = editDistanceMatrix[smlIndex][bigIndex] - 1;\n            if (bigIndex && meMinusOne === editDistanceMatrix[smlIndex][bigIndex-1]) {\n                notInSml.push(editScript[editScript.length] = {     // added\n                    'status': statusNotInSml,\n                    'value': bigArray[--bigIndex],\n                    'index': bigIndex });\n            } else if (smlIndex && meMinusOne === editDistanceMatrix[smlIndex - 1][bigIndex]) {\n                notInBig.push(editScript[editScript.length] = {     // deleted\n                    'status': statusNotInBig,\n                    'value': smlArray[--smlIndex],\n                    'index': smlIndex });\n            } else {\n                --bigIndex;\n                --smlIndex;\n                if (!options['sparse']) {\n                    editScript.push({\n                        'status': \"retained\",\n                        'value': bigArray[bigIndex] });\n                }\n            }\n        }\n\n        // Set a limit on the number of consecutive non-matching comparisons; having it a multiple of\n        // smlIndexMax keeps the time complexity of this algorithm linear.\n        ko.utils.findMovesInArrayComparison(notInBig, notInSml, !options['dontLimitMoves'] && smlIndexMax * 10);\n\n        return editScript.reverse();\n    }\n\n    return compareArrays;\n})();\n\nko.exportSymbol('utils.compareArrays', ko.utils.compareArrays);\n(function () {\n    // Objective:\n    // * Given an input array, a container DOM node, and a function from array elements to arrays of DOM nodes,\n    //   map the array elements to arrays of DOM nodes, concatenate together all these arrays, and use them to populate the container DOM node\n    // * Next time we're given the same combination of things (with the array possibly having mutated), update the container DOM node\n    //   so that its children is again the concatenation of the mappings of the array elements, but don't re-map any array elements that we\n    //   previously mapped - retain those nodes, and just insert/delete other ones\n\n    // \"callbackAfterAddingNodes\" will be invoked after any \"mapping\"-generated nodes are inserted into the container node\n    // You can use this, for example, to activate bindings on those nodes.\n\n    function mapNodeAndRefreshWhenChanged(containerNode, mapping, valueToMap, callbackAfterAddingNodes, index) {\n        // Map this array value inside a dependentObservable so we re-map when any dependency changes\n        var mappedNodes = [];\n        var dependentObservable = ko.dependentObservable(function() {\n            var newMappedNodes = mapping(valueToMap, index, ko.utils.fixUpContinuousNodeArray(mappedNodes, containerNode)) || [];\n\n            // On subsequent evaluations, just replace the previously-inserted DOM nodes\n            if (mappedNodes.length > 0) {\n                ko.utils.replaceDomNodes(mappedNodes, newMappedNodes);\n                if (callbackAfterAddingNodes)\n                    ko.dependencyDetection.ignore(callbackAfterAddingNodes, null, [valueToMap, newMappedNodes, index]);\n            }\n\n            // Replace the contents of the mappedNodes array, thereby updating the record\n            // of which nodes would be deleted if valueToMap was itself later removed\n            mappedNodes.length = 0;\n            ko.utils.arrayPushAll(mappedNodes, newMappedNodes);\n        }, null, { disposeWhenNodeIsRemoved: containerNode, disposeWhen: function() { return !ko.utils.anyDomNodeIsAttachedToDocument(mappedNodes); } });\n        return { mappedNodes : mappedNodes, dependentObservable : (dependentObservable.isActive() ? dependentObservable : undefined) };\n    }\n\n    var lastMappingResultDomDataKey = ko.utils.domData.nextKey(),\n        deletedItemDummyValue = ko.utils.domData.nextKey();\n\n    ko.utils.setDomNodeChildrenFromArrayMapping = function (domNode, array, mapping, options, callbackAfterAddingNodes) {\n        // Compare the provided array against the previous one\n        array = array || [];\n        options = options || {};\n        var isFirstExecution = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) === undefined;\n        var lastMappingResult = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) || [];\n        var lastArray = ko.utils.arrayMap(lastMappingResult, function (x) { return x.arrayEntry; });\n        var editScript = ko.utils.compareArrays(lastArray, array, options['dontLimitMoves']);\n\n        // Build the new mapping result\n        var newMappingResult = [];\n        var lastMappingResultIndex = 0;\n        var newMappingResultIndex = 0;\n\n        var nodesToDelete = [];\n        var itemsToProcess = [];\n        var itemsForBeforeRemoveCallbacks = [];\n        var itemsForMoveCallbacks = [];\n        var itemsForAfterAddCallbacks = [];\n        var mapData;\n\n        function itemMovedOrRetained(editScriptIndex, oldPosition) {\n            mapData = lastMappingResult[oldPosition];\n            if (newMappingResultIndex !== oldPosition)\n                itemsForMoveCallbacks[editScriptIndex] = mapData;\n            // Since updating the index might change the nodes, do so before calling fixUpContinuousNodeArray\n            mapData.indexObservable(newMappingResultIndex++);\n            ko.utils.fixUpContinuousNodeArray(mapData.mappedNodes, domNode);\n            newMappingResult.push(mapData);\n            itemsToProcess.push(mapData);\n        }\n\n        function callCallback(callback, items) {\n            if (callback) {\n                for (var i = 0, n = items.length; i < n; i++) {\n                    if (items[i]) {\n                        ko.utils.arrayForEach(items[i].mappedNodes, function(node) {\n                            callback(node, i, items[i].arrayEntry);\n                        });\n                    }\n                }\n            }\n        }\n\n        for (var i = 0, editScriptItem, movedIndex; editScriptItem = editScript[i]; i++) {\n            movedIndex = editScriptItem['moved'];\n            switch (editScriptItem['status']) {\n                case \"deleted\":\n                    if (movedIndex === undefined) {\n                        mapData = lastMappingResult[lastMappingResultIndex];\n\n                        // Stop tracking changes to the mapping for these nodes\n                        if (mapData.dependentObservable) {\n                            mapData.dependentObservable.dispose();\n                            mapData.dependentObservable = undefined;\n                        }\n\n                        // Queue these nodes for later removal\n                        if (ko.utils.fixUpContinuousNodeArray(mapData.mappedNodes, domNode).length) {\n                            if (options['beforeRemove']) {\n                                newMappingResult.push(mapData);\n                                itemsToProcess.push(mapData);\n                                if (mapData.arrayEntry === deletedItemDummyValue) {\n                                    mapData = null;\n                                } else {\n                                    itemsForBeforeRemoveCallbacks[i] = mapData;\n                                }\n                            }\n                            if (mapData) {\n                                nodesToDelete.push.apply(nodesToDelete, mapData.mappedNodes);\n                            }\n                        }\n                    }\n                    lastMappingResultIndex++;\n                    break;\n\n                case \"retained\":\n                    itemMovedOrRetained(i, lastMappingResultIndex++);\n                    break;\n\n                case \"added\":\n                    if (movedIndex !== undefined) {\n                        itemMovedOrRetained(i, movedIndex);\n                    } else {\n                        mapData = { arrayEntry: editScriptItem['value'], indexObservable: ko.observable(newMappingResultIndex++) };\n                        newMappingResult.push(mapData);\n                        itemsToProcess.push(mapData);\n                        if (!isFirstExecution)\n                            itemsForAfterAddCallbacks[i] = mapData;\n                    }\n                    break;\n            }\n        }\n\n        // Store a copy of the array items we just considered so we can difference it next time\n        ko.utils.domData.set(domNode, lastMappingResultDomDataKey, newMappingResult);\n\n        // Call beforeMove first before any changes have been made to the DOM\n        callCallback(options['beforeMove'], itemsForMoveCallbacks);\n\n        // Next remove nodes for deleted items (or just clean if there's a beforeRemove callback)\n        ko.utils.arrayForEach(nodesToDelete, options['beforeRemove'] ? ko.cleanNode : ko.removeNode);\n\n        // Next add/reorder the remaining items (will include deleted items if there's a beforeRemove callback)\n        for (var i = 0, nextNode = ko.virtualElements.firstChild(domNode), lastNode, node; mapData = itemsToProcess[i]; i++) {\n            // Get nodes for newly added items\n            if (!mapData.mappedNodes)\n                ko.utils.extend(mapData, mapNodeAndRefreshWhenChanged(domNode, mapping, mapData.arrayEntry, callbackAfterAddingNodes, mapData.indexObservable));\n\n            // Put nodes in the right place if they aren't there already\n            for (var j = 0; node = mapData.mappedNodes[j]; nextNode = node.nextSibling, lastNode = node, j++) {\n                if (node !== nextNode)\n                    ko.virtualElements.insertAfter(domNode, node, lastNode);\n            }\n\n            // Run the callbacks for newly added nodes (for example, to apply bindings, etc.)\n            if (!mapData.initialized && callbackAfterAddingNodes) {\n                callbackAfterAddingNodes(mapData.arrayEntry, mapData.mappedNodes, mapData.indexObservable);\n                mapData.initialized = true;\n            }\n        }\n\n        // If there's a beforeRemove callback, call it after reordering.\n        // Note that we assume that the beforeRemove callback will usually be used to remove the nodes using\n        // some sort of animation, which is why we first reorder the nodes that will be removed. If the\n        // callback instead removes the nodes right away, it would be more efficient to skip reordering them.\n        // Perhaps we'll make that change in the future if this scenario becomes more common.\n        callCallback(options['beforeRemove'], itemsForBeforeRemoveCallbacks);\n\n        // Replace the stored values of deleted items with a dummy value. This provides two benefits: it marks this item\n        // as already \"removed\" so we won't call beforeRemove for it again, and it ensures that the item won't match up\n        // with an actual item in the array and appear as \"retained\" or \"moved\".\n        for (i = 0; i < itemsForBeforeRemoveCallbacks.length; ++i) {\n            if (itemsForBeforeRemoveCallbacks[i]) {\n                itemsForBeforeRemoveCallbacks[i].arrayEntry = deletedItemDummyValue;\n            }\n        }\n\n        // Finally call afterMove and afterAdd callbacks\n        callCallback(options['afterMove'], itemsForMoveCallbacks);\n        callCallback(options['afterAdd'], itemsForAfterAddCallbacks);\n    }\n})();\n\nko.exportSymbol('utils.setDomNodeChildrenFromArrayMapping', ko.utils.setDomNodeChildrenFromArrayMapping);\nko.nativeTemplateEngine = function () {\n    this['allowTemplateRewriting'] = false;\n}\n\nko.nativeTemplateEngine.prototype = new ko.templateEngine();\nko.nativeTemplateEngine.prototype.constructor = ko.nativeTemplateEngine;\nko.nativeTemplateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options, templateDocument) {\n    var useNodesIfAvailable = !(ko.utils.ieVersion < 9), // IE<9 cloneNode doesn't work properly\n        templateNodesFunc = useNodesIfAvailable ? templateSource['nodes'] : null,\n        templateNodes = templateNodesFunc ? templateSource['nodes']() : null;\n\n    if (templateNodes) {\n        return ko.utils.makeArray(templateNodes.cloneNode(true).childNodes);\n    } else {\n        var templateText = templateSource['text']();\n        return ko.utils.parseHtmlFragment(templateText, templateDocument);\n    }\n};\n\nko.nativeTemplateEngine.instance = new ko.nativeTemplateEngine();\nko.setTemplateEngine(ko.nativeTemplateEngine.instance);\n\nko.exportSymbol('nativeTemplateEngine', ko.nativeTemplateEngine);\n(function() {\n    ko.jqueryTmplTemplateEngine = function () {\n        // Detect which version of jquery-tmpl you're using. Unfortunately jquery-tmpl\n        // doesn't expose a version number, so we have to infer it.\n        // Note that as of Knockout 1.3, we only support jQuery.tmpl 1.0.0pre and later,\n        // which KO internally refers to as version \"2\", so older versions are no longer detected.\n        var jQueryTmplVersion = this.jQueryTmplVersion = (function() {\n            if (!jQueryInstance || !(jQueryInstance['tmpl']))\n                return 0;\n            // Since it exposes no official version number, we use our own numbering system. To be updated as jquery-tmpl evolves.\n            try {\n                if (jQueryInstance['tmpl']['tag']['tmpl']['open'].toString().indexOf('__') >= 0) {\n                    // Since 1.0.0pre, custom tags should append markup to an array called \"__\"\n                    return 2; // Final version of jquery.tmpl\n                }\n            } catch(ex) { /* Apparently not the version we were looking for */ }\n\n            return 1; // Any older version that we don't support\n        })();\n\n        function ensureHasReferencedJQueryTemplates() {\n            if (jQueryTmplVersion < 2)\n                throw new Error(\"Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.\");\n        }\n\n        function executeTemplate(compiledTemplate, data, jQueryTemplateOptions) {\n            return jQueryInstance['tmpl'](compiledTemplate, data, jQueryTemplateOptions);\n        }\n\n        this['renderTemplateSource'] = function(templateSource, bindingContext, options, templateDocument) {\n            templateDocument = templateDocument || document;\n            options = options || {};\n            ensureHasReferencedJQueryTemplates();\n\n            // Ensure we have stored a precompiled version of this template (don't want to reparse on every render)\n            var precompiled = templateSource['data']('precompiled');\n            if (!precompiled) {\n                var templateText = templateSource['text']() || \"\";\n                // Wrap in \"with($whatever.koBindingContext) { ... }\"\n                templateText = \"{{ko_with $item.koBindingContext}}\" + templateText + \"{{/ko_with}}\";\n\n                precompiled = jQueryInstance['template'](null, templateText);\n                templateSource['data']('precompiled', precompiled);\n            }\n\n            var data = [bindingContext['$data']]; // Prewrap the data in an array to stop jquery.tmpl from trying to unwrap any arrays\n            var jQueryTemplateOptions = jQueryInstance['extend']({ 'koBindingContext': bindingContext }, options['templateOptions']);\n\n            var resultNodes = executeTemplate(precompiled, data, jQueryTemplateOptions);\n            resultNodes['appendTo'](templateDocument.createElement(\"div\")); // Using \"appendTo\" forces jQuery/jQuery.tmpl to perform necessary cleanup work\n\n            jQueryInstance['fragments'] = {}; // Clear jQuery's fragment cache to avoid a memory leak after a large number of template renders\n            return resultNodes;\n        };\n\n        this['createJavaScriptEvaluatorBlock'] = function(script) {\n            return \"{{ko_code ((function() { return \" + script + \" })()) }}\";\n        };\n\n        this['addTemplate'] = function(templateName, templateMarkup) {\n            document.write(\"<script type='text/html' id='\" + templateName + \"'>\" + templateMarkup + \"<\" + \"/script>\");\n        };\n\n        if (jQueryTmplVersion > 0) {\n            jQueryInstance['tmpl']['tag']['ko_code'] = {\n                open: \"__.push($1 || '');\"\n            };\n            jQueryInstance['tmpl']['tag']['ko_with'] = {\n                open: \"with($1) {\",\n                close: \"} \"\n            };\n        }\n    };\n\n    ko.jqueryTmplTemplateEngine.prototype = new ko.templateEngine();\n    ko.jqueryTmplTemplateEngine.prototype.constructor = ko.jqueryTmplTemplateEngine;\n\n    // Use this one by default *only if jquery.tmpl is referenced*\n    var jqueryTmplTemplateEngineInstance = new ko.jqueryTmplTemplateEngine();\n    if (jqueryTmplTemplateEngineInstance.jQueryTmplVersion > 0)\n        ko.setTemplateEngine(jqueryTmplTemplateEngineInstance);\n\n    ko.exportSymbol('jqueryTmplTemplateEngine', ko.jqueryTmplTemplateEngine);\n})();\n}));\n}());\n})();\n","mage/accordion.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'mage/tabs'\n], function ($, tabs) {\n    'use strict';\n\n    $.widget('mage.accordion', tabs, {\n        options: {\n            active: [0],\n            multipleCollapsible: false,\n            openOnFocus: false\n        },\n\n        /**\n         * @private\n         */\n        _callCollapsible: function () {\n            var self = this,\n                disabled = false,\n                active = false;\n\n            if (typeof this.options.active === 'string') {\n                this.options.active = this.options.active.split(' ').map(function (item) {\n                    return parseInt(item, 10);\n                });\n            }\n\n            $.each(this.collapsibles, function (i) {\n                disabled = active = false;\n\n                if ($.inArray(i, self.options.disabled) !== -1) {\n                    disabled = true;\n                }\n\n                if ($.inArray(i, self.options.active) !== -1) {\n                    active = true;\n                }\n                self._instantiateCollapsible(this, i, active, disabled);\n            });\n        },\n\n        /**\n         * Overwrites default functionality to provide the option to activate/deactivate multiple sections simultaneous\n         * @param {*} action\n         * @param {*} index\n         * @private\n         */\n        _toggleActivate: function (action, index) {\n            var self = this;\n\n            if ($.isArray(index && this.options.multipleCollapsible)) {\n                $.each(index, function () {\n                    self.collapsibles.eq(this).collapsible(action);\n                });\n            } else if (index === undefined && this.options.multipleCollapsible) {\n                this.collapsibles.collapsible(action);\n            } else {\n                this._super(action, index);\n            }\n        },\n\n        /**\n         * If the Accordion allows multiple section to be active at the same time, if deep linking is used\n         * sections that don't contain the id from anchor shouldn't be closed, otherwise the accordion uses the\n         * tabs behavior\n         * @private\n         */\n        _handleDeepLinking: function () {\n            if (!this.options.multipleCollapsible) {\n                this._super();\n            }\n        },\n\n        /**\n         * Prevent default behavior that closes the other sections when one gets activated if the Accordion allows\n         * multiple sections simultaneous\n         * @private\n         */\n        _closeOthers: function () {\n            var self = this;\n\n            if (!this.options.multipleCollapsible) {\n                $.each(this.collapsibles, function () {\n                    $(this).on('beforeOpen', function () {\n                        self.collapsibles.not(this).collapsible('deactivate');\n                    });\n                });\n            }\n            $.each(this.collapsibles, function () {\n                $(this).on('beforeOpen', function () {\n                    var section = $(this);\n\n                    section.addClass('allow').prevAll().addClass('allow');\n                    section.nextAll().removeClass('allow');\n                });\n            });\n        }\n    });\n\n    return $.mage.accordion;\n});\n","mage/bootstrap.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'mage/apply/main',\n    'Magento_Ui/js/lib/knockout/bootstrap'\n], function ($, mage) {\n    'use strict';\n\n    $.ajaxSetup({\n        cache: false\n    });\n\n    /**\n     * Init all components defined via data-mage-init attribute.\n     * Execute in a separate task to prevent main thread blocking.\n     */\n    setTimeout(mage.apply);\n});\n","mage/calendar.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\n/*eslint max-depth: 0*/\ndefine([\n    'jquery',\n    'jquery-ui-modules/widget',\n    'jquery-ui-modules/datepicker',\n    'jquery-ui-modules/timepicker'\n], function ($) {\n    'use strict';\n\n    var calendarBasePrototype,\n        datepickerPrototype = $.datepicker.constructor.prototype;\n\n    $.datepicker.markerClassName = '_has-datepicker';\n\n    /**\n     * Extend JQuery date picker prototype with store local time methods\n     */\n    $.extend(datepickerPrototype, {\n        /**\n         * Get date/time according to store settings.\n         * We use serverTimezoneOffset (in seconds) instead of serverTimezoneSeconds\n         * in order to have ability to know actual store time even if page hadn't been reloaded\n         * @returns {Date}\n         */\n        _getTimezoneDate: function (options) {\n            // local time in ms\n            var ms = Date.now();\n\n            options = options || $.calendarConfig || {};\n\n            // Adjust milliseconds according to store timezone offset,\n            // mind the GMT zero offset\n            if (typeof options.serverTimezoneOffset !== 'undefined') {\n                // Make UTC time and add store timezone offset in seconds\n                ms += new Date().getTimezoneOffset() * 60 * 1000 + options.serverTimezoneOffset * 1000;\n            } else if (typeof options.serverTimezoneSeconds !== 'undefined') {\n                //Set milliseconds according to client local timezone offset\n                ms = (options.serverTimezoneSeconds + new Date().getTimezoneOffset() * 60) * 1000;\n            }\n\n            return new Date(ms);\n        },\n\n        /**\n         * Set date/time according to store settings.\n         * @param {String|Object} target - the target input field or division or span\n         */\n        _setTimezoneDateDatepicker: function (target) {\n            this._setDateDatepicker(target, this._getTimezoneDate());\n        }\n    });\n\n    /**\n     * Widget calendar\n     */\n    $.widget('mage.calendar', {\n        options: {\n            autoComplete: true\n        },\n\n        /**\n         * Merge global options with options passed to widget invoke\n         * @protected\n         */\n        _create: function () {\n            this._enableAMPM();\n            this.options = $.extend(\n                {},\n                $.calendarConfig ? $.calendarConfig : {},\n                this.options.showsTime ? {\n                    showTime: true,\n                    showHour: true,\n                    showMinute: true\n                } : {},\n                this.options\n            );\n            this._initPicker(this.element);\n            this._overwriteGenerateHtml();\n        },\n\n        /**\n         * Get picker name\n         * @protected\n         */\n        _picker: function () {\n            return this.options.showsTime ? 'datetimepicker' : 'datepicker';\n        },\n\n        /**\n         * Fix for Timepicker - Set ampm option for Timepicker if timeformat contains string 'tt'\n         * @protected\n         */\n        _enableAMPM: function () {\n            if (this.options.timeFormat && this.options.timeFormat.indexOf('tt') >= 0) {\n                this.options.ampm = true;\n            }\n        },\n\n        /**\n         * Wrapper for overwrite jQuery UI datepicker function.\n         */\n        _overwriteGenerateHtml: function () {\n            /**\n             * Overwrite jQuery UI datepicker function.\n             * Reason: magento date could be set before calendar show\n             * but local date will be styled as current in original _generateHTML\n             *\n             * @param {Object} inst - instance datepicker.\n             * @return {String} html template\n             */\n            $.datepicker.constructor.prototype._generateHTML = function (inst) {\n                var today = this._getTimezoneDate(),\n                    isRTL = this._get(inst, 'isRTL'),\n                    showButtonPanel = this._get(inst, 'showButtonPanel'),\n                    hideIfNoPrevNext = this._get(inst, 'hideIfNoPrevNext'),\n                    navigationAsDateFormat = this._get(inst, 'navigationAsDateFormat'),\n                    numMonths = this._getNumberOfMonths(inst),\n                    showCurrentAtPos = this._get(inst, 'showCurrentAtPos'),\n                    stepMonths = this._get(inst, 'stepMonths'),\n                    isMultiMonth = parseInt(numMonths[0], 10) !== 1 || parseInt(numMonths[1], 10) !== 1,\n                    currentDate = this._daylightSavingAdjust(!inst.currentDay ? new Date(9999, 9, 9) :\n                        new Date(inst.currentYear, inst.currentMonth, inst.currentDay)),\n                    minDate = this._getMinMaxDate(inst, 'min'),\n                    maxDate = this._getMinMaxDate(inst, 'max'),\n                    drawMonth = inst.drawMonth - showCurrentAtPos,\n                    drawYear = inst.drawYear,\n                    maxDraw,\n                    prevText = this._get(inst, 'prevText'),\n                    prev,\n                    nextText = this._get(inst, 'nextText'),\n                    next,\n                    currentText = this._get(inst, 'currentText'),\n                    gotoDate,\n                    controls,\n                    buttonPanel,\n                    firstDay,\n                    showWeek = this._get(inst, 'showWeek'),\n                    dayNames = this._get(inst, 'dayNames'),\n                    dayNamesMin = this._get(inst, 'dayNamesMin'),\n                    monthNames = this._get(inst, 'monthNames'),\n                    monthNamesShort =  this._get(inst, 'monthNamesShort'),\n                    beforeShowDay = this._get(inst, 'beforeShowDay'),\n                    showOtherMonths = this._get(inst, 'showOtherMonths'),\n                    selectOtherMonths = this._get(inst, 'selectOtherMonths'),\n                    defaultDate = this._getDefaultDate(inst),\n                    html = '',\n                    row = 0,\n                    col = 0,\n                    selectedDate,\n                    cornerClass = ' ui-corner-all',\n                    group = '',\n                    calender = '',\n                    dow = 0,\n                    thead,\n                    day,\n                    daysInMonth,\n                    leadDays,\n                    curRows,\n                    numRows,\n                    printDate,\n                    dRow = 0,\n                    tbody,\n                    daySettings,\n                    otherMonth,\n                    unselectable;\n\n                if (drawMonth < 0) {\n                    drawMonth += 12;\n                    drawYear--;\n                }\n\n                if (maxDate) {\n                    maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),\n                        maxDate.getMonth() - numMonths[0] * numMonths[1] + 1, maxDate.getDate()));\n                    maxDraw = minDate && maxDraw < minDate ? minDate : maxDraw;\n\n                    while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {\n                        drawMonth--;\n\n                        if (drawMonth < 0) {\n                            drawMonth = 11;\n                            drawYear--;\n\n                        }\n                    }\n                }\n                inst.drawMonth = drawMonth;\n                inst.drawYear = drawYear;\n                prevText = !navigationAsDateFormat ? prevText : this.formatDate(prevText,\n                    this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),\n                    this._getFormatConfig(inst));\n                prev = this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?\n                    '<a class=\"ui-datepicker-prev ui-corner-all\" data-handler=\"prev\" data-event=\"click\"' +\n                    ' title=\"' + prevText + '\">' +\n                    '<span class=\"ui-icon ui-icon-circle-triangle-' + (isRTL ? 'e' : 'w') + '\">' +\n                    '' + prevText + '</span></a>'\n                    : hideIfNoPrevNext ? ''\n                        :   '<a class=\"ui-datepicker-prev ui-corner-all ui-state-disabled\" title=\"' +\n                            '' + prevText + '\"><span class=\"ui-icon ui-icon-circle-triangle-' +\n                            '' + (isRTL ? 'e' : 'w') + '\">' + prevText + '</span></a>';\n                nextText = !navigationAsDateFormat ?\n                    nextText\n                    :   this.formatDate(nextText,\n                        this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),\n                        this._getFormatConfig(inst));\n                next = this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?\n                    '<a class=\"ui-datepicker-next ui-corner-all\" data-handler=\"next\" data-event=\"click\"' +\n                    'title=\"' + nextText + '\"><span class=\"ui-icon ui-icon-circle-triangle-' +\n                    '' + (isRTL ? 'w' : 'e') + '\">' + nextText + '</span></a>'\n                    : hideIfNoPrevNext ? ''\n                        :   '<a class=\"ui-datepicker-next ui-corner-all ui-state-disabled\" title=\"' + nextText + '\">' +\n                            '<span class=\"ui-icon ui-icon-circle-triangle-' + (isRTL ? 'w' : 'e') + '\">' + nextText +\n                            '</span></a>';\n                gotoDate = this._get(inst, 'gotoCurrent') && inst.currentDay ? currentDate : today;\n                currentText = !navigationAsDateFormat ? currentText :\n                    this.formatDate(currentText, gotoDate, this._getFormatConfig(inst));\n                controls = !inst.inline ?\n                    '<button type=\"button\" class=\"ui-datepicker-close ui-state-default ui-priority-primary ' +\n                    'ui-corner-all\" data-handler=\"hide\" data-event=\"click\">' +\n                    this._get(inst, 'closeText') + '</button>'\n                    : '';\n                buttonPanel = showButtonPanel ?\n                    '<div class=\"ui-datepicker-buttonpane ui-widget-content\">' + (isRTL ? controls : '') +\n                    (this._isInRange(inst, gotoDate) ? '<button type=\"button\" class=\"ui-datepicker-current ' +\n                    'ui-state-default ui-priority-secondary ui-corner-all\" data-handler=\"today\" data-event=\"click\"' +\n                    '>' + currentText + '</button>' : '') + (isRTL ? '' : controls) + '</div>' : '';\n                firstDay = parseInt(this._get(inst, 'firstDay'), 10);\n                firstDay = isNaN(firstDay) ? 0 : firstDay;\n\n                for (row = 0; row < numMonths[0]; row++) {\n                    this.maxRows = 4;\n\n                    for (col = 0; col < numMonths[1]; col++) {\n                        selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));\n\n                        calender = '';\n\n                        if (isMultiMonth) {\n                            calender += '<div class=\"ui-datepicker-group';\n\n                            if (numMonths[1] > 1) {\n                                switch (col) {\n                                    case 0: calender += ' ui-datepicker-group-first';\n                                        cornerClass = ' ui-corner-' + (isRTL ? 'right' : 'left');\n                                        break;\n\n                                    case numMonths[1] - 1: calender += ' ui-datepicker-group-last';\n                                        cornerClass = ' ui-corner-' + (isRTL ? 'left' : 'right');\n                                        break;\n\n                                    default: calender += ' ui-datepicker-group-middle'; cornerClass = '';\n                                }\n                            }\n                            calender += '\">';\n                        }\n                        calender += '<div class=\"ui-datepicker-header ' +\n                            'ui-widget-header ui-helper-clearfix' + cornerClass + '\">' +\n                            (/all|left/.test(cornerClass) && parseInt(row, 10) === 0 ? isRTL ? next : prev : '') +\n                            (/all|right/.test(cornerClass) && parseInt(row, 10) === 0 ? isRTL ? prev : next : '') +\n                            this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,\n                            row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers\n                            '</div><table class=\"ui-datepicker-calendar\"><thead>' +\n                            '<tr>';\n                        thead = showWeek ?\n                            '<th class=\"ui-datepicker-week-col\">' + this._get(inst, 'weekHeader') + '</th>' : '';\n\n                        for (dow = 0; dow < 7; dow++) { // days of the week\n                            day = (dow + firstDay) % 7;\n                            thead += '<th' + ((dow + firstDay + 6) % 7 >= 5 ?\n                                ' class=\"ui-datepicker-week-end\"' : '') + '>' +\n                                '<span title=\"' + dayNames[day] + '\">' + dayNamesMin[day] + '</span></th>';\n                        }\n                        calender += thead + '</tr></thead><tbody>';\n                        daysInMonth = this._getDaysInMonth(drawYear, drawMonth);\n\n                        if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {\n                            inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);\n                        }\n                        leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;\n                        curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate\n                        numRows = isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows;\n                        this.maxRows = numRows;\n                        printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));\n\n                        for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows\n                            calender += '<tr>';\n                            tbody = !showWeek ? '' : '<td class=\"ui-datepicker-week-col\">' +\n                            this._get(inst, 'calculateWeek')(printDate) + '</td>';\n\n                            for (dow = 0; dow < 7; dow++) { // create date picker days\n                                daySettings = beforeShowDay ?\n                                    beforeShowDay.apply(inst.input ? inst.input[0] : null, [printDate]) : [true, ''];\n                                otherMonth = printDate.getMonth() !== drawMonth;\n                                unselectable = otherMonth && !selectOtherMonths || !daySettings[0] ||\n                                minDate && printDate < minDate || maxDate && printDate > maxDate;\n                                tbody += '<td class=\"' +\n                                ((dow + firstDay + 6) % 7 >= 5 ? ' ui-datepicker-week-end' : '') + // highlight weekends\n                                (otherMonth ? ' ui-datepicker-other-month' : '') + // highlight days from other months\n                                (printDate.getTime() === selectedDate.getTime() &&\n                                drawMonth === inst.selectedMonth && inst._keyEvent || // user pressed key\n                                defaultDate.getTime() === printDate.getTime() &&\n                                defaultDate.getTime() === selectedDate.getTime() ?\n                                    // or defaultDate is current printedDate and defaultDate is selectedDate\n                                ' ' + this._dayOverClass : '') + // highlight selected day\n                                (unselectable ? ' ' + this._unselectableClass + ' ui-state-disabled' : '') +\n                                (otherMonth && !showOtherMonths ? '' : ' ' + daySettings[1] + // highlight custom dates\n                                (printDate.getTime() === currentDate.getTime() ? ' ' + this._currentClass : '') +\n                                (printDate.getDate() === today.getDate() && printDate.getMonth() === today.getMonth() &&\n                                printDate.getYear() === today.getYear() ? ' ui-datepicker-today' : '')) + '\"' +\n                                ((!otherMonth || showOtherMonths) && daySettings[2] ?\n                                ' title=\"' + daySettings[2] + '\"' : '') + // cell title\n                                (unselectable ? '' : ' data-handler=\"selectDay\" data-event=\"click\" data-month=\"' +\n                                '' + printDate.getMonth() + '\" data-year=\"' + printDate.getFullYear() + '\"') + '>' +\n                                (otherMonth && !showOtherMonths ? '&#xa0;' : // display for other months\n                                    unselectable ? '<span class=\"ui-state-default\">' + printDate.getDate() + '</span>'\n                                        : '<a class=\"ui-state-default' +\n                                    (printDate.getTime() === today.getTime() ? ' ' : '') +\n                                    (printDate.getTime() === currentDate.getTime() ? ' ui-state-active' : '') +\n                                    (otherMonth ? ' ui-priority-secondary' : '') +\n                                    '\" href=\"#\">' + printDate.getDate() + '</a>') + '</td>';\n                                printDate.setDate(printDate.getDate() + 1);\n                                printDate = this._daylightSavingAdjust(printDate);\n                            }\n                            calender += tbody + '</tr>';\n                        }\n                        drawMonth++;\n\n                        if (drawMonth > 11) {\n                            drawMonth = 0;\n                            drawYear++;\n                        }\n                        calender += '</tbody></table>' + (isMultiMonth ? '</div>' +\n                        (numMonths[0] > 0 && col === numMonths[1] - 1 ? '<div class=\"ui-datepicker-row-break\"></div>'\n                            : '') : '');\n                        group += calender;\n                    }\n                    html += group;\n                }\n                html += buttonPanel + ($.ui.ie6 && !inst.inline ?\n                    '<iframe src=\"javascript:false;\" class=\"ui-datepicker-cover\" frameborder=\"0\"></iframe>' : '');\n                inst._keyEvent = false;\n\n                return html;\n            };\n        },\n\n        /**\n         * Set current date if the date is not set\n         * @protected\n         * @param {Object} element\n         */\n        _setCurrentDate: function (element) {\n            if (!element.val()) {\n                element[this._picker()]('setTimezoneDate').val('');\n            }\n        },\n\n        /**\n         * Init Datetimepicker\n         * @protected\n         * @param {Object} element\n         */\n        _initPicker: function (element) {\n            var picker = element[this._picker()](this.options),\n                pickerButtonText = picker.next('.ui-datepicker-trigger')\n                    .find('img')\n                    .attr('title');\n\n            picker.next('.ui-datepicker-trigger')\n                .addClass('v-middle')\n                .text('') // Remove jQuery UI datepicker generated image\n                .append('<span>' + pickerButtonText + '</span>');\n\n            $(element).attr('autocomplete', this.options.autoComplete ? 'on' : 'off');\n\n            this._setCurrentDate(element);\n        },\n\n        /**\n         * destroy instance of datetimepicker\n         */\n        _destroy: function () {\n            this.element[this._picker()]('destroy');\n            this._super();\n        },\n\n        /**\n         * Method is kept for backward compatibility and unit-tests acceptance\n         * see \\mage\\calendar\\calendar-test.js\n         * @return {Object} date\n         */\n        getTimezoneDate: function () {\n            return datepickerPrototype._getTimezoneDate.call(this, this.options);\n        }\n    });\n\n    calendarBasePrototype = $.mage.calendar.prototype;\n\n    /**\n     * Extension for Calendar - date and time format convert functionality\n     * @var {Object}\n     */\n    $.widget('mage.calendar', $.extend({}, calendarBasePrototype,\n            /** @lends {$.mage.calendar.prototype} */ {\n                /**\n                 * key - backend format, value - jquery format\n                 * @type {Object}\n                 * @private\n                 */\n                dateTimeFormat: {\n                    date: {\n                        'EEEE': 'DD',\n                        'EEE': 'D',\n                        'EE': 'D',\n                        'E': 'D',\n                        'D': 'o',\n                        'MMMM': 'MM',\n                        'MMM': 'M',\n                        'MM': 'mm',\n                        'M': 'mm',\n                        'yyyy': 'yy',\n                        'y': 'yy',\n                        'Y': 'yy',\n                        'yy': 'yy' // Always long year format on frontend\n                    },\n                    time: {\n                        'a': 'TT'\n                    }\n                },\n\n                /**\n                 * Add Date and Time converting to _create method\n                 * @protected\n                 */\n                _create: function () {\n                    if (this.options.dateFormat) {\n                        this.options.dateFormat = this._convertFormat(this.options.dateFormat, 'date');\n                    }\n\n                    if (this.options.timeFormat) {\n                        this.options.timeFormat = this._convertFormat(this.options.timeFormat, 'time');\n                    }\n                    calendarBasePrototype._create.apply(this, arguments);\n                },\n\n                /**\n                 * Converting date or time format\n                 * @protected\n                 * @param {String} format\n                 * @param {String} type\n                 * @return {String}\n                 */\n                _convertFormat: function (format, type) {\n                    var symbols = format.match(/([a-z]+)/ig),\n                        separators = format.match(/([^a-z]+)/ig),\n                        self = this,\n                        convertedFormat = '';\n\n                    if (symbols) {\n                        $.each(symbols, function (key, val) {\n                            convertedFormat +=\n                                (self.dateTimeFormat[type][val] || val) +\n                                (separators[key] || '');\n                        });\n                    }\n\n                    return convertedFormat;\n                }\n            })\n    );\n\n    /**\n     * Widget dateRange\n     * @extends $.mage.calendar\n     */\n    $.widget('mage.dateRange', $.mage.calendar, {\n\n        /**\n         * creates two instances of datetimepicker for date range selection\n         * @protected\n         */\n        _initPicker: function () {\n            var from,\n                to;\n\n            if (this.options.from && this.options.to) {\n                from = this.element.find('#' + this.options.from.id);\n                to = this.element.find('#' + this.options.to.id);\n                this.options.onSelect = $.proxy(function (selectedDate) {\n                    to[this._picker()]('option', 'minDate', selectedDate);\n                }, this);\n                $.mage.calendar.prototype._initPicker.call(this, from);\n                from.on('change', $.proxy(function () {\n                    to[this._picker()]('option', 'minDate', from[this._picker()]('getDate'));\n                }, this));\n                this.options.onSelect = $.proxy(function (selectedDate) {\n                    from[this._picker()]('option', 'maxDate', selectedDate);\n                }, this);\n                $.mage.calendar.prototype._initPicker.call(this, to);\n                to.on('change', $.proxy(function () {\n                    from[this._picker()]('option', 'maxDate', to[this._picker()]('getDate'));\n                }, this));\n            }\n        },\n\n        /**\n         * destroy two instances of datetimepicker\n         */\n        _destroy: function () {\n            if (this.options.from) {\n                this.element.find('#' + this.options.from.id)[this._picker()]('destroy');\n            }\n\n            if (this.options.to) {\n                this.element.find('#' + this.options.to.id)[this._picker()]('destroy');\n            }\n            this._super();\n        }\n    });\n\n    // Overrides the \"today\" button functionality to select today's date when clicked.\n    $.datepicker._gotoTodayOriginal = $.datepicker._gotoToday;\n\n    /**\n     * overwrite jQuery UI _showDatepicker function for proper HTML generation conditions.\n     *\n     */\n    $.datepicker._showDatepickerOriginal = $.datepicker._showDatepicker;\n\n    /**\n     * Triggers original method showDataPicker for rendering calendar\n     * @param {HTMLObject} input\n     * @private\n     */\n    $.datepicker._showDatepicker = function (input) {\n        if (!input.disabled) {\n            $.datepicker._showDatepickerOriginal.call(this, input);\n        }\n    };\n\n    /**\n     * _gotoToday\n     * @param {Object} el\n     */\n    $.datepicker._gotoToday = function (el) {\n        //Set date/time according to timezone offset\n        $(el).datepicker('setTimezoneDate')\n            // To ensure that user can re-select date field without clicking outside it first.\n            .blur().trigger('change');\n    };\n\n    return {\n        dateRange:  $.mage.dateRange,\n        calendar:   $.mage.calendar\n    };\n});\n","mage/collapsible.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'jquery-ui-modules/widget',\n    'jquery-ui-modules/core',\n    'jquery/jquery-storageapi',\n    'mage/mage'\n], function ($) {\n    'use strict';\n\n    var hideProps = {},\n        showProps = {};\n\n    hideProps.height = 'hide';\n    showProps.height = 'show';\n\n    $.widget('mage.collapsible', {\n        options: {\n            active: false,\n            disabled: false,\n            collapsible: true,\n            header: '[data-role=title]',\n            content: '[data-role=content]',\n            trigger: '[data-role=trigger]',\n            closedState: null,\n            openedState: null,\n            disabledState: null,\n            ajaxUrlElement: '[data-ajax=true]',\n            ajaxContent: false,\n            loadingClass: null,\n            saveState: false,\n            animate: false,\n            icons: {\n                activeHeader: null,\n                header: null\n            },\n            collateral: {\n                element: null,\n                openedState: null\n            }\n        },\n\n        /**\n         * @private\n         */\n        _create: function () {\n            this.storage = $.localStorage;\n            this.icons = false;\n\n            if (typeof this.options.icons === 'string') {\n                this.options.icons = $.parseJSON(this.options.icons);\n            }\n\n            this._processPanels();\n            this._processState();\n            this._refresh();\n\n            if (this.options.icons.header && this.options.icons.activeHeader) {\n                this._createIcons();\n                this.icons = true;\n            }\n\n            this.element.on('dimensionsChanged', function (e) {\n                if (e.target && e.target.classList.contains('active')) {\n                    this._scrollToTopIfNotVisible();\n                }\n            }.bind(this));\n\n            this._bind('click');\n            this._trigger('created');\n        },\n\n        /**\n         * @private\n         */\n        _refresh: function () {\n            this.trigger.attr('tabIndex', 0);\n\n            if (this.options.active && !this.options.disabled) {\n                if (this.options.openedState) {\n                    this.element.addClass(this.options.openedState);\n                }\n\n                if (this.options.collateral.element && this.options.collateral.openedState) {\n                    $(this.options.collateral.element).addClass(this.options.collateral.openedState);\n                }\n\n                if (this.options.ajaxContent) {\n                    this._loadContent();\n                }\n                // ARIA (updates aria attributes)\n                this.header.attr({\n                    'aria-selected': false\n                });\n            } else if (this.options.disabled) {\n                this.disable();\n            } else {\n                this.content.hide();\n\n                if (this.options.closedState) {\n                    this.element.addClass(this.options.closedState);\n                }\n            }\n        },\n\n        /**\n         * Processing the state:\n         *     If deep linking is used and the anchor is the id of the content or the content contains this id,\n         *     and the collapsible element is a nested one having collapsible parents, in order to see the content,\n         *     all the parents must be expanded.\n         * @private\n         */\n        _processState: function () {\n            var anchor = window.location.hash,\n                isValid = $.mage.isValidSelector(anchor),\n                urlPath = window.location.pathname.replace(/\\./g, ''),\n                state;\n\n            this.stateKey = encodeURIComponent(urlPath + this.element.attr('id'));\n\n            if (isValid &&\n                ($(this.content.find(anchor)).length > 0 || this.content.attr('id') === anchor.replace('#', ''))\n            ) {\n                this.element.parents('[data-collapsible=true]').collapsible('forceActivate');\n\n                if (!this.options.disabled) {\n                    this.options.active = true;\n\n                    if (this.options.saveState) { //eslint-disable-line max-depth\n                        this.storage.set(this.stateKey, true);\n                    }\n                }\n            } else if (this.options.saveState && !this.options.disabled) {\n                state = this.storage.get(this.stateKey);\n\n                if (typeof state === 'undefined' || state === null) {\n                    this.storage.set(this.stateKey, this.options.active);\n                } else if (state === true) {\n                    this.options.active = true;\n                } else if (state === false) {\n                    this.options.active = false;\n                }\n            }\n        },\n\n        /**\n         * @private\n         */\n        _createIcons: function () {\n            var icons = this.options.icons;\n\n            if (icons) {\n                $('<span>')\n                    .addClass(icons.header)\n                    .attr('data-role', 'icons')\n                    .prependTo(this.header);\n\n                if (this.options.active && !this.options.disabled) {\n                    this.header.children('[data-role=icons]')\n                        .removeClass(icons.header)\n                        .addClass(icons.activeHeader);\n                }\n            }\n        },\n\n        /**\n         * @private\n         */\n        _destroyIcons: function () {\n            this.header\n                .children('[data-role=icons]')\n                .remove();\n        },\n\n        /**\n         * @private\n         */\n        _destroy: function () {\n            var options = this.options;\n\n            this.element.removeAttr('data-collapsible');\n\n            this.trigger.removeAttr('tabIndex');\n\n            if (options.openedState) {\n                this.element.removeClass(options.openedState);\n            }\n\n            if (this.options.collateral.element && this.options.collateral.openedState) {\n                $(this.options.collateral.element).removeClass(this.options.collateral.openedState);\n            }\n\n            if (options.closedState) {\n                this.element.removeClass(options.closedState);\n            }\n\n            if (options.disabledState) {\n                this.element.removeClass(options.disabledState);\n            }\n\n            if (this.icons) {\n                this._destroyIcons();\n            }\n        },\n\n        /**\n         * @private\n         */\n        _processPanels: function () {\n            var headers, triggers;\n\n            this.element.attr('data-collapsible', 'true');\n\n            if (typeof this.options.header === 'object') {\n                this.header = this.options.header;\n            } else {\n                headers = this.element.find(this.options.header);\n\n                if (headers.length > 0) {\n                    this.header = headers.eq(0);\n                } else {\n                    this.header = this.element;\n                }\n            }\n\n            if (typeof this.options.content === 'object') {\n                this.content = this.options.content;\n            } else {\n                this.content = this.header.next(this.options.content).eq(0);\n            }\n\n            // ARIA (init aria attributes)\n            if (this.header.attr('id')) {\n                this.content.attr('aria-labelledby', this.header.attr('id'));\n            }\n\n            if (this.content.attr('id')) {\n                this.header.attr('aria-controls', this.content.attr('id'));\n            }\n\n            this.header\n                .attr({\n                    'role': 'tab',\n                    'aria-selected': this.options.active,\n                    'aria-expanded': this.options.active\n                });\n\n            // For collapsible widget only (not tabs or accordion)\n            if (this.header.parent().attr('role') !== 'presentation') {\n                this.header\n                    .parent()\n                    .attr('role', 'tablist');\n            }\n\n            this.content.attr({\n                'role': 'tabpanel',\n                'aria-hidden': !this.options.active\n            });\n\n            if (typeof this.options.trigger === 'object') {\n                this.trigger = this.options.trigger;\n            } else {\n                triggers = this.header.find(this.options.trigger);\n\n                if (triggers.length > 0) {\n                    this.trigger = triggers.eq(0);\n                } else {\n                    this.trigger = this.header;\n                }\n            }\n        },\n\n        /**\n         * @param {jQuery.Event} event\n         * @private\n         */\n        _keydown: function (event) {\n            var keyCode;\n\n            if (event.altKey || event.ctrlKey) {\n                return;\n            }\n\n            keyCode = $.ui.keyCode;\n\n            switch (event.keyCode) {\n                case keyCode.SPACE:\n                case keyCode.ENTER:\n                    this._eventHandler(event);\n                    break;\n            }\n\n        },\n\n        /**\n         * @param {jQuery.Event} event\n         * @private\n         */\n        _bind: function (event) {\n            var self = this;\n\n            this.events = {\n                keydown: '_keydown'\n            };\n\n            if (event) {\n                $.each(event.split(' '), function (index, eventName) {\n                    self.events[eventName] = '_eventHandler';\n                });\n            }\n            this._off(this.trigger);\n\n            if (!this.options.disabled) {\n                this._on(this.trigger, this.events);\n            }\n        },\n\n        /**\n         * Disable.\n         */\n        disable: function () {\n            this.options.disabled = true;\n            this._off(this.trigger);\n            this.forceDeactivate();\n\n            if (this.options.disabledState) {\n                this.element.addClass(this.options.disabledState);\n            }\n            this.trigger.attr('tabIndex', -1);\n        },\n\n        /**\n         * Enable.\n         */\n        enable: function () {\n            this.options.disabled = false;\n            this._on(this.trigger, this.events);\n            this.forceActivate();\n\n            if (this.options.disabledState) {\n                this.element.removeClass(this.options.disabledState);\n            }\n            this.trigger.attr('tabIndex', 0);\n        },\n\n        /**\n         * @param {jQuery.Event} event\n         * @private\n         */\n        _eventHandler: function (event) {\n\n            if (this.options.active && this.options.collapsible) {\n                this.deactivate();\n            } else {\n                this.activate();\n\n            }\n            event.preventDefault();\n\n        },\n\n        /**\n         * @param {*} prop\n         * @private\n         */\n        _animate: function (prop) {\n            var duration,\n                easing,\n                animate = this.options.animate;\n\n            if (typeof animate === 'number') {\n                duration = animate;\n            }\n\n            if (typeof animate === 'string') {\n                animate = $.parseJSON(animate);\n            }\n            duration = duration || animate.duration;\n            easing = animate.easing;\n            this.content.animate(prop, duration, easing);\n        },\n\n        /**\n         * Deactivate.\n         */\n        deactivate: function () {\n            if (this.options.animate) {\n                this._animate(hideProps);\n            } else {\n                this.content.hide();\n            }\n            this._close();\n        },\n\n        /**\n         * Force deactivate.\n         */\n        forceDeactivate: function () {\n            this.content.hide();\n            this._close();\n\n        },\n\n        /**\n         * @private\n         */\n        _close: function () {\n            this.options.active = false;\n\n            if (this.options.saveState) {\n                this.storage.set(this.stateKey, false);\n            }\n\n            if (this.options.openedState) {\n                this.element.removeClass(this.options.openedState);\n            }\n\n            if (this.options.collateral.element && this.options.collateral.openedState) {\n                $(this.options.collateral.element).removeClass(this.options.collateral.openedState);\n            }\n\n            if (this.options.closedState) {\n                this.element.addClass(this.options.closedState);\n            }\n\n            if (this.icons) {\n                this.header.children('[data-role=icons]')\n                    .removeClass(this.options.icons.activeHeader)\n                    .addClass(this.options.icons.header);\n            }\n\n            // ARIA (updates aria attributes)\n            this.header.attr({\n                'aria-selected': 'false',\n                'aria-expanded': 'false'\n            });\n            this.content.attr({\n                'aria-hidden': 'true'\n            });\n\n            this.element.trigger('dimensionsChanged', {\n                opened: false\n            });\n        },\n\n        /**\n         * Activate.\n         *\n         * @return void;\n         */\n        activate: function () {\n            if (this.options.disabled) {\n                return;\n            }\n\n            if (this.options.animate) {\n                this._animate(showProps);\n            } else {\n                this.content.show();\n            }\n            this._open();\n        },\n\n        /**\n         * Force activate.\n         */\n        forceActivate: function () {\n            if (!this.options.disabled) {\n                this.content.show();\n                this._open();\n            }\n        },\n\n        /**\n         * @private\n         */\n        _open: function () {\n            this.element.trigger('beforeOpen');\n            this.options.active = true;\n\n            if (this.options.ajaxContent) {\n                this._loadContent();\n            }\n\n            if (this.options.saveState) {\n                this.storage.set(this.stateKey, true);\n            }\n\n            if (this.options.openedState) {\n                this.element.addClass(this.options.openedState);\n            }\n\n            if (this.options.collateral.element && this.options.collateral.openedState) {\n                $(this.options.collateral.element).addClass(this.options.collateral.openedState);\n            }\n\n            if (this.options.closedState) {\n                this.element.removeClass(this.options.closedState);\n            }\n\n            if (this.icons) {\n                this.header.children('[data-role=icons]')\n                    .removeClass(this.options.icons.header)\n                    .addClass(this.options.icons.activeHeader);\n            }\n\n            // ARIA (updates aria attributes)\n            this.header.attr({\n                'aria-selected': 'true',\n                'aria-expanded': 'true'\n            });\n            this.content.attr({\n                'aria-hidden': 'false'\n            });\n\n            this.element.trigger('dimensionsChanged', {\n                opened: true\n            });\n        },\n\n        /**\n         * @private\n         */\n        _loadContent: function () {\n            var url = this.element.find(this.options.ajaxUrlElement).attr('href'),\n                that = this;\n\n            if (url) {\n                that.xhr = $.get({\n                    url: url,\n                    dataType: 'html'\n                }, function () {\n                });\n            }\n\n            if (that.xhr && that.xhr.statusText !== 'canceled') {\n                if (that.options.loadingClass) {\n                    that.element.addClass(that.options.loadingClass);\n                }\n                that.content.attr('aria-busy', 'true');\n                that.xhr.done(function (response) {\n                    setTimeout(function () {\n                        that.content.html(response);\n                    }, 1);\n                });\n                that.xhr.always(function (jqXHR, status) {\n                    setTimeout(function () {\n                        if (status === 'abort') {\n                            that.content.stop(false, true);\n                        }\n\n                        if (that.options.loadingClass) {\n                            that.element.removeClass(that.options.loadingClass);\n                        }\n                        that.content.removeAttr('aria-busy');\n\n                        if (jqXHR === that.xhr) {\n                            delete that.xhr;\n                        }\n                    }, 1);\n                });\n            }\n        },\n\n        /**\n         * @private\n         */\n        _scrollToTopIfNotVisible: function () {\n            if (this._isElementOutOfViewport()) {\n                this.header[0].scrollIntoView();\n            }\n        },\n\n        /**\n         * @private\n         * @return {Boolean}\n         */\n        _isElementOutOfViewport: function () {\n            var headerRect = this.header[0].getBoundingClientRect(),\n                contentRect = this.content.get().length ? this.content[0].getBoundingClientRect() : false,\n                headerOut,\n                contentOut;\n\n            headerOut = headerRect.bottom - headerRect.height < 0 ||\n                headerRect.right - headerRect.width < 0 ||\n                headerRect.left + headerRect.width > window.innerWidth ||\n                headerRect.top + headerRect.height > window.innerHeight;\n\n            contentOut = contentRect ? contentRect.bottom - contentRect.height < 0 ||\n                contentRect.right - contentRect.width < 0 ||\n                contentRect.left + contentRect.width > window.innerWidth ||\n                contentRect.top + contentRect.height > window.innerHeight : false;\n\n            return headerOut ? headerOut : contentOut;\n        }\n    });\n\n    return $.mage.collapsible;\n});\n","mage/common.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'domReady!'\n], function ($) {\n    'use strict';\n\n    /* Form with auto submit feature */\n    $('form[data-auto-submit=\"true\"]').submit();\n\n    //Add form keys.\n    $(document).on(\n        'submit',\n        'form',\n        function (e) {\n            var formKeyElement,\n                existingFormKeyElement,\n                isKeyPresentInForm,\n                isActionExternal,\n                baseUrl = window.BASE_URL,\n                form = $(e.target),\n                formKey = $('input[name=\"form_key\"]').val(),\n                formMethod = form.prop('method'),\n                formAction = form.prop('action');\n\n            isActionExternal = formAction.indexOf(baseUrl) !== 0;\n\n            existingFormKeyElement = form.find('input[name=\"form_key\"]');\n            isKeyPresentInForm = existingFormKeyElement.length;\n\n            /* Verifies that existing auto-added form key is a direct form child element,\n               protection from a case when one form contains another form. */\n            if (isKeyPresentInForm && existingFormKeyElement.attr('auto-added-form-key') === '1') {\n                isKeyPresentInForm = form.find('> input[name=\"form_key\"]').length;\n            }\n\n            if (formKey && !isKeyPresentInForm && !isActionExternal && formMethod !== 'get') {\n                formKeyElement = document.createElement('input');\n                formKeyElement.setAttribute('type', 'hidden');\n                formKeyElement.setAttribute('name', 'form_key');\n                formKeyElement.setAttribute('value', formKey);\n                formKeyElement.setAttribute('auto-added-form-key', '1');\n                form.get(0).appendChild(formKeyElement);\n            }\n        }\n    );\n});\n","mage/cookies.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'mage/mage',\n    'jquery/jquery.cookie'\n], function ($) {\n    'use strict';\n\n    /**\n     * Helper for cookies manipulation\n     * @returns {CookieHelper}\n     * @constructor\n     */\n    var CookieHelper = function () {\n\n        /**\n         * Cookie default values.\n         * @type {Object}\n         */\n        this.defaults = {\n            expires: null,\n            path: '/',\n            domain: null,\n            secure: false,\n            lifetime: null,\n            samesite: 'lax'\n        };\n\n        /**\n         * Calculate cookie expiration date based on its lifetime.\n         * @param {Object} options - Cookie option values\n         * @return {Date|null} Calculated cookie expiration date or null if no lifetime provided.\n         * @private\n         */\n        function lifetimeToExpires(options, defaults) {\n            var expires,\n                lifetime;\n\n            lifetime = options.lifetime || defaults.lifetime;\n\n            if (lifetime && lifetime > 0) {\n                expires = options.expires || new Date();\n\n                return new Date(expires.getTime() + lifetime * 1000);\n            }\n\n            return null;\n        }\n\n        /**\n         * Set a cookie's value by cookie name based on optional cookie options.\n         * @param {String} name - The name of the cookie.\n         * @param {String} value - The cookie's value.\n         * @param {Object} options - Optional options (e.g. lifetime, expires, path, etc.)\n         */\n        this.set = function (name, value, options) {\n            var expires,\n                path,\n                domain,\n                secure,\n                samesite;\n\n            options = $.extend({}, this.defaults, options || {});\n            expires = lifetimeToExpires(options, this.defaults) || options.expires;\n            path = options.path;\n            domain = options.domain;\n            secure = options.secure;\n            samesite = options.samesite;\n\n            document.cookie = name + '=' + encodeURIComponent(value) +\n                (expires ? '; expires=' + expires.toUTCString() :  '') +\n                (path ? '; path=' + path : '') +\n                (domain ? '; domain=' + domain : '') +\n                (secure ? '; secure' : '') +\n                (samesite ? '; samesite=' + samesite : 'lax');\n        };\n\n        /**\n         * Get a cookie's value by cookie name.\n         * @param {String} name  - The name of the cookie.\n         * @return {(null|String)}\n         */\n        this.get = function (name) {\n            var arg = name + '=',\n                aLength = arg.length,\n                cookie = document.cookie,\n                cLength = cookie.length,\n                i = 0,\n                j = 0;\n\n            while (i < cLength) {\n                j = i + aLength;\n\n                if (cookie.substring(i, j) === arg) {\n                    return this.getCookieVal(j);\n                }\n                i = cookie.indexOf(' ', i) + 1;\n\n                if (i === 0) {\n                    break;\n                }\n            }\n\n            return null;\n        };\n\n        /**\n         * Clear a cookie's value by name.\n         * @param {String} name - The name of the cookie being cleared.\n         */\n        this.clear = function (name) {\n            if (this.get(name)) {\n                this.set(name, '', {\n                    expires: new Date('Jan 01 1970 00:00:01 GMT')\n                });\n            }\n        };\n\n        /**\n         * Return URI decoded cookie component value (e.g. expires, path, etc.) based on a\n         * numeric offset in the document's cookie value.\n         * @param {Number} offset - Offset into the document's cookie value.\n         * @return {String}\n         */\n        this.getCookieVal = function (offset) {\n            var cookie = document.cookie,\n                endstr = cookie.indexOf(';', offset);\n\n            if (endstr === -1) {\n                endstr = cookie.length;\n            }\n\n            return decodeURIComponent(cookie.substring(offset, endstr));\n        };\n\n        return this;\n    };\n\n    $.extend(true, $, {\n        mage: {\n            cookies: new CookieHelper()\n        }\n    });\n\n    return function (pageOptions) {\n        $.extend($.mage.cookies.defaults, pageOptions);\n        $.extend($.cookie.defaults, $.mage.cookies.defaults);\n    };\n});\n","mage/dataPost.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'mage/template',\n    'Magento_Ui/js/modal/confirm',\n    'jquery-ui-modules/widget'\n], function ($, mageTemplate, uiConfirm) {\n    'use strict';\n\n    $.widget('mage.dataPost', {\n        options: {\n            formTemplate: '<form action=\"<%- data.action %>\" method=\"post\">' +\n            '<% _.each(data.data, function(value, index) { %>' +\n            '<input name=\"<%- index %>\" value=\"<%- value %>\">' +\n            '<% }) %></form>',\n            postTrigger: ['a[data-post]', 'button[data-post]', 'span[data-post]'],\n            formKeyInputSelector: 'input[name=\"form_key\"]'\n        },\n\n        /** @inheritdoc */\n        _create: function () {\n            this._bind();\n        },\n\n        /** @inheritdoc */\n        _bind: function () {\n            var events = {};\n\n            $.each(this.options.postTrigger, function (index, value) {\n                events['click ' + value] = '_postDataAction';\n            });\n\n            this._on(events);\n        },\n\n        /**\n         * Handler for click.\n         *\n         * @param {Object} e\n         * @private\n         */\n        _postDataAction: function (e) {\n            var params = $(e.currentTarget).data('post');\n\n            e.preventDefault();\n            this.postData(params);\n        },\n\n        /**\n         * Data post action.\n         *\n         * @param {Object} params\n         */\n        postData: function (params) {\n            var formKey = $(this.options.formKeyInputSelector).val(),\n                $form, input;\n\n            if (formKey) {\n                params.data['form_key'] = formKey;\n            }\n\n            $form = $(mageTemplate(this.options.formTemplate, {\n                data: params\n            }));\n\n            if (params.files) {\n                $form[0].enctype = 'multipart/form-data';\n                $.each(params.files, function (key, files) {\n                    if (files instanceof FileList) {\n                        input = document.createElement('input');\n                        input.type = 'file';\n                        input.name = key;\n                        input.files = files;\n                        $form[0].appendChild(input);\n                    }\n                });\n            }\n\n            if (params.data.confirmation) {\n                uiConfirm({\n                    content: params.data.confirmationMessage,\n                    actions: {\n                        /** @inheritdoc */\n                        confirm: function () {\n                            $form.appendTo('body').hide().submit();\n                        }\n                    }\n                });\n            } else {\n                $form.appendTo('body').hide().submit();\n            }\n        }\n    });\n\n    $(document).dataPost();\n\n    return $.mage.dataPost;\n});\n","mage/decorate.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\n/* eslint-disable strict */\ndefine([\n    'jquery',\n    'mage/translate'\n], function ($) {\n    var methods = {\n        /**\n         * Decorate a list (e.g. a <ul> containing <li>) recursively if specified.\n         * @param {Boolean} isRecursive\n         */\n        list: function (isRecursive) {\n            return this.each(function () {\n                var list = $(this),\n                    items;\n\n                if (list.length > 0) {\n                    items = typeof isRecursive === 'undefined' || isRecursive ?\n                        list.find('li') :\n                        list.children();\n                    items.decorate('generic', ['odd', 'even', 'last']);\n                }\n            });\n        },\n\n        /**\n         * Annotate a set of DOM elements with decorator classes.\n         * @param {Array} decoratorParams\n         */\n        generic: function (decoratorParams) {\n            var elements = $(this),\n                allSupportedParams;\n\n            if (elements) {\n                allSupportedParams = {\n                    even: 'odd', // Flip jQuery odd/even so that index 0 is odd.\n                    odd: 'even',\n                    last: 'last',\n                    first: 'first'\n                };\n\n                decoratorParams = decoratorParams || allSupportedParams;\n\n                $.each(decoratorParams, function (index, param) {\n                    if (param === 'even' || param === 'odd') {\n                        elements.filter(':' + param).removeClass('odd even').addClass(allSupportedParams[param]);\n                    } else {\n                        elements.filter(':' + param).addClass(allSupportedParams[param]);\n                    }\n                });\n            }\n\n            return this;\n        },\n\n        /**\n         * Decorate DOM elements in an HTML table with specified classes.\n         * @param {Object} instanceOptions\n         */\n        table: function (instanceOptions) {\n            return this.each(function () {\n                var table = $(this),\n                    options;\n\n                if (table.length > 0) {\n                    options = {\n                        'tbody': false,\n                        'tbody tr': ['odd', 'even', 'first', 'last'],\n                        'thead tr': ['first', 'last'],\n                        'tfoot tr': ['first', 'last'],\n                        'tr td': ['last']\n                    };\n\n                    $.extend(options, instanceOptions || {});\n\n                    $.each(options, function (key, value) {\n                        if (options[key]) {\n                            if (key === 'tr td') {\n                                $.each(table.find('tr'), function () {\n                                    $(this).find('td').decorate('generic', options['tr td']);\n                                });\n                            } else {\n                                table.find(key).decorate('generic', value);\n                            }\n                        }\n                    });\n                }\n            });\n        },\n\n        /**\n         * Annotate data list elements with CSS classes.\n         */\n        dataList: function () {\n            return this.each(function () {\n                var list = $(this);\n\n                if (list) {\n                    list.find('dt').decorate('generic', ['odd', 'even', 'last']);\n                    list.find('dd').decorate('generic', ['odd', 'even', 'last']);\n                }\n            });\n        }\n    };\n\n    /**\n     * @param {String} method\n     * @return {*}\n     */\n    $.fn.decorate = function (method) {\n        var message;\n\n        if (methods[method]) {\n            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));\n        } else if (typeof method === 'object' || !method) {\n            return methods.init.apply(this, arguments);\n        }\n\n        message = $.mage.__('Method %s does not exist on jQuery.decorate');\n        $.error(message.replace('%s', method));\n    };\n});\n","mage/deletable-item.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\n/**\n * @deprecated since version 2.2.0\n */\ndefine([\n    'jquery',\n    'jquery-ui-modules/widget'\n], function ($) {\n    'use strict';\n\n    /**\n     * This widget is used to tag a DOM element as deletable. By default, it will use the click event on the item with a\n     * data role of delete to trigger the deletion.\n     */\n    $.widget('mage.deletableItem', {\n        options: {\n            deleteEvent: 'click',\n            deleteSelector: '[data-role=\"delete\"]',\n            hiddenClass: 'no-display'\n        },\n\n        /**\n         * This method binds elements found in this widget.\n         */\n        _bind: function () {\n            var handlers = {};\n\n            // since the first handler is dynamic, generate the object using array notation\n            handlers[this.options.deleteEvent + ' ' + this.options.deleteSelector] = '_onDeleteClicked';\n            handlers.hideDelete = '_onHideDelete';\n            handlers.showDelete = '_onShowDelete';\n\n            this._on(handlers);\n        },\n\n        /**\n         * This method constructs a new widget.\n         */\n        _create: function () {\n            this._bind();\n        },\n\n        /**\n         * This method is to initialize the control\n         * @private\n         */\n        _init: function () {\n            this._onHideDelete(); // by default, hide the control\n        },\n\n        /**\n         * This method removes the entity from the DOM.\n         * @private\n         */\n        _onDeleteClicked: function (e) {\n            e.stopPropagation();\n            this.element.trigger('deleteItem');\n        },\n\n        /**\n         * This method hides the delete capability of this item (i.e. making it not deletable)\n         * @private\n         */\n        _onHideDelete: function () {\n            this.element.find(this.options.deleteSelector).addClass(this.options.hiddenClass);\n        },\n\n        /**\n         * This method shows the delete capability of this item (i.e. making it deletable)\n         * @private\n         */\n        _onShowDelete: function () {\n            this.element.find(this.options.deleteSelector).removeClass(this.options.hiddenClass);\n        }\n    });\n\n    return $.mage.deletableItem;\n});\n","mage/dialog.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\n/**\n * @deprecated since version 2.2.0\n */\ndefine([\n    'jquery',\n    'jquery-ui-modules/dialog'\n], function ($) {\n    'use strict';\n\n    /**\n     * Dialog Widget - this widget is a wrapper for the jQuery UI Dialog\n     */\n    $.widget('mage.dialog', $.ui.dialog, {});\n\n    return $.mage.dialog;\n});\n","mage/dropdown.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'jquery-ui-modules/dialog',\n    'mage/translate'\n], function ($) {\n    'use strict';\n\n    var timer = null;\n\n    /**\n     * Dropdown Widget - this widget is a wrapper for the jQuery UI Dialog\n     */\n    $.widget('mage.dropdownDialog', $.ui.dialog, {\n        options: {\n            triggerEvent: 'click',\n            triggerClass: null,\n            parentClass: null,\n            triggerTarget: null,\n            defaultDialogClass: 'mage-dropdown-dialog',\n            dialogContentClass: null,\n            shadowHinter: null,\n            closeOnMouseLeave: true,\n            closeOnClickOutside: true,\n            minHeight: null,\n            minWidth: null,\n            width: null,\n            modal: false,\n            timeout: null,\n            autoOpen: false,\n            createTitleBar: false,\n            autoPosition: false,\n            autoSize: false,\n            draggable: false,\n            resizable: false,\n            bodyClass: '',\n            buttons: [\n                {\n                    'class': 'action close',\n                    'text': $.mage.__('Close'),\n\n                    /**\n                     * Click action.\n                     */\n                    'click': function () {\n                        $(this).dropdownDialog('close');\n                    }\n                }\n            ]\n        },\n\n        /**\n         * extend default functionality to bind the opener for dropdown\n         * @private\n         */\n        _create: function () {\n            var _self = this;\n\n            this._super();\n            this.uiDialog.addClass(this.options.defaultDialogClass);\n\n            if (_self.options.triggerTarget) {\n                $(_self.options.triggerTarget).on(_self.options.triggerEvent, function (event) {\n                    event.preventDefault();\n                    event.stopPropagation();\n\n                    if (!_self._isOpen) {\n                        $('.' + _self.options.defaultDialogClass + ' > .ui-dialog-content').dropdownDialog('close');\n                        _self.open();\n                    } else {\n                        _self.close(event);\n                    }\n                });\n            }\n\n            if (_self.options.shadowHinter) {\n                _self.hinter = $('<div class=\"' + _self.options.shadowHinter + '\"/>');\n                _self.element.append(_self.hinter);\n            }\n        },\n\n        /**\n         * Extend default functionality to close the dropdown\n         * with custom delay on mouse out and also to close when clicking outside\n         */\n        open: function () {\n            var _self = this;\n\n            this._super();\n\n            if (_self.options.dialogContentClass) {\n                _self.element.addClass(_self.options.dialogContentClass);\n            }\n\n            if (_self.options.closeOnMouseLeave) {\n\n                this._mouseEnter(_self.uiDialog);\n                this._mouseLeave(_self.uiDialog);\n\n                if (_self.options.triggerTarget) {\n                    this._mouseLeave($(_self.options.triggerTarget));\n                }\n            }\n\n            if (_self.options.closeOnClickOutside) {\n                $('body').on('click.outsideDropdown', function (event) {\n                    if (_self._isOpen && !$(event.target).closest('.ui-dialog').length) {\n                        if (timer) {\n                            clearTimeout(timer);\n                        }\n                        _self.close(event);\n                    }\n                });\n            }\n            // adding the class on the opener and parent element for dropdown\n            if (_self.options.triggerClass) {\n                $(_self.options.triggerTarget).addClass(_self.options.triggerClass);\n            }\n\n            if (_self.options.parentClass) {\n                $(_self.options.appendTo).addClass(_self.options.parentClass);\n            }\n\n            if (_self.options.bodyClass) {\n                $('body').addClass(_self.options.bodyClass);\n            }\n\n            if (_self.options.shadowHinter) {\n                _self._setShadowHinterPosition();\n            }\n        },\n\n        /**\n         * extend default functionality to reset the timer and remove the active class for opener\n         */\n        close: function () {\n            this._super();\n\n            if (this.options.dialogContentClass) {\n                this.element.removeClass(this.options.dialogContentClass);\n            }\n\n            if (this.options.triggerClass) {\n                $(this.options.triggerTarget).removeClass(this.options.triggerClass);\n            }\n\n            if (this.options.parentClass) {\n                $(this.options.appendTo).removeClass(this.options.parentClass);\n            }\n\n            if (this.options.bodyClass) {\n                $('body').removeClass(this.options.bodyClass);\n            }\n\n            if (timer) {\n                clearTimeout(timer);\n            }\n\n            if (this.options.triggerTarget) {\n                $(this.options.triggerTarget).off('mouseleave');\n            }\n            this.uiDialog.off('mouseenter');\n            this.uiDialog.off('mouseleave');\n            $('body').off('click.outsideDropdown');\n        },\n\n        /**\n         * _setShadowHinterPosition\n         * @private\n         */\n        _setShadowHinterPosition: function () {\n            var _self = this,\n                offset;\n\n            offset = _self.options.position.of.offset().left -\n                _self.element.offset().left +\n                _self.options.position.of.outerWidth() / 2;\n            offset = isNaN(offset) ? 0 : Math.floor(offset);\n            _self.hinter.css('left', offset);\n        },\n\n        /**\n         * @private\n         */\n        _position: function () {\n            if (this.options.autoPosition) {\n                this._super();\n            }\n        },\n\n        /**\n         * @private\n         */\n        _createTitlebar: function () {\n            if (this.options.createTitleBar) {\n                this._super();\n            } else {\n                // the title bar close button is referenced\n                // in _focusTabbable function, so to prevent errors it must be declared\n                this.uiDialogTitlebarClose = $('<div>');\n            }\n        },\n\n        /**\n         * @private\n         */\n        _size: function () {\n            if (this.options.autoSize) {\n                this._super();\n            }\n        },\n\n        /**\n         * @param {Object} handler\n         * @private\n         */\n        _mouseLeave: function (handler) {\n            var _self = this;\n\n            handler.on('mouseleave', function (event) {\n                event.stopPropagation();\n\n                if (_self._isOpen) {\n                    if (timer) {\n                        clearTimeout(timer);\n                    }\n                    timer = setTimeout(function (e) {\n                        _self.close(e);\n                    }, _self.options.timeout);\n                }\n            });\n        },\n\n        /**\n         * @param {Object} handler\n         * @private\n         */\n        _mouseEnter: function (handler) {\n            handler.on('mouseenter', function (event) {\n                event.stopPropagation();\n\n                if (timer) {\n                    clearTimeout(timer);\n                }\n            });\n        },\n\n        /**\n         * @param {String} key\n         * @param {*} value\n         * @private\n         */\n        _setOption: function (key, value) {\n            this._super(key, value);\n\n            if (key === 'triggerTarget') {\n                this.options.triggerTarget = value;\n            }\n        }\n    });\n\n    return $.mage.dropdownDialog;\n});\n","mage/dropdowns.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery'\n], function ($) {\n    'use strict';\n\n    /**\n     * @param {Object} options\n     */\n    $.fn.dropdown = function (options) {\n        var defaults = {\n                parent: null,\n                autoclose: true,\n                btnArrow: '.arrow',\n                menu: '[data-target=\"dropdown\"]',\n                activeClass: 'active'\n            },\n            actionElem = $(this),\n            self = this;\n\n        options = $.extend(defaults, options);\n        actionElem = $(this);\n        self = this;\n\n        /**\n         * @param {HTMLElement} elem\n         */\n        this.openDropdown = function (elem) {\n            elem\n                .addClass(options.activeClass)\n                .attr('aria-expanded', true)\n                .parent()\n                    .addClass(options.activeClass);\n\n            elem.parent()\n                .find(options.menu)\n                .attr('aria-hidden', false);\n\n            $(options.btnArrow, elem).text('-');\n        };\n\n        /**\n         * @param {HTMLElement} elem\n         */\n        this.closeDropdown = function (elem) {\n            elem.removeClass(options.activeClass)\n                .attr('aria-expanded', false)\n                .parent()\n                    .removeClass(options.activeClass);\n\n            elem.parent()\n                .find(options.menu)\n                .attr('aria-hidden', true);\n\n            $(options.btnArrow, elem).text('+');\n        };\n\n        /**\n         * Reset all dropdowns.\n         *\n         * @param {Object} param\n         */\n        this.reset = function (param) {\n            var params = param || {},\n                dropdowns = params.elems || actionElem;\n\n            dropdowns.each(function (index, elem) {\n                self.closeDropdown($(elem));\n            });\n        };\n\n        /* document Event bindings */\n        if (options.autoclose === true) {\n            $(document).on('click.hideDropdown', this.reset);\n            $(document).on('keyup.hideDropdown', function (e) {\n                var ESC_CODE = '27';\n\n                if (e.keyCode == ESC_CODE) { //eslint-disable-line eqeqeq\n                    self.reset();\n                }\n            });\n        }\n\n        if (options.events) {\n            $.each(options.events, function (index, event) {\n                $(document).on(event.name, event.selector, event.action);\n            });\n        }\n\n        return this.each(function () {\n            var elem = $(this),\n                parent = $(options.parent).length > 0 ? $(options.parent) : elem.parent(),\n                menu = $(options.menu, parent) || $('.dropdown-menu', parent);\n\n            // ARIA (adding aria attributes)\n            if (menu.length) {\n                elem.attr('aria-haspopup', true);\n            }\n\n            if (!elem.hasClass(options.activeClass)) {\n                elem.attr('aria-expanded', false);\n                menu.attr('aria-hidden', true);\n            } else {\n                elem.attr('aria-expanded', true);\n                menu.attr('aria-hidden', false);\n            }\n\n            if (!elem.is('a, button')) {\n                elem.attr('role', 'button');\n                elem.attr('tabindex', 0);\n            }\n\n            if (elem.attr('data-trigger-keypress-button')) {\n                elem.on('keypress', function (e) {\n                    var keyCode = e.keyCode || e.which,\n                        ENTER_CODE = 13;\n\n                    if (keyCode === ENTER_CODE) {\n                        e.preventDefault();\n                        elem.trigger('click.toggleDropdown');\n                    }\n                });\n            }\n\n            elem.on('click.toggleDropdown', function () {\n                var el = actionElem;\n\n                if (options.autoclose === true) {\n                    actionElem = $();\n                    $(document).trigger('click.hideDropdown');\n                    actionElem = el;\n                }\n\n                self[el.hasClass(options.activeClass) ? 'closeDropdown' : 'openDropdown'](elem);\n\n                return false;\n            });\n        });\n    };\n\n    return function (data, el) {\n        $(el).dropdown(data);\n    };\n});\n","mage/edit-trigger.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\n/**\n * @deprecated since version 2.2.0\n */\ndefine([\n    'jquery',\n    'mage/template',\n    'jquery-ui-modules/widget'\n], function ($, mageTemplate) {\n    'use strict';\n\n    var editTriggerPrototype;\n\n    $.widget('mage.editTrigger', {\n        options: {\n            img: '',\n            alt: '[TR]',\n            template: '#translate-inline-icon',\n            zIndex: 2000,\n            editSelector: '[data-translate]',\n            delay: 2000,\n            offsetTop: -3,\n            singleElement: true\n        },\n\n        /**\n         * editTriger creation\n         * @protected\n         */\n        _create: function () {\n            this.tmpl = mageTemplate(this.options.template);\n            this._initTrigger();\n            this._bind();\n        },\n\n        /**\n         * @return {Object}\n         * @private\n         */\n        _getCss: function () {\n            return {\n                position: 'absolute',\n                cursor: 'pointer',\n                display: 'none',\n                'z-index': this.options.zIndex\n            };\n        },\n\n        /**\n         * @param {*} appendTo\n         * @return {*|jQuery}\n         * @private\n         */\n        _createTrigger: function (appendTo) {\n            var tmpl = this.tmpl({\n                data: this.options\n            });\n\n            return $(tmpl)\n                .css(this._getCss())\n                .data('role', 'edit-trigger-element')\n                .appendTo(appendTo);\n        },\n\n        /**\n         * @private\n         */\n        _initTrigger: function () {\n            this.trigger = this._createTrigger($('body'));\n        },\n\n        /**\n         * Bind on mousemove event\n         * @protected\n         */\n        _bind: function () {\n            this.trigger.on('click.' + this.widgetName, $.proxy(this._onClick, this));\n            this.element.on('mousemove.' + this.widgetName, $.proxy(this._onMouseMove, this));\n        },\n\n        /**\n         * Show editTriger\n         */\n        show: function () {\n            if (this.trigger.is(':hidden')) {\n                this.trigger.show();\n            }\n        },\n\n        /**\n         * Hide editTriger\n         */\n        hide: function () {\n            this.currentTarget = null;\n\n            if (this.trigger && this.trigger.is(':visible')) {\n                this.trigger.hide();\n            }\n        },\n\n        /**\n         * Set editTriger position\n         * @protected\n         */\n        _setPosition: function (el) {\n            var offset = el.offset();\n\n            this.trigger.css({\n                top: offset.top + el.outerHeight() + this.options.offsetTop,\n                left: offset.left\n            });\n        },\n\n        /**\n         * Show/hide trigger on mouse move.\n         *\n         * @param {jQuery.Event} e\n         * @protected\n         */\n        _onMouseMove: function (e) {\n            var target = $(e.target),\n                inner = target.find(this.options.editSelector);\n\n            if ($(e.target).is('button') && inner.length) {\n                target = inner;\n            } else if (!target.is(this.trigger) && !target.is(this.options.editSelector)) {\n                target = target.parents(this.options.editSelector).first();\n            }\n\n            if (target.length) {\n                if (!target.is(this.trigger)) {\n                    this._setPosition(target);\n                    this.currentTarget = target;\n                }\n                this.show();\n            } else {\n                this.hide();\n            }\n        },\n\n        /**\n         * Trigger event \"edit\" on element for translate.\n         *\n         * @param {jQuery.Event} e\n         * @protected\n         */\n        _onClick: function (e) {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n            $(this.currentTarget).trigger('edit.' + this.widgetName);\n            this.hide(true);\n        },\n\n        /**\n         * Destroy editTriger\n         */\n        destroy: function () {\n            this.trigger.remove();\n            this.element.off('.' + this.widgetName);\n\n            return $.Widget.prototype.destroy.call(this);\n        }\n    });\n\n    /**\n     * Extention for widget editTrigger - hide trigger with delay\n     */\n    editTriggerPrototype = $.mage.editTrigger.prototype;\n\n    $.widget('mage.editTrigger', $.extend({}, editTriggerPrototype, {\n        /**\n         * Added clear timeout on trigger show\n         */\n        show: function () {\n            editTriggerPrototype.show.apply(this, arguments);\n\n            if (this.options.delay) {\n                this._clearTimer();\n            }\n        },\n\n        /**\n         * Added setTimeout on trigger hide\n         */\n        hide: function (immediate) {\n            if (!immediate && this.options.delay) {\n                if (!this.timer) {\n                    this.timer = setTimeout($.proxy(function () {\n                        editTriggerPrototype.hide.apply(this, arguments);\n                        this._clearTimer();\n                    }, this), this.options.delay);\n                }\n            } else {\n                editTriggerPrototype.hide.apply(this, arguments);\n            }\n        },\n\n        /**\n         * Clear timer\n         * @protected\n         */\n        _clearTimer: function () {\n            if (this.timer) {\n                clearTimeout(this.timer);\n                this.timer = null;\n            }\n        }\n    }));\n\n    return $.mage.editTrigger;\n});\n","mage/fieldset-controls.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\n/**\n * @deprecated since version 2.2.0\n */\ndefine([\n    'jquery',\n    'jquery-ui-modules/widget'\n], function ($) {\n    'use strict';\n\n    /**\n     * This widget will allow a control with the fieldsetResetControl widget attached to reset a set of input fields.\n     * The input fields to reset are defined by the inputSelector selector. The widget will store a clone of the fields\n     * on create, and on trigger of fieldsetReset event it resets the defined fields. The event is triggered by the\n     * reset control widget.\n     *\n     * For inputs of type file, the whole dom element is replaced as changing the value is a security violation\n     * For inputs of type checkbox or radio, the checked attribute is added or removed as appropriate\n     * For all others the jquery .val method is used to update to value to the original.\n     */\n    $.widget('mage.fieldsetControls', {\n        original: undefined,\n        options: {\n            inputSelector: '[data-reset=\"true\"]'\n        },\n\n        /**\n         * @private\n         */\n        _create: function () {\n            this.original = this.element.find(this.options.inputSelector).clone(true);\n            this._bind();\n        },\n\n        /**\n         * @private\n         */\n        _bind: function () {\n            this._on({\n                'fieldsetReset': '_onReset'\n            });\n        },\n\n        /**\n         * @param {jQuery.Event} e\n         * @private\n         */\n        _onReset: function (e) {\n            var items;\n\n            e.stopPropagation();\n            // find all the ones we have to remove\n            items = this.element.find(this.options.inputSelector);\n            // loop over replacing each one.\n            items.each($.proxy(function (index, item) {\n                if ($(item).attr('type') == 'file') { //eslint-disable-line eqeqeq\n                    // Replace the current one we found with a clone of the original saved earlier\n                    $(item).replaceWith($(this.original[index]).clone(true));\n                } else if ($(item).attr('type') == 'checkbox' || $(item).attr('type') == 'radio') { //eslint-disable-line\n                    // Return to original state.\n                    if ($(this.original[index]).attr('checked') === undefined) {\n                        $(item).removeAttr('checked');\n                    } else {\n                        $(item).attr('checked', $(this.original[index]).attr('checked'));\n                    }\n                } else {\n                    // Replace the value with the original\n                    $(item).val($(this.original[index]).val());\n                }\n            }, this));\n        }\n    });\n\n    $.widget('mage.fieldsetResetControl', {\n        /**\n         * @private\n         */\n        _create: function () {\n            this._bind();\n        },\n\n        /**\n         * @private\n         */\n        _bind: function () {\n            this._on({\n                click: '_onClick'\n            });\n        },\n\n        /**\n         * @param {jQuery.Event} e\n         * @private\n         */\n        _onClick: function (e) {\n            e.stopPropagation();\n            $(this.element).trigger('fieldsetReset');\n        }\n    });\n\n    return {\n        fieldsetControls: $.mage.fieldsetControls,\n        fieldsetResetControl: $.mage.fieldsetResetControl\n    };\n});\n","mage/ie-class-fixer.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([], function () {\n    'use strict';\n\n    if (navigator.userAgent.match(/Trident.*rv[ :]*11\\./)) {\n        document.documentElement.classList.add('ie11');\n    }\n});\n","mage/item-table.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\n/**\n * @deprecated since version 2.2.0\n */\ndefine([\n    'jquery',\n    'mage/template',\n    'jquery-ui-modules/widget'\n], function ($, mageTemplate) {\n    'use strict';\n\n    $.widget('mage.itemTable', {\n        options: {\n            addBlock: '[data-template=\"add-block\"]',\n            addBlockData: {},\n            addEvent: 'click',\n            addSelector: '[data-role=\"add\"]',\n            itemsSelector: '[data-container=\"items\"]',\n            keepLastRow: true\n        },\n\n        /**\n         * This method adds a new instance of the block to the items.\n         * @private\n         */\n        _add: function () {\n            var hideShowDelete,\n                deletableItems,\n                addedBlock;\n\n            // adding a new row, so increment the count to give each row a unique index\n            this.rowIndex++;\n\n            // make sure the block data has the rowIndex\n            this.options.addBlockData.rowIndex = this.rowIndex;\n\n            // render the form\n            addedBlock = $(this.addBlockTmpl({\n                data: this.options.addBlockData\n            }));\n\n            // add the row to the item block\n            this.element.find(this.options.itemsSelector).append(addedBlock);\n\n            // initialize all mage content\n            addedBlock.trigger('contentUpdated');\n\n            // determine all existing items in the collection\n            deletableItems = this._getDeletableItems();\n\n            // for the most part, show the delete mechanism, except in the case where there is only one it should not\n            // be deleted\n            hideShowDelete = 'showDelete';\n\n            if (this.options.keepLastRow && deletableItems.length === 1) {\n                hideShowDelete = 'hideDelete';\n            }\n\n            // loop through each control and perform that action on the deletable item\n            $.each(deletableItems, function (index) {\n                $(deletableItems[index]).trigger(hideShowDelete);\n            });\n        },\n\n        /**\n         * This method binds elements found in this widget.\n         * @private\n         */\n        _bind: function () {\n            var handlers = {};\n\n            // since the first handler is dynamic, generate the object using array notation\n            handlers[this.options.addEvent + ' ' + this.options.addSelector] = '_add';\n            handlers.deleteItem = '_onDeleteItem';\n\n            this._on(handlers);\n        },\n\n        /**\n         * This method constructs a new widget.\n         * @private\n         */\n        _create: function () {\n            this._bind();\n\n            this.addBlockTmpl = mageTemplate(this.options.addBlock);\n\n            // nothing in the table, so indicate that\n            this.rowIndex = -1;\n\n            // make sure the block data is an object\n            if (this.options.addBlockData == null || typeof this.options.addBlockData !== 'object') {\n                // reset the block data to an empty object\n                this.options.addBlockData = {};\n            }\n\n            // add the first row to the table\n            this._add();\n        },\n\n        /**\n         * This method returns the list of widgets associated with deletable items from the container (direct children\n         * only).\n         * @private\n         */\n        _getDeletableItems: function () {\n            return this.element.find(this.options.itemsSelector + '> .deletableItem');\n        },\n\n        /**\n         * This method removes the item associated with the message.\n         * @private\n         */\n        _onDeleteItem: function (e) {\n            var deletableItems;\n\n            // parent elements don't need to see this event\n            e.stopPropagation();\n\n            // remove the deletable item\n            $(e.target).remove();\n\n            if (this.options.keepLastRow) {\n                // determine if there is only one element remaining, in which case, disable the delete mechanism on it\n                deletableItems = this._getDeletableItems();\n\n                if (deletableItems.length === 1) {\n                    $(deletableItems[0]).trigger('hideDelete');\n                }\n            }\n        }\n    });\n\n    return $.mage.itemTable;\n});\n","mage/layout.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\n/**\n * @deprecated since version 2.2.0\n */\n/* eslint-disable strict */\ndefine(['underscore'], function (_) {\n    return {\n        /**\n         * @param {Object} config\n         */\n        build: function (config) {\n            var types = _.map(_.flatten(config), function (item) {\n                return item.type;\n            });\n\n            require(types, function () {});\n        }\n    };\n});\n","mage/loader.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'mage/template',\n    'jquery-ui-modules/widget',\n    'mage/translate'\n], function ($, mageTemplate) {\n    'use strict';\n\n    $.widget('mage.loader', {\n        loaderStarted: 0,\n        options: {\n            icon: '',\n            texts: {\n                loaderText: $.mage.__('Please wait...'),\n                imgAlt: $.mage.__('Loading...')\n            },\n            template:\n                '<div class=\"loading-mask\" data-role=\"loader\">' +\n                    '<div class=\"loader\">' +\n                        '<img alt=\"<%- data.texts.imgAlt %>\" src=\"<%- data.icon %>\">' +\n                        '<p><%- data.texts.loaderText %></p>' +\n                    '</div>' +\n                '</div>'\n\n        },\n\n        /**\n         * Loader creation\n         * @protected\n         */\n        _create: function () {\n            this._bind();\n        },\n\n        /**\n         * Bind on ajax events\n         * @protected\n         */\n        _bind: function () {\n            this._on({\n                'processStop': 'hide',\n                'processStart': 'show',\n                'show.loader': 'show',\n                'hide.loader': 'hide',\n                'contentUpdated.loader': '_contentUpdated'\n            });\n        },\n\n        /**\n         * Verify loader present after content updated\n         *\n         * This will be cleaned up by the task MAGETWO-11070\n         *\n         * @param {EventObject} e\n         * @private\n         */\n        _contentUpdated: function (e) {\n            this.show(e);\n        },\n\n        /**\n         * Show loader\n         */\n        show: function (e, ctx) {\n            this._render();\n            this.loaderStarted++;\n            this.spinner.show();\n\n            if (ctx) {\n                this.spinner\n                    .css({\n                        width: ctx.outerWidth(),\n                        height: ctx.outerHeight(),\n                        position: 'absolute'\n                    })\n                    .position({\n                        my: 'top left',\n                        at: 'top left',\n                        of: ctx\n                    });\n            }\n\n            return false;\n        },\n\n        /**\n         * Hide loader\n         */\n        hide: function () {\n            if (this.loaderStarted > 0) {\n                this.loaderStarted--;\n\n                if (this.loaderStarted === 0) {\n                    this.spinner.hide();\n                }\n            }\n\n            return false;\n        },\n\n        /**\n         * Render loader\n         * @protected\n         */\n        _render: function () {\n            var html;\n\n            if (!this.spinnerTemplate) {\n                this.spinnerTemplate = mageTemplate(this.options.template);\n\n                html = $(this.spinnerTemplate({\n                    data: this.options\n                }));\n\n                html.prependTo(this.element);\n\n                this.spinner = html;\n            }\n        },\n\n        /**\n         * Destroy loader\n         */\n        _destroy: function () {\n            this.spinner.remove();\n        }\n    });\n\n    /**\n     * This widget takes care of registering the needed loader listeners on the body\n     */\n    $.widget('mage.loaderAjax', {\n        options: {\n            defaultContainer: '[data-container=body]',\n            loadingClass: 'ajax-loading'\n        },\n\n        /**\n         * @private\n         */\n        _create: function () {\n            this._bind();\n            // There should only be one instance of this widget, and it should be attached\n            // to the body only. Having it on the page twice will trigger multiple processStarts.\n            if (window.console && !this.element.is(this.options.defaultContainer) && $.mage.isDevMode(undefined)) {\n                console.warn('This widget is intended to be attached to the body, not below.');\n            }\n        },\n\n        /**\n         * @private\n         */\n        _bind: function () {\n            $(document).on({\n                'ajaxSend': this._onAjaxSend.bind(this),\n                'ajaxComplete': this._onAjaxComplete.bind(this)\n            });\n        },\n\n        /**\n         * @param {Object} loaderContext\n         * @return {*}\n         * @private\n         */\n        _getJqueryObj: function (loaderContext) {\n            var ctx;\n\n            // Check to see if context is jQuery object or not.\n            if (loaderContext) {\n                if (loaderContext.jquery) {\n                    ctx = loaderContext;\n                } else {\n                    ctx = $(loaderContext);\n                }\n            } else {\n                ctx = $('[data-container=\"body\"]');\n            }\n\n            return ctx;\n        },\n\n        /**\n         * @param {jQuery.Event} e\n         * @param {Object} jqxhr\n         * @param {Object} settings\n         * @private\n         */\n        _onAjaxSend: function (e, jqxhr, settings) {\n            var ctx;\n\n            $(this.options.defaultContainer)\n                .addClass(this.options.loadingClass)\n                .attr({\n                    'aria-busy': true\n                });\n\n            if (settings && settings.showLoader) {\n                ctx = this._getJqueryObj(settings.loaderContext);\n                ctx.trigger('processStart');\n\n                // Check to make sure the loader is there on the page if not report it on the console.\n                // NOTE that this check should be removed before going live. It is just an aid to help\n                // in finding the uses of the loader that maybe broken.\n                if (window.console && !ctx.parents('[data-role=\"loader\"]').length) {\n                    console.warn('Expected to start loader but did not find one in the dom');\n                }\n            }\n        },\n\n        /**\n         * @param {jQuery.Event} e\n         * @param {Object} jqxhr\n         * @param {Object} settings\n         * @private\n         */\n        _onAjaxComplete: function (e, jqxhr, settings) {\n            $(this.options.defaultContainer)\n                .removeClass(this.options.loadingClass)\n                .attr('aria-busy', false);\n\n            if (settings && settings.showLoader) {\n                this._getJqueryObj(settings.loaderContext).trigger('processStop');\n            }\n        }\n\n    });\n\n    return {\n        loader: $.mage.loader,\n        loaderAjax: $.mage.loaderAjax\n    };\n});\n","mage/mage.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'mage/apply/main'\n], function ($, mage) {\n    'use strict';\n\n    /**\n     * Main namespace for Magento extensions\n     * @type {Object}\n     */\n    $.mage = $.mage || {};\n\n    /**\n     * Plugin mage, initialize components on elements\n     * @param {String} name - Components' path.\n     * @param {Object} config - Components' config.\n     * @returns {JQuery} Chainable.\n     */\n    $.fn.mage = function (name, config) {\n        config = config || {};\n\n        this.each(function (index, el) {\n            mage.applyFor(el, config, name);\n        });\n\n        return this;\n    };\n\n    $.extend($.mage, {\n        /**\n         * Handle all components declared via data attribute\n         * @return {Object} $.mage\n         */\n        init: function () {\n            mage.apply();\n\n            return this;\n        },\n\n        /**\n         * Method handling redirects and page refresh\n         * @param {String} url - redirect URL\n         * @param {(undefined|String)} type - 'assign', 'reload', 'replace'\n         * @param {(undefined|Number)} timeout - timeout in milliseconds before processing the redirect or reload\n         * @param {(undefined|Boolean)} forced - true|false used for 'reload' only\n         */\n        redirect: function (url, type, timeout, forced) {\n            var _redirect;\n\n            forced  = !!forced;\n            timeout = timeout || 0;\n            type    = type || 'assign';\n\n            /**\n             * @private\n             */\n            _redirect = function () {\n                window.location[type](type === 'reload' ? forced : url);\n            };\n\n            timeout ? setTimeout(_redirect, timeout) : _redirect();\n        },\n\n        /**\n         * Checks if provided string is a valid selector.\n         * @param {String} selector - Selector to check.\n         * @returns {Boolean}\n         */\n        isValidSelector: function (selector) {\n            try {\n                document.querySelector(selector);\n\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n    });\n\n    /**\n     * Init components inside of dynamically updated elements\n     */\n    $('body').on('contentUpdated', function () {\n        if (mage) {\n            mage.apply();\n        }\n    });\n\n    return $.mage;\n});\n","mage/menu.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'matchMedia',\n    'jquery-ui-modules/menu',\n    'jquery/jquery.mobile.custom',\n    'mage/translate'\n], function ($, mediaCheck) {\n    'use strict';\n\n    /**\n     * Menu Widget - this widget is a wrapper for the jQuery UI Menu\n     */\n    $.widget('mage.menu', $.ui.menu, {\n        options: {\n            responsive: false,\n            expanded: false,\n            showDelay: 42,\n            hideDelay: 300,\n            delay: 0,\n            mediaBreakpoint: '(max-width: 767px)'\n        },\n\n        /**\n         * @private\n         */\n        _create: function () {\n            var self = this;\n\n            this.delay = this.options.delay;\n\n            this._super();\n            $(window).on('resize', function () {\n                self.element.find('.submenu-reverse').removeClass('submenu-reverse');\n            });\n        },\n\n        /**\n         * @private\n         */\n        _init: function () {\n            this._super();\n\n            if (this.options.expanded === true) {\n                this.isExpanded();\n            }\n\n            if (this.options.responsive === true) {\n                mediaCheck({\n                    media: this.options.mediaBreakpoint,\n                    entry: $.proxy(function () {\n                        this._toggleMobileMode();\n                    }, this),\n                    exit: $.proxy(function () {\n                        this._toggleDesktopMode();\n                    }, this)\n                });\n            }\n\n            this._assignControls()._listen();\n            this._setActiveMenu();\n        },\n\n        /**\n         * @return {Object}\n         * @private\n         */\n        _assignControls: function () {\n            this.controls = {\n                toggleBtn: $('[data-action=\"toggle-nav\"]'),\n                swipeArea: $('.nav-sections')\n            };\n\n            return this;\n        },\n\n        /**\n         * @private\n         */\n        _listen: function () {\n            var controls = this.controls,\n                toggle = this.toggle;\n\n            controls.toggleBtn.off('click');\n            controls.toggleBtn.on('click', toggle.bind(this));\n            controls.swipeArea.off('swipeleft');\n            controls.swipeArea.on('swipeleft', toggle.bind(this));\n        },\n\n        /**\n         * Toggle.\n         */\n        toggle: function () {\n            var html = $('html');\n\n            if (html.hasClass('nav-open')) {\n                html.removeClass('nav-open');\n                setTimeout(function () {\n                    html.removeClass('nav-before-open');\n                }, this.options.hideDelay);\n            } else {\n                html.addClass('nav-before-open');\n                setTimeout(function () {\n                    html.addClass('nav-open');\n                }, this.options.showDelay);\n            }\n        },\n\n        /**\n         * Tries to figure out the active category for current page and add appropriate classes:\n         *  - 'active' class for active category\n         *  - 'has-active' class for all parents of active category\n         *\n         *  First, checks whether current URL is URL of category page,\n         *  otherwise tries to retrieve category URL in case of current URL is product view page URL\n         *  which has category tree path in it.\n         *\n         * @return void\n         * @private\n         */\n        _setActiveMenu: function () {\n            var currentUrl = window.location.href.split('?')[0];\n\n            if (!this._setActiveMenuForCategory(currentUrl)) {\n                this._setActiveMenuForProduct(currentUrl);\n            }\n        },\n\n        /**\n         * Looks for category with provided URL and adds 'active' CSS class to it if it was not set before.\n         * If menu item has parent categories, sets 'has-active' class to all af them.\n         *\n         * @param {String} url - possible category URL\n         * @returns {Boolean} - true if active category was founded by provided URL, otherwise return false\n         * @private\n         */\n        _setActiveMenuForCategory: function (url) {\n            var activeCategoryLink = this.element.find('a[href=\"' + url + '\"]'),\n                classes,\n                classNav;\n\n            if (!activeCategoryLink || !activeCategoryLink.hasClass('ui-corner-all')) {\n\n                //category was not found by provided URL\n                return false;\n            } else if (!activeCategoryLink.parent().hasClass('active')) {\n                activeCategoryLink.parent().addClass('active');\n                classes = activeCategoryLink.parent().attr('class');\n                classNav = classes.match(/(nav\\-)[0-9]+(\\-[0-9]+)+/gi);\n\n                if (classNav) {\n                    this._setActiveParent(classNav[0]);\n                }\n            }\n\n            return true;\n        },\n\n        /**\n         * Sets 'has-active' CSS class to all parent categories which have part of provided class in childClassName\n         *\n         * @example\n         *  childClassName - 'nav-1-2-3'\n         *  CSS class 'has-active' will be added to categories have 'nav-1-2' and 'nav-1' classes\n         *\n         * @param {String} childClassName - Class name of active category <li> element\n         * @return void\n         * @private\n         */\n        _setActiveParent: function (childClassName) {\n            var parentElement,\n                parentClass = childClassName.substr(0, childClassName.lastIndexOf('-'));\n\n            if (parentClass.lastIndexOf('-') !== -1) {\n                parentElement = this.element.find('.' + parentClass);\n\n                if (parentElement) {\n                    parentElement.addClass('has-active');\n                }\n                this._setActiveParent(parentClass);\n            }\n        },\n\n        /**\n         * Tries to retrieve category URL from current URL and mark this category as active\n         * @see _setActiveMenuForCategory(url)\n         *\n         * @example\n         *  currentUrl - http://magento.com/category1/category12/product.html,\n         *  category URLs has extensions .phtml - http://magento.com/category1.phtml\n         *  method sets active category which has URL http://magento.com/category1/category12.phtml\n         *\n         * @param {String} currentUrl - current page URL without parameters\n         * @return void\n         * @private\n         */\n        _setActiveMenuForProduct: function (currentUrl) {\n            var categoryUrlExtension,\n                lastUrlSection,\n                possibleCategoryUrl,\n                //retrieve first category URL to know what extension is used for category URLs\n                firstCategoryUrl = this.element.find('> li a').attr('href');\n\n            if (firstCategoryUrl) {\n                lastUrlSection = firstCategoryUrl.substr(firstCategoryUrl.lastIndexOf('/'));\n                categoryUrlExtension = lastUrlSection.lastIndexOf('.') !== -1 ?\n                    lastUrlSection.substr(lastUrlSection.lastIndexOf('.')) : '';\n\n                possibleCategoryUrl = currentUrl.substr(0, currentUrl.lastIndexOf('/')) + categoryUrlExtension;\n                this._setActiveMenuForCategory(possibleCategoryUrl);\n            }\n        },\n\n        /**\n         * Add class for expanded option.\n         */\n        isExpanded: function () {\n            var subMenus = this.element.find(this.options.menus),\n                expandedMenus = subMenus.find(this.options.menus);\n\n            expandedMenus.addClass('expanded');\n        },\n\n        /**\n         * @param {jQuery.Event} event\n         * @private\n         */\n        _activate: function (event) {\n            window.location.href = this.active.find('> a').attr('href');\n            this.collapseAll(event);\n        },\n\n        /**\n         * @param {jQuery.Event} event\n         * @private\n         */\n        _keydown: function (event) {\n            var match, prev, character, skip, regex,\n                preventDefault = true;\n\n            /* eslint-disable max-depth */\n            /**\n             * @param {String} value\n             */\n            function escape(value) {\n                return value.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&');\n            }\n\n            if (this.active.closest(this.options.menus).attr('aria-expanded') != 'true') { //eslint-disable-line eqeqeq\n\n                switch (event.keyCode) {\n                    case $.ui.keyCode.PAGE_UP:\n                        this.previousPage(event);\n                        break;\n\n                    case $.ui.keyCode.PAGE_DOWN:\n                        this.nextPage(event);\n                        break;\n\n                    case $.ui.keyCode.HOME:\n                        this._move('first', 'first', event);\n                        break;\n\n                    case $.ui.keyCode.END:\n                        this._move('last', 'last', event);\n                        break;\n\n                    case $.ui.keyCode.UP:\n                        this.previous(event);\n                        break;\n\n                    case $.ui.keyCode.DOWN:\n                        if (this.active && !this.active.is('.ui-state-disabled')) {\n                            this.expand(event);\n                        }\n                        break;\n\n                    case $.ui.keyCode.LEFT:\n                        this.previous(event);\n                        break;\n\n                    case $.ui.keyCode.RIGHT:\n                        this.next(event);\n                        break;\n\n                    case $.ui.keyCode.ENTER:\n                    case $.ui.keyCode.SPACE:\n                        this._activate(event);\n                        break;\n\n                    case $.ui.keyCode.ESCAPE:\n                        this.collapse(event);\n                        break;\n                    default:\n                        preventDefault = false;\n                        prev = this.previousFilter || '';\n                        character = String.fromCharCode(event.keyCode);\n                        skip = false;\n\n                        clearTimeout(this.filterTimer);\n\n                        if (character === prev) {\n                            skip = true;\n                        } else {\n                            character = prev + character;\n                        }\n\n                        regex = new RegExp('^' + escape(character), 'i');\n                        match = this.activeMenu.children('.ui-menu-item').filter(function () {\n                            return regex.test($(this).children('a').text());\n                        });\n                        match = skip && match.index(this.active.next()) !== -1 ?\n                            this.active.nextAll('.ui-menu-item') :\n                            match;\n\n                        // If no matches on the current filter, reset to the last character pressed\n                        // to move down the menu to the first item that starts with that character\n                        if (!match.length) {\n                            character = String.fromCharCode(event.keyCode);\n                            regex = new RegExp('^' + escape(character), 'i');\n                            match = this.activeMenu.children('.ui-menu-item').filter(function () {\n                                return regex.test($(this).children('a').text());\n                            });\n                        }\n\n                        if (match.length) {\n                            this.focus(event, match);\n\n                            if (match.length > 1) {\n                                this.previousFilter = character;\n                                this.filterTimer = this._delay(function () {\n                                    delete this.previousFilter;\n                                }, 1000);\n                            } else {\n                                delete this.previousFilter;\n                            }\n                        } else {\n                            delete this.previousFilter;\n                        }\n                }\n            } else {\n                switch (event.keyCode) {\n                    case $.ui.keyCode.DOWN:\n                        this.next(event);\n                        break;\n\n                    case $.ui.keyCode.UP:\n                        this.previous(event);\n                        break;\n\n                    case $.ui.keyCode.RIGHT:\n                        if (this.active && !this.active.is('.ui-state-disabled')) {\n                            this.expand(event);\n                        }\n                        break;\n\n                    case $.ui.keyCode.ENTER:\n                    case $.ui.keyCode.SPACE:\n                        this._activate(event);\n                        break;\n\n                    case $.ui.keyCode.LEFT:\n                    case $.ui.keyCode.ESCAPE:\n                        this.collapse(event);\n                        break;\n                    default:\n                        preventDefault = false;\n                        prev = this.previousFilter || '';\n                        character = String.fromCharCode(event.keyCode);\n                        skip = false;\n\n                        clearTimeout(this.filterTimer);\n\n                        if (character === prev) {\n                            skip = true;\n                        } else {\n                            character = prev + character;\n                        }\n\n                        regex = new RegExp('^' + escape(character), 'i');\n                        match = this.activeMenu.children('.ui-menu-item').filter(function () {\n                            return regex.test($(this).children('a').text());\n                        });\n                        match = skip && match.index(this.active.next()) !== -1 ?\n                            this.active.nextAll('.ui-menu-item') :\n                            match;\n\n                        // If no matches on the current filter, reset to the last character pressed\n                        // to move down the menu to the first item that starts with that character\n                        if (!match.length) {\n                            character = String.fromCharCode(event.keyCode);\n                            regex = new RegExp('^' + escape(character), 'i');\n                            match = this.activeMenu.children('.ui-menu-item').filter(function () {\n                                return regex.test($(this).children('a').text());\n                            });\n                        }\n\n                        if (match.length) {\n                            this.focus(event, match);\n\n                            if (match.length > 1) {\n                                this.previousFilter = character;\n                                this.filterTimer = this._delay(function () {\n                                    delete this.previousFilter;\n                                }, 1000);\n                            } else {\n                                delete this.previousFilter;\n                            }\n                        } else {\n                            delete this.previousFilter;\n                        }\n                }\n            }\n\n            /* eslint-enable max-depth */\n            if (preventDefault) {\n                event.preventDefault();\n            }\n        },\n\n        /**\n         * @private\n         */\n        _toggleMobileMode: function () {\n            var subMenus;\n\n            $(this.element).off('mouseenter mouseleave');\n            this._on({\n\n                /**\n                 * @param {jQuery.Event} event\n                 */\n                'click .ui-menu-item:has(a)': function (event) {\n                    var target;\n\n                    event.preventDefault();\n                    target = $(event.target).closest('.ui-menu-item');\n                    target.get(0).scrollIntoView();\n\n                    if (!target.hasClass('level-top') || !target.has('.ui-menu').length) {\n                        window.location.href = target.find('> a').attr('href');\n                    }\n                },\n\n                /**\n                 * @param {jQuery.Event} event\n                 */\n                'click .ui-menu-item:has(.ui-state-active)': function (event) {\n                    this.collapseAll(event, true);\n                }\n            });\n\n            subMenus = this.element.find('.level-top');\n            $.each(subMenus, $.proxy(function (index, item) {\n                var category = $(item).find('> a span').not('.ui-menu-icon').text(),\n                    categoryUrl = $(item).find('> a').attr('href'),\n                    menu = $(item).find('> .ui-menu');\n\n                this.categoryLink = $('<a>')\n                    .attr('href', categoryUrl)\n                    .text($.mage.__('All %1').replace('%1', category));\n\n                this.categoryParent = $('<li>')\n                    .addClass('ui-menu-item all-category')\n                    .html(this.categoryLink);\n\n                if (menu.find('.all-category').length === 0) {\n                    menu.prepend(this.categoryParent);\n                }\n\n            }, this));\n        },\n\n        /**\n         * @private\n         */\n        _toggleDesktopMode: function () {\n            var categoryParent, html;\n\n            $(this.element).off('click mousedown mouseenter mouseleave');\n            this._on({\n\n                /**\n                 * Prevent focus from sticking to links inside menu after clicking\n                 * them (focus should always stay on UL during navigation).\n                 */\n                'mousedown .ui-menu-item > a': function (event) {\n                    event.preventDefault();\n                },\n\n                /**\n                 * Prevent focus from sticking to links inside menu after clicking\n                 * them (focus should always stay on UL during navigation).\n                 */\n                'click .ui-state-disabled > a': function (event) {\n                    event.preventDefault();\n                },\n\n                /**\n                 * @param {jQuer.Event} event\n                 */\n                'click .ui-menu-item:has(a)': function (event) {\n                    var target = $(event.target).closest('.ui-menu-item');\n\n                    if (!this.mouseHandled && target.not('.ui-state-disabled').length) {\n                        this.select(event);\n\n                        // Only set the mouseHandled flag if the event will bubble, see #9469.\n                        if (!event.isPropagationStopped()) {\n                            this.mouseHandled = true;\n                        }\n\n                        // Open submenu on click\n                        if (target.has('.ui-menu').length) {\n                            this.expand(event);\n                        } else if (!this.element.is(':focus') &&\n                            $(this.document[0].activeElement).closest('.ui-menu').length\n                        ) {\n                            // Redirect focus to the menu\n                            this.element.trigger('focus', [true]);\n\n                            // If the active item is on the top level, let it stay active.\n                            // Otherwise, blur the active item since it is no longer visible.\n                            if (this.active && this.active.parents('.ui-menu').length === 1) { //eslint-disable-line\n                                clearTimeout(this.timer);\n                            }\n                        }\n                    }\n                },\n\n                /**\n                 * @param {jQuery.Event} event\n                 */\n                'mouseenter .ui-menu-item': function (event) {\n                    var target = $(event.currentTarget),\n                        submenu = this.options.menus,\n                        ulElement,\n                        ulElementWidth,\n                        width,\n                        targetPageX,\n                        rightBound;\n\n                    if (target.has(submenu)) {\n                        ulElement = target.find(submenu);\n                        ulElementWidth = ulElement.outerWidth(true);\n                        width = target.outerWidth() * 2;\n                        targetPageX = target.offset().left;\n                        rightBound = $(window).width();\n\n                        if (ulElementWidth + width + targetPageX > rightBound) {\n                            ulElement.addClass('submenu-reverse');\n                        }\n\n                        if (targetPageX - ulElementWidth < 0) {\n                            ulElement.removeClass('submenu-reverse');\n                        }\n                    }\n\n                    // Remove ui-state-active class from siblings of the newly focused menu item\n                    // to avoid a jump caused by adjacent elements both having a class with a border\n                    target.siblings().children('.ui-state-active').removeClass('ui-state-active');\n                    this.focus(event, target);\n                },\n\n                /**\n                 * @param {jQuery.Event} event\n                 */\n                'mouseleave': function (event) {\n                    this.collapseAll(event, true);\n                },\n\n                /**\n                 * Mouse leave.\n                 */\n                'mouseleave .ui-menu': 'collapseAll'\n            });\n\n            categoryParent = this.element.find('.all-category');\n            html = $('html');\n\n            categoryParent.remove();\n\n            if (html.hasClass('nav-open')) {\n                html.removeClass('nav-open');\n                setTimeout(function () {\n                    html.removeClass('nav-before-open');\n                }, this.options.hideDelay);\n            }\n        },\n\n        /**\n         * @param {*} handler\n         * @param {Number} delay\n         * @return {Number}\n         * @private\n         */\n        _delay: function (handler, delay) {\n            var instance = this,\n\n                /**\n                 * @return {*}\n                 */\n                handlerProxy = function () {\n                    return (typeof handler === 'string' ? instance[handler] : handler).apply(instance, arguments);\n                };\n\n            return setTimeout(handlerProxy, delay || 0);\n        },\n\n        /**\n         * @param {jQuery.Event} event\n         */\n        expand: function (event) {\n            var newItem = this.active &&\n                this.active\n                    .children('.ui-menu')\n                    .children('.ui-menu-item')\n                    .first();\n\n            if (newItem && newItem.length) {\n                if (newItem.closest('.ui-menu').is(':visible') &&\n                    newItem.closest('.ui-menu').has('.all-categories')\n                ) {\n                    return;\n                }\n\n                // remove the active state class from the siblings\n                this.active.siblings().children('.ui-state-active').removeClass('ui-state-active');\n\n                this._open(newItem.parent());\n\n                // Delay so Firefox will not hide activedescendant change in expanding submenu from AT\n                this._delay(function () {\n                    this.focus(event, newItem);\n                });\n            }\n        },\n\n        /**\n         * @param {jQuery.Event} event\n         */\n        select: function (event) {\n            var ui;\n\n            this.active = this.active || $(event.target).closest('.ui-menu-item');\n\n            if (this.active.is('.all-category')) {\n                this.active = $(event.target).closest('.ui-menu-item');\n            }\n            ui = {\n                item: this.active\n            };\n\n            if (!this.active.has('.ui-menu').length) {\n                this.collapseAll(event, true);\n            }\n            this._trigger('select', event, ui);\n        }\n    });\n\n    $.widget('mage.navigation', $.mage.menu, {\n        options: {\n            responsiveAction: 'wrap', //option for responsive handling\n            maxItems: null, //option to set max number of menu items\n            container: '#menu', //container to check against navigation length\n            moreText: $.mage.__('more'),\n            breakpoint: 768\n        },\n\n        /**\n         * @private\n         */\n        _init: function () {\n            var that, responsive;\n\n            this._super();\n\n            that = this;\n            responsive = this.options.responsiveAction;\n\n            this.element\n                .addClass('ui-menu-responsive')\n                .attr('responsive', 'main');\n\n            this.setupMoreMenu();\n            this.setMaxItems();\n\n            //check responsive option\n            if (responsive == 'onResize') { //eslint-disable-line eqeqeq\n                $(window).on('resize', function () {\n                    if ($(window).width() > that.options.breakpoint) {\n                        that._responsive();\n                        $('[responsive=more]').show();\n                    } else {\n                        that.element.children().show();\n                        $('[responsive=more]').hide();\n                    }\n                });\n            } else if (responsive == 'onReload') { //eslint-disable-line eqeqeq\n                this._responsive();\n            }\n        },\n\n        /**\n         * Setup more menu.\n         */\n        setupMoreMenu: function () {\n            var moreListItems = this.element.children().clone(),\n                moreLink = $('<a>' + this.options.moreText + '</a>');\n\n            moreListItems.hide();\n\n            moreLink.attr('href', '#');\n\n            this.moreItemsList = $('<ul>')\n                .append(moreListItems);\n\n            this.moreListContainer = $('<li>')\n                .append(moreLink)\n                .append(this.moreItemsList);\n\n            this.responsiveMenu = $('<ul>')\n                .addClass('ui-menu-more')\n                .attr('responsive', 'more')\n                .append(this.moreListContainer)\n                .menu({\n                    position: {\n                        my: 'right top',\n                        at: 'right bottom'\n                    }\n                })\n                .insertAfter(this.element);\n        },\n\n        /**\n         * @private\n         */\n        _responsive: function () {\n            var container = $(this.options.container),\n                containerSize = container.width(),\n                width = 0,\n                items = this.element.children('li'),\n                more = $('.ui-menu-more > li > ul > li a');\n\n            items = items.map(function () {\n                var item = {};\n\n                item.item = $(this);\n                item.itemSize = $(this).outerWidth();\n\n                return item;\n            });\n\n            $.each(items, function (index) {\n                var itemText = items[index].item\n                    .find('a:first')\n                    .text();\n\n                width += parseInt(items[index].itemSize, null); //eslint-disable-line radix\n\n                if (width < containerSize) {\n                    items[index].item.show();\n\n                    more.each(function () {\n                        var text = $(this).text();\n\n                        if (text === itemText) {\n                            $(this).parent().hide();\n                        }\n                    });\n                } else if (width > containerSize) {\n                    items[index].item.hide();\n\n                    more.each(function () {\n                        var text = $(this).text();\n\n                        if (text === itemText) {\n                            $(this).parent().show();\n                        }\n                    });\n                }\n            });\n        },\n\n        /**\n         * Set max items.\n         */\n        setMaxItems: function () {\n            var items = this.element.children('li'),\n                itemsCount = items.length,\n                maxItems = this.options.maxItems,\n                overflow = itemsCount - maxItems,\n                overflowItems = items.slice(overflow);\n\n            overflowItems.hide();\n\n            overflowItems.each(function () {\n                var itemText = $(this).find('a:first').text();\n\n                $(this).hide();\n\n                $('.ui-menu-more > li > ul > li a').each(function () {\n                    var text = $(this).text();\n\n                    if (text === itemText) {\n                        $(this).parent().show();\n                    }\n                });\n            });\n        }\n    });\n\n    return {\n        menu: $.mage.menu,\n        navigation: $.mage.navigation\n    };\n});\n","mage/multiselect.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'underscore',\n    'jquery',\n    'text!mage/multiselect.html',\n    'Magento_Ui/js/modal/alert',\n    'jquery-ui-modules/widget',\n    'jquery/editableMultiselect/js/jquery.multiselect'\n], function (_, $, searchTemplate, alert) {\n    'use strict';\n\n    $.widget('mage.multiselect2', {\n        options: {\n            mselectContainer: 'section.mselect-list',\n            mselectItemsWrapperClass: 'mselect-items-wrapper',\n            mselectCheckedClass: 'mselect-checked',\n            containerClass: 'paginated',\n            searchInputClass: 'admin__action-multiselect-search',\n            selectedItemsCountClass: 'admin__action-multiselect-items-selected',\n            currentPage: 1,\n            lastAppendValue: 0,\n            updateDelay: 1000,\n            optionsLoaded: false\n        },\n\n        /** @inheritdoc */\n        _create: function () {\n            $.fn.multiselect.call(this.element, this.options);\n        },\n\n        /** @inheritdoc */\n        _init: function () {\n            this.domElement = this.element.get(0);\n\n            this.$container = $(this.options.mselectContainer);\n            this.$wrapper = this.$container.find('.' + this.options.mselectItemsWrapperClass);\n            this.$item = this.$wrapper.find('div').first();\n            this.selectedValues = [];\n            this.values = {};\n\n            this.$container.addClass(this.options.containerClass).prepend(searchTemplate);\n            this.$input = this.$container.find('.' + this.options.searchInputClass);\n            this.$selectedCounter = this.$container.find('.' + this.options.selectedItemsCountClass);\n            this.filter = '';\n\n            if (this.domElement.options.length) {\n                this._setLastAppendOption(this.domElement.options[this.domElement.options.length - 1].value);\n            }\n\n            this._initElement();\n            this._events();\n        },\n\n        /**\n         * Leave only saved/selected options in select element.\n         *\n         * @private\n         */\n        _initElement: function () {\n            this.element.empty();\n            _.each(this.options.selectedValues, function (value) {\n                this._createSelectedOption({\n                    value: value,\n                    label: value\n                });\n            }, this);\n        },\n\n        /**\n         * Attach required events.\n         *\n         * @private\n         */\n        _events: function () {\n            var onKeyUp = _.debounce(this.onKeyUp, this.options.updateDelay);\n\n            _.bindAll(this, 'onScroll', 'onCheck', 'onOptionsChange');\n\n            this.$wrapper.on('scroll', this.onScroll);\n            this.$wrapper.on('change.mselectCheck', '[type=checkbox]', this.onCheck);\n            this.$input.on('keyup', _.bind(onKeyUp, this));\n            this.element.on('change.hiddenSelect', this.onOptionsChange);\n        },\n\n        /**\n         * Behaves multiselect scroll.\n         */\n        onScroll: function () {\n            var height = this.$wrapper.height(),\n                scrollHeight = this.$wrapper.prop('scrollHeight'),\n                scrollTop = Math.ceil(this.$wrapper.prop('scrollTop'));\n\n            if (!this.options.optionsLoaded && scrollHeight - height <= scrollTop) {\n                this.loadOptions();\n            }\n        },\n\n        /**\n         * Behaves keyup event on input search\n         */\n        onKeyUp: function () {\n            if (this.getSearchCriteria() === this.filter) {\n                return false;\n            }\n\n            this.setFilter();\n            this.clearMultiselectOptions();\n            this.setCurrentPage(0);\n            this.loadOptions();\n        },\n\n        /**\n         * Callback for select change event\n         */\n        onOptionsChange: function () {\n            this.selectedValues = _.map(this.domElement.options, function (option) {\n                this.values[option.value] = true;\n\n                return option.value;\n            }, this);\n\n            this._updateSelectedCounter();\n        },\n\n        /**\n         * Overrides native check behaviour.\n         *\n         * @param {Event} event\n         */\n        onCheck: function (event) {\n            var checkbox = event.target,\n                option = {\n                    value: checkbox.value,\n                    label: $(checkbox).parent('label').text()\n                };\n\n            checkbox.checked ? this._createSelectedOption(option) : this._removeSelectedOption(option);\n            event.stopPropagation();\n        },\n\n        /**\n         * Show error message.\n         *\n         * @param {String} message\n         */\n        onError: function (message) {\n            alert({\n                content: message\n            });\n        },\n\n        /**\n         * Updates current filter state.\n         */\n        setFilter: function () {\n            this.filter = this.getSearchCriteria() || '';\n        },\n\n        /**\n         * Reads search input value.\n         *\n         * @return {String}\n         */\n        getSearchCriteria: function () {\n            return $.trim(this.$input.val());\n        },\n\n        /**\n         * Load options data.\n         */\n        loadOptions: function () {\n            var nextPage = this.getCurrentPage() + 1;\n\n            this.$wrapper.trigger('processStart');\n            this.$input.prop('disabled', true);\n\n            $.get(this.options.nextPageUrl, {\n                p: nextPage,\n                s: this.filter\n            })\n            .done(function (response) {\n                if (response.success) {\n                    this.appendOptions(response.result);\n                    this.setCurrentPage(nextPage);\n                } else {\n                    this.onError(response.errorMessage);\n                }\n            }.bind(this))\n            .always(function () {\n                this.$wrapper.trigger('processStop');\n                this.$input.prop('disabled', false);\n\n                if (this.filter) {\n                    this.$input.focus();\n                }\n            }.bind(this));\n        },\n\n        /**\n         * Append loaded options\n         *\n         * @param {Array} options\n         */\n        appendOptions: function (options) {\n            var divOptions = [];\n\n            if (!options.length) {\n                return false;\n            }\n\n            if (this.isOptionsLoaded(options)) {\n                return;\n            }\n\n            options.forEach(function (option) {\n                if (!this.values[option.value]) {\n                    this.values[option.value] = true;\n                    option.selected = this._isOptionSelected(option);\n                    divOptions.push(this._createMultiSelectOption(option));\n                    this._setLastAppendOption(option.value);\n                }\n            }, this);\n\n            this.$wrapper.append(divOptions);\n        },\n\n        /**\n         * Clear multiselect options\n         */\n        clearMultiselectOptions: function () {\n            this._setLastAppendOption(0);\n            this.values = {};\n            this.$wrapper.empty();\n        },\n\n        /**\n         * Checks if all options are already loaded\n         *\n         * @return {Boolean}\n         */\n        isOptionsLoaded: function (options) {\n            this.options.optionsLoaded = this.options.lastAppendValue === options[options.length - 1].value;\n\n            return this.options.optionsLoaded;\n        },\n\n        /**\n         * Setter for current page.\n         *\n         * @param {Number} page\n         */\n        setCurrentPage: function (page) {\n            this.options.currentPage = page;\n        },\n\n        /**\n         * Getter for current page.\n         *\n         * @return {Number}\n         */\n        getCurrentPage: function () {\n            return this.options.currentPage;\n        },\n\n        /**\n         * Creates new selected option for select element\n         *\n         * @param {Object} option - option object\n         * @param {String} option.value - option value\n         * @param {String} option.label - option label\n         * @private\n         */\n        _createSelectedOption: function (option) {\n            var selectOption = new Option(option.label, option.value, false, true);\n\n            this.element.append(selectOption);\n            this.selectedValues.push(option.value);\n            this._updateSelectedCounter();\n\n            return selectOption;\n        },\n\n        /**\n         * Remove passed option from select element\n         *\n         * @param {Object} option - option object\n         * @param {String} option.value - option value\n         * @param {String} option.label - option label\n         * @return {Object} option\n         * @private\n         */\n        _removeSelectedOption: function (option) {\n            var unselectedOption = _.findWhere(this.domElement.options, {\n                value: option.value\n            });\n\n            if (!_.isUndefined(unselectedOption)) {\n                this.domElement.remove(unselectedOption.index);\n                this.selectedValues.splice(_.indexOf(this.selectedValues, option.value), 1);\n                this._updateSelectedCounter();\n            }\n\n            return unselectedOption;\n        },\n\n        /**\n         * Creates new DIV option for multiselect widget\n         *\n         * @param {Object} option - option object\n         * @param {String} option.value - option value\n         * @param {String} option.label - option label\n         * @param {Boolean} option.selected - is option selected\n         * @private\n         */\n        _createMultiSelectOption: function (option) {\n            var item = this.$item.clone(),\n                checkbox = item.find('input'),\n                isSelected = !!option.selected;\n\n            checkbox.val(option.value)\n                .prop('checked', isSelected)\n                .toggleClass(this.options.mselectCheckedClass, isSelected);\n\n            item.find('label > span').text(option.label);\n\n            return item;\n        },\n\n        /**\n         * Checks if passed option should be selected\n         *\n         * @param {Object} option - option object\n         * @param {String} option.value - option value\n         * @param {String} option.label - option label\n         * @param {Boolean} option.selected - is option selected\n         * @return {Boolean}\n         * @private\n         */\n        _isOptionSelected: function (option) {\n            return !!~this.selectedValues.indexOf(option.value);\n        },\n\n        /**\n         * Saves last added option value.\n         *\n         * @param {Number} value\n         * @private\n         */\n        _setLastAppendOption: function (value) {\n            this.options.lastAppendValue = value;\n        },\n\n        /**\n         * Updates counter of selected items.\n         *\n         * @private\n         */\n        _updateSelectedCounter: function () {\n            this.$selectedCounter.text(this.selectedValues.length);\n        }\n    });\n\n    return $.mage.multiselect2;\n});\n","mage/polyfill.js":"(function (root, doc) {\n    'use strict';\n\n    var Storage;\n\n    try {\n        if (!root.localStorage || !root.sessionStorage) {\n            throw new Error();\n        }\n\n        localStorage.setItem('storage_test', 1);\n        localStorage.removeItem('storage_test');\n    } catch (e) {\n        /**\n         * Returns a storage object to shim local or sessionStorage\n         * @param {String} type - either 'local' or 'session'\n         */\n        Storage = function (type) {\n            var data;\n\n            /**\n             * Creates a cookie\n             * @param {String} name\n             * @param {String} value\n             * @param {Integer} days\n             */\n            function createCookie(name, value, days) {\n                var date, expires;\n\n                if (days) {\n                    date = new Date();\n                    date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);\n                    expires = '; expires=' + date.toGMTString();\n                } else {\n                    expires = '';\n                }\n                doc.cookie = name + '=' + value + expires + '; path=/';\n            }\n\n            /**\n             * Reads value of a cookie\n             * @param {String} name\n             */\n            function readCookie(name) {\n                var nameEQ = name + '=',\n                    ca = doc.cookie.split(';'),\n                    i = 0,\n                    c;\n\n                for (i = 0; i < ca.length; i++) {\n                    c = ca[i];\n\n                    while (c.charAt(0) === ' ') {\n                        c = c.substring(1, c.length);\n                    }\n\n                    if (c.indexOf(nameEQ) === 0) {\n                        return c.substring(nameEQ.length, c.length);\n                    }\n                }\n\n                return null;\n            }\n\n            /**\n             * Returns cookie name based upon the storage type.\n             * If this is session storage, the function returns a unique cookie per tab\n             */\n            function getCookieName() {\n\n                if (type !== 'session') {\n                    return 'localstorage';\n                }\n\n                if (!root.name) {\n                    root.name = new Date().getTime();\n                }\n\n                return 'sessionStorage' + root.name;\n            }\n\n            /**\n             * Sets storage cookie to a data object\n             * @param {Object} dataObject\n             */\n            function setData(dataObject) {\n                data = encodeURIComponent(JSON.stringify(dataObject));\n                createCookie(getCookieName(), data, 365);\n            }\n\n            /**\n             * Clears value of cookie data\n             */\n            function clearData() {\n                createCookie(getCookieName(), '', 365);\n            }\n\n            /**\n             * @returns value of cookie data\n             */\n            function getData() {\n                var dataResponse = readCookie(getCookieName());\n\n                return dataResponse ? JSON.parse(decodeURIComponent(dataResponse)) : {};\n            }\n\n            data = getData();\n\n            return {\n                length: 0,\n\n                /**\n                 * Clears data from storage\n                 */\n                clear: function () {\n                    data = {};\n                    this.length = 0;\n                    clearData();\n                },\n\n                /**\n                 * Gets an item from storage\n                 * @param {String} key\n                 */\n                getItem: function (key) {\n                    return data[key] === undefined ? null : data[key];\n                },\n\n                /**\n                 * Gets an item by index from storage\n                 * @param {Integer} i\n                 */\n                key: function (i) {\n                    var ctr = 0,\n                        k;\n\n                    for (k in data) {\n\n                        if (data.hasOwnProperty(k)) {\n\n                            // eslint-disable-next-line max-depth\n                            if (ctr.toString() === i.toString()) {\n                                return k;\n                            }\n                            ctr++;\n                        }\n                    }\n\n                    return null;\n                },\n\n                /**\n                 * Removes an item from storage\n                 * @param {String} key\n                 */\n                removeItem: function (key) {\n                    delete data[key];\n                    this.length--;\n                    setData(data);\n                },\n\n                /**\n                 * Sets an item from storage\n                 * @param {String} key\n                 * @param {String} value\n                 */\n                setItem: function (key, value) {\n                    data[key] = value.toString();\n                    this.length++;\n                    setData(data);\n                }\n            };\n        };\n\n        root.localStorage.prototype = root.localStorage = new Storage('local');\n        root.sessionStorage.prototype = root.sessionStorage = new Storage('session');\n    }\n})(window, document);\n","mage/popup-window.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'jquery-ui-modules/widget'\n], function ($) {\n    'use strict';\n\n    $.widget('mage.popupWindow', {\n        options: {\n            centerBrowser: 0, // center window over browser window? {1 (YES) or 0 (NO)}. overrides top and left\n            centerScreen: 0, // center window over entire screen? {1 (YES) or 0 (NO)}. overrides top and left\n            height: 500, // sets the height in pixels of the window.\n            left: 0, // left position when the window appears.\n            location: 0, // determines whether the address bar is displayed {1 (YES) or 0 (NO)}.\n            menubar: 0, // determines whether the menu bar is displayed {1 (YES) or 0 (NO)}.\n            resizable: 0, // whether the window can be resized {1 (YES) or 0 (NO)}.\n            scrollbars: 0, // determines whether scrollbars appear on the window {1 (YES) or 0 (NO)}.\n            status: 0, // whether a status line appears at the bottom of the window {1 (YES) or 0 (NO)}.\n            width: 500, // sets the width in pixels of the window.\n            windowName: null, // name of window set from the name attribute of the element that invokes the click\n            windowURL: null, // url used for the popup\n            top: 0, // top position when the window appears.\n            toolbar: 0 // determines whether a toolbar is displayed {1 (YES) or 0 (NO)}.\n        },\n\n        /**\n         * @private\n         */\n        _create: function () {\n            this.element.on('click', $.proxy(this._openPopupWindow, this));\n        },\n\n        /**\n         * @param {jQuery.Event} event\n         * @private\n         */\n        _openPopupWindow: function (event) {\n            var element = $(event.target),\n                settings = this.options,\n                windowFeatures =\n                    'height=' + settings.height +\n                        ',width=' + settings.width +\n                        ',toolbar=' + settings.toolbar +\n                        ',scrollbars=' + settings.scrollbars +\n                        ',status=' + settings.status +\n                        ',resizable=' + settings.resizable +\n                        ',location=' + settings.location +\n                        ',menuBar=' + settings.menubar,\n                centeredX,\n                centeredY;\n\n            settings.windowName = settings.windowName || element.attr('name');\n            settings.windowURL = settings.windowURL || element.attr('href');\n\n            if (settings.centerBrowser) {\n                centeredY = window.screenY + (window.outerHeight / 2 - settings.height / 2);\n                centeredX = window.screenX + (window.outerWidth / 2 - settings.width / 2);\n                windowFeatures += ',left=' + centeredX + ',top=' + centeredY;\n            } else if (settings.centerScreen) {\n                centeredY = (screen.height - settings.height) / 2;\n                centeredX = (screen.width - settings.width) / 2;\n                windowFeatures += ',left=' + centeredX + ',top=' + centeredY;\n            } else {\n                windowFeatures += ',left=' + settings.left + ',top=' + settings.top;\n            }\n\n            window.open(settings.windowURL, settings.windowName, windowFeatures).focus();\n            event.preventDefault();\n        }\n    });\n\n    return $.mage.popupWindow;\n});\n","mage/redirect-url.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'jquery-ui-modules/widget'\n], function ($) {\n    'use strict';\n\n    $.widget('mage.redirectUrl', {\n        options: {\n            event: 'click',\n            url: undefined\n        },\n\n        /**\n         * This method binds elements found in this widget.\n         * @private\n         */\n        _bind: function () {\n            var handlers = {};\n\n            handlers[this.options.event] = '_onEvent';\n            this._on(handlers);\n        },\n\n        /**\n         * This method constructs a new widget.\n         * @private\n         */\n        _create: function () {\n            this._bind();\n        },\n\n        /**\n         * This method set the url for the redirect.\n         * @private\n         */\n        _onEvent: function () {\n            if (this.options.url) {\n                location.href = this.options.url;\n            } else {\n                location.href = this.element.val();\n            }\n        }\n    });\n\n    return $.mage.redirectUrl;\n});\n","mage/smart-keyboard-handler.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\ndefine([\n    'jquery'\n], function ($) {\n    'use strict';\n\n    /**\n     * @return {Object}\n     * @constructor\n     */\n    function KeyboardHandler() {\n        var body = $('body'),\n            focusState = false,\n            tabFocusClass = '_keyfocus',\n            productsGrid = '[data-container=\"product-grid\"]',\n            catalogProductsGrid = $(productsGrid),\n            CODE_TAB = 9;\n\n        /**\n         * Handle logic, when onTabKeyPress fired at first.\n         * Then it changes state.\n         */\n        function onFocusInHandler() {\n            focusState = true;\n            body.addClass(tabFocusClass)\n                .off('focusin.keyboardHandler', onFocusInHandler);\n        }\n\n        /**\n         * Handle logic to remove state after onTabKeyPress to normal.\n         */\n        function onClickHandler() {\n            focusState = false;\n            body.removeClass(tabFocusClass)\n                .off('click', onClickHandler);\n        }\n\n        /**\n         * Tab key onKeypress handler. Apply main logic:\n         *  - call differ actions onTabKeyPress and onClick\n         */\n        function smartKeyboardFocus() {\n            $(document).on('keydown keypress', function (event) {\n                if (event.which === CODE_TAB && !focusState) {\n                    body\n                        .on('focusin.keyboardHandler', onFocusInHandler)\n                        .on('click', onClickHandler);\n                }\n            });\n\n            // ARIA support for catalog grid products\n            if (catalogProductsGrid.length) {\n                body.on('focusin.gridProducts', productsGrid, function () {\n                    if (body.hasClass(tabFocusClass)) {\n                        $(this).addClass('active');\n                    }\n                });\n                body.on('focusout.gridProducts', productsGrid, function () {\n                    $(this).removeClass('active');\n                });\n            }\n        }\n\n        /**\n         * Attach smart focus on specific element.\n         * @param {jQuery} element\n         */\n        function handleFocus(element) {\n            element.on('focusin.emulateTabFocus', function () {\n                focusState = true;\n                body.addClass(tabFocusClass);\n                element.off();\n            });\n\n            element.on('focusout.emulateTabFocus', function () {\n                focusState = false;\n                body.removeClass(tabFocusClass);\n                element.off();\n            });\n        }\n\n        return {\n            apply: smartKeyboardFocus,\n            focus: handleFocus\n        };\n    }\n\n    return new KeyboardHandler;\n});\n","mage/sticky.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'jquery-ui-modules/widget'\n], function ($) {\n    'use strict';\n\n    $.widget('mage.sticky', {\n        options: {\n            /**\n             * Element selector, who's height will be used to restrict the\n             * maximum offsetTop position of the stuck element.\n             * Default uses document body.\n             * @type {String}\n             */\n            container: '',\n\n            /**\n             * Spacing in pixels above the stuck element\n             * @type {Number|Function} Number or Function that will return a Number\n             */\n            spacingTop: 0,\n\n            /**\n             * Allows postponing sticking, until element will go out of the\n             * screen for the number of pixels.\n             * @type {Number|Function} Number or Function that will return a Number\n             */\n            stickAfter: 0,\n\n            /**\n             * CSS class for active sticky state\n             * @type {String}\n             */\n            stickyClass: '_sticky'\n        },\n\n        /**\n         * Retrieve option value\n         * @param  {String} option\n         * @return {*}\n         * @private\n         */\n        _getOptionValue: function (option) {\n            var value = this.options[option] || 0;\n\n            if (typeof value === 'function') {\n                value = this.options[option]();\n            }\n\n            return value;\n        },\n\n        /**\n         * Bind handlers to scroll event\n         * @private\n         */\n        _create: function () {\n            $(window).on({\n                'scroll': $.proxy(this._stick, this),\n                'resize': $.proxy(this.reset, this)\n            });\n\n            this.element.on('dimensionsChanged', $.proxy(this.reset, this));\n\n            this.reset();\n\n            // Application of the workaround for IE11 and Edge\n            this.normalizeIE11AndEdgeScroll();\n        },\n\n        /**\n         * float Block on windowScroll\n         * @private\n         */\n        _stick: function () {\n            var offset,\n                isStatic,\n                stuck,\n                stickAfter;\n\n            isStatic = this.element.css('position') === 'static';\n\n            if (!isStatic && this.element.is(':visible')) {\n                offset = $(document).scrollTop() -\n                    this.parentOffset +\n                    this._getOptionValue('spacingTop');\n\n                offset = Math.max(0, Math.min(offset, this.maxOffset));\n\n                stuck = this.element.hasClass(this.options.stickyClass);\n                stickAfter = this._getOptionValue('stickAfter');\n\n                if (offset && !stuck && offset < stickAfter) {\n                    offset = 0;\n                }\n\n                this.element\n                    .toggleClass(this.options.stickyClass, offset > 0)\n                    .css('top', offset);\n            }\n        },\n\n        /**\n         * Defines maximum offset value of the element.\n         * @private\n         */\n        _calculateDimens: function () {\n            var $parent         = this.element.parent(),\n                topMargin       = parseInt(this.element.css('margin-top'), 10),\n                parentHeight    = $parent.height() - topMargin,\n                height          = this.element.innerHeight(),\n                maxScroll       = document.body.offsetHeight - window.innerHeight;\n\n            if (this.options.container.length > 0) {\n                maxScroll = $(this.options.container).height();\n            }\n\n            this.parentOffset   = $parent.offset().top + topMargin;\n            this.maxOffset      = maxScroll - this.parentOffset;\n\n            if (this.maxOffset + height >= parentHeight) {\n                this.maxOffset = parentHeight - height;\n            }\n\n            return this;\n        },\n\n        /**\n         * Facade method that places sticky element where it should be.\n         */\n        reset: function () {\n            this._calculateDimens()\n                ._stick();\n        },\n\n        /**\n         * Workaround for IE11 and Edge that solves the IE known rendering issue\n         * that prevents sticky element from jumpy movement on scrolling the page.\n         *\n         * Alternatively, undesired jumpy movement can be eliminated by changing the setting in IE:\n         * Settings > Internet options > Advanced tab > inside 'Browsing' item > set 'Use smooth scrolling' to False\n         */\n        normalizeIE11AndEdgeScroll: function () {\n            if (navigator.userAgent.match(/Trident.*rv[ :]*11\\.|Edge\\//)) {\n                document.body.addEventListener('mousewheel', function () {\n                    event.preventDefault();\n                    window.scrollTo(0, window.pageYOffset - event.wheelDelta);\n                });\n            }\n        }\n    });\n\n    return $.mage.sticky;\n});\n","mage/storage.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine(['jquery', 'mage/url'], function ($, urlBuilder) {\n    'use strict';\n\n    return {\n        /**\n         * Perform asynchronous GET request to server.\n         * @param {String} url\n         * @param {Boolean} global\n         * @param {String} contentType\n         * @param {Object} headers\n         * @returns {Deferred}\n         */\n        get: function (url, global, contentType, headers) {\n            headers = headers || {};\n            global = global === undefined ? true : global;\n            contentType = contentType || 'application/json';\n\n            return $.ajax({\n                url: urlBuilder.build(url),\n                type: 'GET',\n                global: global,\n                contentType: contentType,\n                headers: headers\n            });\n        },\n\n        /**\n         * Perform asynchronous POST request to server.\n         * @param {String} url\n         * @param {String} data\n         * @param {Boolean} global\n         * @param {String} contentType\n         * @param {Object} headers\n         * @returns {Deferred}\n         */\n        post: function (url, data, global, contentType, headers) {\n            headers = headers || {};\n            global = global === undefined ? true : global;\n            contentType = contentType || 'application/json';\n\n            return $.ajax({\n                url: urlBuilder.build(url),\n                type: 'POST',\n                data: data,\n                global: global,\n                contentType: contentType,\n                headers: headers\n            });\n        },\n\n        /**\n         * Perform asynchronous PUT request to server.\n         * @param {String} url\n         * @param {String} data\n         * @param {Boolean} global\n         * @param {String} contentType\n         * @param {Object} headers\n         * @returns {Deferred}\n         */\n        put: function (url, data, global, contentType, headers) {\n            var ajaxSettings = {};\n\n            headers = headers || {};\n            global = global === undefined ? true : global;\n            contentType = contentType || 'application/json';\n            ajaxSettings.url = urlBuilder.build(url);\n            ajaxSettings.type = 'PUT';\n            ajaxSettings.data = data;\n            ajaxSettings.global = global;\n            ajaxSettings.contentType = contentType;\n            ajaxSettings.headers = headers;\n\n            return $.ajax(ajaxSettings);\n        },\n\n        /**\n         * Perform asynchronous DELETE request to server.\n         * @param {String} url\n         * @param {Boolean} global\n         * @param {String} contentType\n         * @param {Object} headers\n         * @returns {Deferred}\n         */\n        delete: function (url, global, contentType, headers) {\n            headers = headers || {};\n            global = global === undefined ? true : global;\n            contentType = contentType || 'application/json';\n\n            return $.ajax({\n                url: urlBuilder.build(url),\n                type: 'DELETE',\n                global: global,\n                contentType: contentType,\n                headers: headers\n            });\n        }\n    };\n});\n","mage/tabs.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'jquery-ui-modules/widget',\n    'jquery-ui-modules/core',\n    'mage/mage',\n    'mage/collapsible'\n], function ($) {\n    'use strict';\n\n    $.widget('mage.tabs', {\n        options: {\n            active: 0,\n            disabled: [],\n            openOnFocus: true,\n            collapsible: false,\n            collapsibleElement: '[data-role=collapsible]',\n            header: '[data-role=title]',\n            content: '[data-role=content]',\n            trigger: '[data-role=trigger]',\n            closedState: null,\n            openedState: null,\n            disabledState: null,\n            ajaxUrlElement: '[data-ajax=true]',\n            ajaxContent: false,\n            loadingClass: null,\n            saveState: false,\n            animate: false,\n            icons: {\n                activeHeader: null,\n                header: null\n            }\n        },\n\n        /**\n         * @private\n         */\n        _create: function () {\n            if (typeof this.options.disabled === 'string') {\n                this.options.disabled = this.options.disabled.split(' ').map(function (item) {\n                    return parseInt(item, 10);\n                });\n            }\n            this._processPanels();\n            this._handleDeepLinking();\n            this._processTabIndex();\n            this._closeOthers();\n            this._bind();\n        },\n\n        /**\n         * @private\n         */\n        _destroy: function () {\n            $.each(this.collapsibles, function () {\n                $(this).collapsible('destroy');\n            });\n        },\n\n        /**\n         * If deep linking is used, all sections must be closed but the one that contains the anchor.\n         * @private\n         */\n        _handleDeepLinking: function () {\n            var self = this,\n                anchor = window.location.hash,\n                isValid = $.mage.isValidSelector(anchor),\n                anchorId = anchor.replace('#', '');\n\n            if (anchor && isValid) {\n                $.each(self.contents, function (i) {\n                    if ($(this).attr('id') === anchorId || $(this).find('#' + anchorId).length) {\n                        self.collapsibles.not(self.collapsibles.eq(i)).collapsible('forceDeactivate');\n\n                        return false;\n                    }\n                });\n            }\n        },\n\n        /**\n         * When the widget gets instantiated, the first tab that is not disabled receive focusable property\n         * All tabs receive tabIndex 0\n         * @private\n         */\n        _processTabIndex: function () {\n            var self = this;\n\n            self.triggers.attr('tabIndex', 0);\n            $.each(this.collapsibles, function (i) {\n                self.triggers.attr('tabIndex', 0);\n                self.triggers.eq(i).attr('tabIndex', 0);\n            });\n        },\n\n        /**\n         * Prepare the elements for instantiating the collapsible widget\n         * @private\n         */\n        _processPanels: function () {\n            var isNotNested = this._isNotNested.bind(this);\n\n            this.contents = this.element\n                .find(this.options.content)\n                .filter(isNotNested);\n\n            this.collapsibles =  this.element\n                .find(this.options.collapsibleElement)\n                .filter(isNotNested);\n\n            this.collapsibles\n                .attr('role', 'presentation')\n                .parent()\n                .attr('role', 'tablist');\n\n            this.headers = this.element\n                .find(this.options.header)\n                .filter(isNotNested);\n\n            if (this.headers.length === 0) {\n                this.headers = this.collapsibles;\n            }\n            this.triggers = this.element\n                .find(this.options.trigger)\n                .filter(isNotNested);\n\n            if (this.triggers.length === 0) {\n                this.triggers = this.headers;\n            }\n            this._callCollapsible();\n        },\n\n        /**\n         * Checks if element is not in nested container to keep the correct scope of collapsible\n         * @param {Number} index\n         * @param {HTMLElement} element\n         * @private\n         * @return {Boolean}\n         */\n        _isNotNested: function (index, element) {\n            var parentContent = $(element).parents(this.options.content);\n\n            return !parentContent.length || !this.element.find(parentContent).length;\n        },\n\n        /**\n         * Setting the disabled and active tabs and calling instantiation of collapsible\n         * @private\n         */\n        _callCollapsible: function () {\n            var self = this,\n                disabled = false,\n                active = false;\n\n            $.each(this.collapsibles, function (i) {\n                disabled = active = false;\n\n                if ($.inArray(i, self.options.disabled) !== -1) {\n                    disabled = true;\n                }\n\n                if (i === self.options.active) {\n                    active = true;\n                }\n                self._instantiateCollapsible(this, i, active, disabled);\n            });\n        },\n\n        /**\n         * Instantiate collapsible.\n         *\n         * @param {HTMLElement} element\n         * @param {Number} index\n         * @param {*} active\n         * @param {*} disabled\n         * @private\n         */\n        _instantiateCollapsible: function (element, index, active, disabled) {\n            $(element).collapsible(\n                $.extend({}, this.options, {\n                    active: active,\n                    disabled: disabled,\n                    header: this.headers.eq(index),\n                    content: this.contents.eq(index),\n                    trigger: this.triggers.eq(index)\n                })\n            );\n        },\n\n        /**\n         * Adding callback to close others tabs when one gets opened\n         * @private\n         */\n        _closeOthers: function () {\n            var self = this;\n\n            $.each(this.collapsibles, function () {\n                $(this).on('beforeOpen', function () {\n                    self.collapsibles.not(this).collapsible('forceDeactivate');\n                });\n            });\n        },\n\n        /**\n         * @param {*} index\n         */\n        activate: function (index) {\n            this._toggleActivate('activate', index);\n        },\n\n        /**\n         * @param {*} index\n         */\n        deactivate: function (index) {\n            this._toggleActivate('deactivate', index);\n        },\n\n        /**\n         * @param {*} action\n         * @param {*} index\n         * @private\n         */\n        _toggleActivate: function (action, index) {\n            this.collapsibles.eq(index).collapsible(action);\n        },\n\n        /**\n         * @param {*} index\n         */\n        disable: function (index) {\n            this._toggleEnable('disable', index);\n        },\n\n        /**\n         * @param {*} index\n         */\n        enable: function (index) {\n            this._toggleEnable('enable', index);\n        },\n\n        /**\n         * @param {*} action\n         * @param {*} index\n         * @private\n         */\n        _toggleEnable: function (action, index) {\n            var self = this;\n\n            if ($.isArray(index)) {\n                $.each(index, function () {\n                    self.collapsibles.eq(this).collapsible(action);\n                });\n            } else if (index === undefined) {\n                this.collapsibles.collapsible(action);\n            } else {\n                this.collapsibles.eq(index).collapsible(action);\n            }\n        },\n\n        /**\n         * @param {jQuery.Event} event\n         * @private\n         */\n        _keydown: function (event) {\n            var self = this,\n                keyCode, toFocus, toFocusIndex, enabledTriggers, length, currentIndex, nextToFocus;\n\n            if (event.altKey || event.ctrlKey) {\n                return;\n            }\n            keyCode = $.ui.keyCode;\n            toFocus = false;\n            enabledTriggers = [];\n\n            $.each(this.triggers, function () {\n                if (!self.collapsibles.eq(self.triggers.index($(this))).collapsible('option', 'disabled')) {\n                    enabledTriggers.push(this);\n                }\n            });\n            length = $(enabledTriggers).length;\n            currentIndex = $(enabledTriggers).index(event.target);\n\n            /**\n             * @param {String} direction\n             * @return {*}\n             */\n            nextToFocus = function (direction) {\n                if (length > 0) {\n                    if (direction === 'right') {\n                        toFocusIndex = (currentIndex + 1) % length;\n                    } else {\n                        toFocusIndex = (currentIndex + length - 1) % length;\n                    }\n\n                    return enabledTriggers[toFocusIndex];\n                }\n\n                return event.target;\n            };\n\n            switch (event.keyCode) {\n                case keyCode.RIGHT:\n                case keyCode.DOWN:\n                    toFocus = nextToFocus('right');\n                    break;\n\n                case keyCode.LEFT:\n                case keyCode.UP:\n                    toFocus = nextToFocus('left');\n                    break;\n\n                case keyCode.HOME:\n                    toFocus = enabledTriggers[0];\n                    break;\n\n                case keyCode.END:\n                    toFocus = enabledTriggers[length - 1];\n                    break;\n            }\n\n            if (toFocus) {\n                toFocusIndex = this.triggers.index(toFocus);\n                $(event.target).attr('tabIndex', -1);\n                $(toFocus).attr('tabIndex', 0);\n                toFocus.focus();\n\n                if (this.options.openOnFocus) {\n                    this.activate(toFocusIndex);\n                }\n                event.preventDefault();\n            }\n        },\n\n        /**\n         * @private\n         */\n        _bind: function () {\n            var events = {\n                keydown: '_keydown'\n            };\n\n            this._off(this.triggers);\n            this._on(this.triggers, events);\n        }\n    });\n\n    return $.mage.tabs;\n});\n","mage/template.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'underscore'\n], function (_) {\n    'use strict';\n\n    /**\n     * Checks if provided string is a valid DOM selector.\n     *\n     * @param {String} selector - Selector to be checked.\n     * @returns {Boolean}\n     */\n    function isSelector(selector) {\n        try {\n            document.querySelector(selector);\n\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Unescapes characters used in underscore templates.\n     *\n     * @param {String} str - String to be processed.\n     * @returns {String}\n     */\n    function unescape(str) {\n        return str.replace(/&lt;%|%3C%/g, '<%').replace(/%&gt;|%%3E/g, '%>');\n    }\n\n    /**\n     * If 'tmpl' is a valid selector, returns target node's innerHTML if found.\n     * Else, returns empty string and emits console warning.\n     * If 'tmpl' is not a selector, returns 'tmpl' as is.\n     *\n     * @param {String} tmpl\n     * @returns {String}\n     */\n    function getTmplString(tmpl) {\n        if (isSelector(tmpl)) {\n            tmpl = document.querySelector(tmpl);\n\n            if (tmpl) {\n                tmpl = tmpl.innerHTML.trim();\n            } else {\n                console.warn('No template was found by selector: ' + tmpl);\n\n                tmpl = '';\n            }\n        }\n\n        return unescape(tmpl);\n    }\n\n    /**\n     * Compiles or renders template provided either\n     * by selector or by the template string.\n     *\n     * @param {String} tmpl - Template string or selector.\n     * @param {(Object|Array|Function)} [data] - Data object with which to render template.\n     * @returns {String|Function}\n     */\n    return function (tmpl, data) {\n        var render;\n\n        tmpl   = getTmplString(tmpl);\n        render = _.template(tmpl);\n\n        return !_.isUndefined(data) ?\n            render(data) :\n            render;\n    };\n});\n","mage/terms.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\n/**\n * @deprecated since version 2.2.0\n */\ndefine([\n    'jquery'\n], function ($) {\n    'use strict';\n\n    /**\n     * @param {*} args\n     */\n    $.fn.terms = function (args) {\n\n        // default\n        var defaults = {\n                start: 0,\n                wrapper: '',\n                showAnchor: '',\n                effects: 'slide'\n            },\n            options = $.extend(defaults, args);\n\n        this.each(function () {\n            var obj = $(this),\n                wrapper = options.wrapper !== '' ? '> ' + options.wrapper : '',\n                switches = $(wrapper + '> [data-section=\"title\"] > [data-toggle=\"switch\"]', obj),\n                terms = $(wrapper + '> [data-section=\"content\"]', obj),\n                t = switches.length,\n                marginTop = $(switches[0]).closest('[data-section=\"title\"]').css('position') == 'absolute' ? 0 : null, //eslint-disable-line\n                title,\n                current,\n\n                /**\n                 * @param {*} item\n                 */\n                showItem = function (item) {\n                    if (item != current && !$(switches[item]).closest('[data-section=\"title\"]').hasClass('disabled')) { //eslint-disable-line\n                        $(switches).closest('[data-section=\"title\"]').removeClass('active');\n\n                        if (options.wrapper !== '') {\n                            $(switches).parent().parent().removeClass('active');\n                        }\n                        $(terms).removeClass('active');\n                        $(switches[item]).closest('[data-section=\"title\"]').addClass('active');\n\n                        if (options.wrapper !== '') {\n                            $(switches[current]).parent().parent().addClass('active');\n                        }\n                        $(terms[item]).addClass('active');\n                        current = item;\n                    } else if (\n                        // Check if this is accordion width as criteria for now\n                        (obj.attr('data-sections') == 'accordion' || $(switches[item]).closest('[data-section=\"title\"]').css('width') == obj.css('width')) && //eslint-disable-line\n                        item == current && !$(switches[item]).closest('[data-section=\"title\"]').hasClass('disabled') //eslint-disable-line\n                    ) {\n                        $(switches).closest('[data-section=\"title\"]').removeClass('active');\n\n                        if (options.wrapper !== '') {\n                            $(switches).parent().parent().removeClass('active');\n                        }\n                        $(terms).removeClass('active');\n                        current = -1;\n                    }\n                },\n\n                /**\n                 * Init.\n                 */\n                init = function () {\n                    var linksList, i, classes, dataSection, itemHref, itemClass, fromUrl;\n\n                    if (t > 0) {\n                        if ($(switches[0]).closest('[data-section=\"title\"]').css('display') == 'table-cell') { //eslint-disable-line\n                            obj.addClass('adjusted');\n\n                            if (obj[0].tagName == 'DL') { //eslint-disable-line eqeqeq, max-depth\n                                linksList = $('<dd>');\n                            } else {\n                                linksList = $('<div>');\n                            }\n                            linksList.addClass('sections-nav');\n                            obj.prepend(linksList);\n\n                            for (i = 0; i < t; i++) { //eslint-disable-line max-depth\n                                title = $(switches[i]).html();\n                                classes = $(switches[i]).closest('[data-section=\"title\"]').attr('class');\n                                dataSection = $(switches[i]).closest('[data-section=\"title\"]').attr('data-section');\n                                itemHref = $(switches[i]).attr('href');\n                                itemClass = $(switches[i]).attr('class');\n                                $(switches[i]).parent('[data-section=\"title\"]').hide();\n                                switches[i] = $('<a/>', {\n                                    href: itemHref,\n                                    'class': itemClass,\n                                    html: title\n                                }).appendTo(linksList);\n                                $(switches[i]).wrap(\n                                    '<strong class=\"' + classes + '\" data-section=\"' + dataSection + '\" />'\n                                );\n                            }\n                        }\n                        $(switches).each(function (ind, el) {\n                            $(el).click(function (event) {\n                                event.preventDefault();\n                                showItem(ind);\n                            });\n\n                            if (marginTop !== null) {\n                                $(el).closest('[data-section=\"title\"]').css({\n                                    'top': marginTop + 'px'\n                                });\n                                marginTop += $(el).closest('[data-section=\"title\"]').outerHeight(true);\n                                obj.css({\n                                    'min-height': marginTop + 'px'\n                                });\n                            }\n                        });\n\n                        fromUrl = false;\n\n                        if (window.location.hash.length > 0) {\n                            $(terms).each(function (ind, el) {\n                                if ('#info-' + $(el).attr('id') == window.location.hash) { //eslint-disable-line eqeqeq\n                                    showItem(ind);\n                                    $('html, body').animate({\n                                        scrollTop: $(switches[ind]).offset().top\n                                    }, 700);\n                                    fromUrl = true;\n                                }\n                            });\n                        }\n\n                        if (fromUrl === false) {\n                            if (options.start % 1 === 0) { //eslint-disable-line max-depth\n                                current = options.start + 1;\n                                showItem(options.start);\n                            } else {\n                                $(terms).each(function (ind, el) {\n                                    if ($(el).attr('id') == options.start) { //eslint-disable-line eqeqeq\n                                        current = ind + 1;\n                                        showItem(ind);\n                                        $('html, body').animate({\n                                            scrollTop: $(switches[ind]).offset().top\n                                        }, 700);\n                                    }\n                                });\n                            }\n                        }\n                    }\n                };\n\n            init();\n        });\n    };\n\n    return function (data, el) {\n        $(el).terms(data);\n    };\n});\n","mage/toggle.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'jquery-ui-modules/widget'\n], function ($) {\n    'use strict';\n\n    $.widget('mage.toggleAdvanced', {\n        options: {\n            baseToggleClass: 'active' // Class used to be toggled on clicked element\n        },\n\n        /**\n         * Toggle creation\n         * @private\n         */\n        _create: function () {\n            this.beforeCreate();\n            this._bindCore();\n            this.afterCreate();\n        },\n\n        /**\n         *  Core bound events & setup\n         * @protected\n         */\n        _bindCore: function () {\n            var widget = this;\n\n            this.element.on('click', $.proxy(function (e) {\n                widget._onClick();\n                e.preventDefault();\n            }, this));\n        },\n\n        /**\n         * Binding Click event\n         *\n         * @protected\n         */\n        _onClick: function () {\n            this._prepareOptions();\n            this._toggleSelectors();\n        },\n\n        /**\n         * Method used to look for data attributes to override default options\n         *\n         * @protected\n         */\n        _prepareOptions: function () {\n            this.options.baseToggleClass = this.element.data('base-toggle-class') ?\n                this.element.data('base-toggle-class') : this.options.baseToggleClass;\n        },\n\n        /**\n         * Method responsible for hiding and revealing specified DOM elements\n         * Toggle the class on clicked element\n         *\n         * @protected\n         */\n        _toggleSelectors: function () {\n            this.element.toggleClass(this.options.baseToggleClass);\n        },\n\n        /**\n         * Method used to inject 3rd party functionality before create\n         * @public\n         */\n        beforeCreate: function () {},\n\n        /**\n         * Method used to inject 3rd party functionality after create\n         * @public\n         */\n        afterCreate: function () {}\n    });\n\n    // Extension for mage.toggle - Adding selectors support for other DOM elements we wish to toggle\n    $.widget('mage.toggleAdvanced', $.mage.toggleAdvanced, {\n\n        options: {\n            selectorsToggleClass: 'hidden',    // Class used to be toggled on selectors DOM elements\n            toggleContainers: null\n        },\n\n        /**\n         * Method responsible for hiding and revealing specified DOM elements\n         * If data-toggle-selectors attribute is present - toggle will be done on these selectors\n         * Otherwise we toggle the class on clicked element\n         *\n         * @protected\n         * @override\n         */\n        _toggleSelectors: function () {\n            this._super();\n\n            if (this.options.toggleContainers) {\n                $(this.options.toggleContainers).toggleClass(this.options.selectorsToggleClass);\n            } else {\n                this.element.toggleClass(this.options.baseToggleClass);\n            }\n        },\n\n        /**\n         * Method used to look for data attributes to override default options\n         *\n         * @protected\n         * @override\n         */\n        _prepareOptions: function () {\n            this.options.selectorsToggleClass = this.element.data('selectors-toggle-class') ?\n                this.element.data('selectors-toggle-class') : this.options.selectorsToggleClass;\n            this.options.toggleContainers = this.element.data('toggle-selectors') ?\n                this.element.data('toggle-selectors') : this.options.toggleContainers;\n            this._super();\n        }\n    });\n\n    // Extension for mage.toggle - Adding label toggle\n    $.widget('mage.toggleAdvanced', $.mage.toggleAdvanced, {\n\n        options: {\n            newLabel: null,             // Text of the new label to be used on toggle\n            curLabel: null,             // Text of the old label to be used on toggle\n            currentLabelElement: null   // Current label container\n        },\n\n        /**\n         * Binding Click event\n         *\n         * @protected\n         * @override\n         */\n        _onClick: function () {\n            this._super();\n            this._toggleLabel();\n        },\n\n        /**\n         * Method responsible for replacing clicked element labels\n         * @protected\n         */\n        _toggleLabel: function () {\n            var cachedLabel, currentLabelSelector;\n\n            if (this.options.newLabel) {\n                cachedLabel = this.options.newLabel;\n                currentLabelSelector = this.options.currentLabelElement ?\n                        $(this.options.currentLabelElement) : this.element;\n\n                this.element.data('toggle-label', this.options.curLabel);\n                currentLabelSelector.html(this.options.newLabel);\n\n                this.options.curLabel = this.options.newLabel;\n                this.options.newLabel = cachedLabel;\n            }\n        },\n\n        /**\n         * Method used to look for data attributes to override default options\n         *\n         * @protected\n         * @override\n         */\n        _prepareOptions: function () {\n            this.options.newLabel = this.element.data('toggle-label') ?\n                this.element.data('toggle-label') : this.options.newLabel;\n\n            this.options.currentLabelElement = this.element.data('current-label-el') ?\n                this.element.data('current-label-el') : this.options.currentLabelElement;\n\n            if (!this.options.currentLabelElement) {\n                this.options.currentLabelElement = this.element;\n            }\n\n            this.options.curLabel = $(this.options.currentLabelElement).html();\n\n            this._super();\n        }\n    });\n\n    return $.mage.toggleAdvanced;\n});\n","mage/tooltip.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\n/**\n * @deprecated since version 2.2.0\n */\ndefine([\n    'jquery',\n    'jquery-ui-modules/tooltip'\n], function ($) {\n    'use strict';\n\n    //Widget Wrapper\n    $.widget('mage.tooltip', $.ui.tooltip, {});\n\n    return $.mage.tooltip;\n});\n","mage/touch-slider.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'underscore',\n    'jquery-ui-modules/slider'\n], function ($, _) {\n    'use strict';\n\n    /**\n     * Adds support for touch events for regular jQuery UI slider.\n     */\n    $.widget('mage.touchSlider', $.ui.slider, {\n\n        /**\n         * Creates instance of widget.\n         *\n         * @override\n         */\n        _create: function () {\n            _.bindAll(\n                this,\n                '_mouseDown',\n                '_mouseMove',\n                '_onTouchEnd'\n            );\n\n            return this._superApply(arguments);\n        },\n\n        /**\n         * Initializes mouse events on element.\n         * @override\n         */\n        _mouseInit: function () {\n            var result = this._superApply(arguments);\n\n            this.element\n                .off('mousedown.' + this.widgetName)\n                .on('touchstart.' + this.widgetName, this._mouseDown);\n\n            return result;\n        },\n\n        /**\n         * Elements' 'mousedown' event handler polyfill.\n         * @override\n         */\n        _mouseDown: function (event) {\n            var prevDelegate = this._mouseMoveDelegate,\n                result;\n\n            event = this._touchToMouse(event);\n            result = this._super(event);\n\n            if (prevDelegate === this._mouseMoveDelegate) {\n                return result;\n            }\n\n            $(document)\n                .off('mousemove.' + this.widgetName)\n                .off('mouseup.' + this.widgetName);\n\n            $(document)\n                .on('touchmove.' + this.widgetName, this._mouseMove)\n                .on('touchend.' + this.widgetName, this._onTouchEnd)\n                .on('tochleave.' + this.widgetName, this._onTouchEnd);\n\n            return result;\n        },\n\n        /**\n         * Documents' 'mousemove' event handler polyfill.\n         *\n         * @override\n         * @param {Event} event - Touch event object.\n         */\n        _mouseMove: function (event) {\n            event = this._touchToMouse(event);\n\n            return this._super(event);\n        },\n\n        /**\n         * Documents' 'touchend' event handler.\n         */\n        _onTouchEnd: function (event) {\n            $(document).trigger('mouseup');\n\n            return this._mouseUp(event);\n        },\n\n        /**\n         * Removes previously assigned touch handlers.\n         *\n         * @override\n         */\n        _mouseUp: function () {\n            this._removeTouchHandlers();\n\n            return this._superApply(arguments);\n        },\n\n        /**\n         * Removes previously assigned touch handlers.\n         *\n         * @override\n         */\n        _mouseDestroy: function () {\n            this._removeTouchHandlers();\n\n            return this._superApply(arguments);\n        },\n\n        /**\n         * Removes touch events from document object.\n         */\n        _removeTouchHandlers: function () {\n            $(document)\n                .off('touchmove.' + this.widgetName)\n                .off('touchend.' + this.widgetName)\n                .off('touchleave.' + this.widgetName);\n        },\n\n        /**\n         * Adds properties to the touch event to mimic mouse event.\n         *\n         * @param {Event} event - Touch event object.\n         * @returns {Event}\n         */\n        _touchToMouse: function (event) {\n            var orig = event.originalEvent,\n                touch = orig.touches[0];\n\n            return _.extend(event, {\n                which:      1,\n                pageX:      touch.pageX,\n                pageY:      touch.pageY,\n                clientX:    touch.clientX,\n                clientY:    touch.clientY,\n                screenX:    touch.screenX,\n                screenY:    touch.screenY\n            });\n        }\n    });\n\n    return $.mage.touchSlider;\n});\n","mage/translate-inline.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'mage/template',\n    'mage/utils/misc',\n    'mage/translate',\n    'jquery-ui-modules/dialog'\n], function ($, mageTemplate, miscUtils) {\n    'use strict';\n\n    $.widget('mage.translateInline', $.ui.dialog, {\n        options: {\n            translateForm: {\n                template: '#translate-form-template',\n                data: {\n                    id: 'translate-inline-form',\n                    message: 'Please refresh the page to see your changes after submitting this form.'\n                }\n            },\n            autoOpen: false,\n            translateArea: null,\n            modal: true,\n            dialogClass: 'popup-window',\n            width: '75%',\n            title: $.mage.__('Translate'),\n            height: 470,\n            position: {\n                my: 'left top',\n                at: 'center top',\n                of: 'body'\n            },\n            buttons: [{\n                text: $.mage.__('Submit'),\n                'class': 'action-primary',\n\n                /**\n                 * Click\n                 */\n                click: function () {\n                    $(this).translateInline('submit');\n                }\n            },\n            {\n                text: $.mage.__('Close'),\n                'class': 'action-close',\n\n                /**\n                 * Click.\n                 */\n                click: function () {\n                    $(this).translateInline('close');\n                }\n            }],\n\n            /**\n             * Open.\n             */\n            open: function () {\n                var $uiDialog = $(this).closest('.ui-dialog'),\n                    topMargin = $uiDialog.children('.ui-dialog-titlebar').outerHeight() + 45;\n\n                $uiDialog\n                    .addClass('ui-dialog-active')\n                    .css('margin-top', topMargin);\n            },\n\n            /**\n             * Close.\n             */\n            close: function () {\n                $(this).closest('.ui-dialog').removeClass('ui-dialog-active');\n            }\n        },\n\n        /**\n         * Translate Inline creation\n         * @protected\n         */\n        _create: function () {\n            var $translateArea = $(this.options.translateArea);\n\n            if (!$translateArea.length) {\n                $translateArea = $('body');\n            }\n            $translateArea.on('edit.editTrigger', $.proxy(this._onEdit, this));\n\n            this.tmpl = mageTemplate(this.options.translateForm.template);\n\n            this._super();\n        },\n\n        /**\n         * @param {*} templateData\n         * @return {*|jQuery|HTMLElement}\n         * @private\n         */\n        _prepareContent: function (templateData) {\n            var data = $.extend({\n                items: templateData,\n                escape: miscUtils.escape\n            }, this.options.translateForm.data);\n\n            this.data = data;\n\n            return $(this.tmpl({\n                data: data\n            }));\n        },\n\n        /**\n         * Render translation form and open dialog\n         * @param {Object} e - object\n         * @protected\n         */\n        _onEdit: function (e) {\n            this.target = e.target;\n            this.element.html(this._prepareContent($(e.target).data('translate')));\n            this.open(e);\n        },\n\n        /**\n         * Submit.\n         */\n        submit: function () {\n            if (this.formIsSubmitted) {\n                return;\n            }\n            this._formSubmit();\n        },\n\n        /**\n         * Send ajax request on form submit\n         * @protected\n         */\n        _formSubmit: function () {\n            var parameters = $.param({\n                    area: this.options.area\n                }) + '&' + $('#' + this.options.translateForm.data.id).serialize();\n\n            this.formIsSubmitted = true;\n\n            $.ajax({\n                url: this.options.ajaxUrl,\n                type: 'POST',\n                data: parameters,\n                loaderContext: this.element,\n                showLoader: true\n            }).complete($.proxy(this._formSubmitComplete, this));\n        },\n\n        /**\n         * @param {Object} response\n         * @private\n         */\n        _formSubmitComplete: function (response) {\n            this.close();\n            this.formIsSubmitted = false;\n            this._updatePlaceholder(response.responseJSON[this.data.items[0].original]);\n        },\n\n        /**\n         * @param {*} newValue\n         * @private\n         */\n        _updatePlaceholder: function (newValue) {\n            var $target = $(this.target),\n                translateObject = $target.data('translate')[0];\n\n            translateObject.shown = newValue;\n            translateObject.translated = newValue;\n\n            $target.html(newValue);\n        },\n\n        /**\n         * Destroy translateInline\n         */\n        destroy: function () {\n            this.element.off('.editTrigger');\n            this._super();\n        }\n    });\n\n    return $.mage.translateInline;\n});\n","mage/translate.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'mage/mage',\n    'mageTranslationDictionary',\n    'underscore'\n], function ($, mage, dictionary, _) {\n    'use strict';\n\n    $.extend(true, $, {\n        mage: {\n            translate: (function () {\n                /**\n                 * Key-value translations storage\n                 * @type {Object}\n                 * @private\n                 */\n                var _data = dictionary;\n\n                return {\n                    /**\n                     * Add new translation (two string parameters) or several translations (object)\n                     */\n                    add: function () {\n                        if (arguments.length > 1) {\n                            _data[arguments[0]] = arguments[1];\n                        } else if (typeof arguments[0] === 'object') {\n                            $.extend(_data, arguments[0]);\n                        }\n                    },\n\n                    /**\n                     * Make a translation with parsing (to handle case when _data represents tuple)\n                     * @param {String} text\n                     * @return {String}\n                     */\n                    translate: function (text) {\n                        return typeof _data[text] !== 'undefined' ? _data[text] : text;\n                    }\n                };\n            }())\n        }\n    });\n    $.mage.__ = $.proxy($.mage.translate.translate, $.mage.translate);\n\n    // Provide i18n wrapper to be used in underscore templates for translation\n    _.extend(_, {\n        /**\n         * Make a translation using $.mage.__\n         *\n         * @param {String} text\n         * @return {String}\n         */\n        i18n: function (text) {\n            return $.mage.__(text);\n        }\n    });\n\n    return $.mage.__;\n});\n","mage/trim-input.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery'\n], function ($) {\n    'use strict';\n\n    $.widget('mage.trimInput', {\n        options: {\n            cache: {}\n        },\n\n        /**\n         * Widget initialization\n         * @private\n         */\n        _create: function () {\n            this.options.cache.input = $(this.element);\n            this._bind();\n        },\n\n        /**\n         * Event binding, will monitor change, keyup and paste events.\n         * @private\n         */\n        _bind: function () {\n            if (this.options.cache.input.length) {\n                this._on(this.options.cache.input, {\n                    'change': this._trimInput,\n                    'keyup': this._trimInput,\n                    'paste': this._trimInput\n                });\n            }\n        },\n\n        /**\n         * Trim value\n         * @private\n         */\n        _trimInput: function () {\n            // Safari caret position workaround: storing carter position\n            var caretStart, caretEnd, input;\n\n            caretStart = this.options.cache.input.get(0).selectionStart;\n            caretEnd = this.options.cache.input.get(0).selectionEnd;\n\n            input = this._getInputValue().trim();\n\n            this.options.cache.input.val(input);\n\n            // Safari caret position workaround: setting caret position to previously stored values\n            if (caretStart !== null && caretEnd !== null) {\n                this.options.cache.input.get(0).setSelectionRange(caretStart, caretEnd);\n            }\n        },\n\n        /**\n         * Get input value\n         * @returns {*}\n         * @private\n         */\n        _getInputValue: function () {\n            return this.options.cache.input.val();\n        }\n    });\n\n    return $.mage.trimInput;\n});\n","mage/url.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\n/* eslint-disable strict */\ndefine([], function () {\n    var baseUrl = '';\n\n    return {\n        /**\n         * @param {String} url\n         */\n        setBaseUrl: function (url) {\n            baseUrl = url;\n        },\n\n        /**\n         * @param {String} path\n         * @return {*}\n         */\n        build: function (path) {\n            if (path.indexOf(baseUrl) !== -1) {\n                return path;\n            }\n\n            return baseUrl + path;\n        }\n    };\n});\n"}
}});
